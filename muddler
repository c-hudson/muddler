#!/usr/bin/env perl
#-#         ( A 90dies mud client written today ) 
#-#       o               v1.0a                   
#-#      o _____                __  __ _          
#-#    _||_| u |    _ _  _ _ __| /_| /| |  __ ____
#-#   (        |== / v \| | |  _ | _ || |/ -_) __/
#-#   /-()---()   |_|_|_|___/\___\___/|_|\__/_/   
#
# Note: A large section of the javascript, html, css came from Grapenut's
#       websocket client and has been embeded into this perl script.
#       I'm betting this is okay considering the license is described as:
#       There is no license. Just make a neato game with it.
#
#       Project's location: https://github.com/grapenut/websockclient

use 5.014;                                                   # enable utf8
use IO::Socket;
use utf8;
use POSIX;
use strict;
binmode(STDOUT, ":utf8");
my ($term, $oterm, $echo, $noecho, $fd_stdin, $ctx,$SSL_ERROR); # required for cbreak/etc

# use Monitor qw(monitor);

use Carp;
my %key;                            # key presses hash table for fast lookups
my %history;                                                  # world history
my %socket;                                              # socket information
my %socket_lookup;
my %command;                            # command hash table for fast lookups
my %address;                                                # world addresses 
my %help;                                                         # help data
my @input;                                                    # input history
my %ws;                                             # websocket specific data
my $ws_listen;                                           # websocket listener
my $ws_server;                                             # websocket server
my $http_listen;                                              # http listener
my %http;                               # data structure for http connections
my %http_data;                                 # store websocket client pages
my %def;                                        # tf style define information
my %pid;                                              # internal process list
my %telnet_ch;
my %cache;
my $client;                                                # websocket client
my $wc;                                                    # websocket client
my %var;                                                 # settable variables
my @options = qw(
    BINARY ECHO RCP SGA NAMS STATUS TM RCTE NAOL NAOP NAOCRD NAOHTS NAOHTD
    NAOFFD NAOVTS NAOVTD NAOLFD XASCII LOGOUT BM DET SUPDUP SUPDUPOUTPUT SNDLOC
    TTYPE EOR TUID OUTMRK TTYLOC VT3270REGIME X3PAD NAWS TSPEED LFLOW LINEMODE
    XDISPLOC OLD_ENVIRON AUTHENTICATION ENCRYPT NEW_ENVIRON
);

my %state = (
   line_pos        => 0,           # character position on the current line
   size_x          => 24,                     # size of screen horizontally
   size_y          => 80,                  # size of the screen veritically
   input_offset    => 0,                   # lines scrolled off input buffer
   input_pos       => -1,                        # location in input history
   line            => [],                                # curent input line
   pending         => {},
   web             => 0,                        # websocket enabled/disabled
   console         => 1,                            # disable console output
   p_password      => "xyzzy",
   p_color         => "light",                     # default websocket theme
   p_port          => 9000,                 # web/websock port starting port
   p_debug         => 0,                   # store debuging info to log file
   p_more          => 1,                                      # enable /more
   overlap         => 3,                        # keep X lines from previous
                                                     # output when scrolling
   world           => "muddler",    # starting "world" to make coding easier
   activity        => {},                       # store worlds with activity
);

#                                    cpan => "perl -MCPAN -e \"install " .
#                                           "Net::WebSocket::Server\"",
my %mod = (
   'Term::ReadKey'               => { fatal => 0,
                                      pkg => "libterm-readkey-perl",
                                      for => 'screen size detection'
                                    },
   'Net::WebSocket::Server'      => { fatal => 0,
                                      cpan => "yes",
                                      for => 'web gui'
                                    },
   'Encode'                      => { fatal => 0,
                                      for => "utf8/fansi"
                                    },
   'Digest::MD5'                 => { fatal => 0,
                                      pkg => "Digest::MD5",
                                      for => "caching/code reloading"
                                    },
   'Text::Aspell'                => { fatal => 0,
                                      pkg => "libtext-aspell-perl", 
                                      for => 'spell check' },
   'IO::Socket::SSL'             => { fatal => 0,
                                      for => 'ssl'
                                    },
   'IO::Select'                  => { fatal => 1,
                                      for => 'networking'
                                    },
   'IO::Socket'                  => { fatal => 1,
                                      for => 'networking'
                                    },
   'Text::ParseWords'            => { fatal => 0,
                                      for => 'tf compat'
                                    },
   'IO::Socket::Timeout'         => { fatal => 0,
                                      for => 'ssl websockets',
                                      pkg => "libio-socket-timeout-perl"
                                    },
   'Protocol::WebSocket::Client' => { fatal => 0,
                                        for => 'remote console',
                                    },

);
#
# define all keys/commands in a manor so that they can be reloaded
# while the program is still running.
#
sub key_init
{
   delete @key{keys %key};
   @key{def}                  = sub { return key_default(@_);          };
   @key{1}                    = sub { return key_ctl_a(@_);            };
   @key{2}                    = sub { return key_left(@_);             };
   @key{4}                    = sub { return key_dump(@_);             };
   @key{5}                    = sub { return key_ctl_e(@_);            };
   @key{6}                    = sub { return key_right(@_);            };
   @key{8}                    = sub { return key_delete(@_);           };
   @key{9}                    = sub { return key_tab(@_);              };
   @key{10}                   = sub { return key_return(@_);           };
   @key{12}                   = sub { return key_ctl_l(@_);            };
   @key{14}                   = sub { return key_ctl_n(@_);            };
   @key{16}                   = sub { return key_ctl_p(@_);            };
   @key{18}                   = sub { return key_ctl_r(@_);            };
   @key{21}                   = sub { return key_ctl_u(@_);            };
   @key{23}                   = sub { return key_ctl_w(@_);            };
   @key{27}                   = sub { return key_escape(@_);           };
   @key{127}                  = sub { return key_delete(@_);           };
   @key{multi}                = sub { return key_multi(@_);            };
   @key{multi_119}            = sub { return key_esc_w(@_);            };
   @key{multi_113}            = sub { return key_esc_q(@_);            };
   @key{multi_106}            = sub { return key_esc_j(@_);            };
   @key{multi_91_53_126}      = sub { return key_pgup(@_);             };
   @key{multi_91_54_126}      = sub { return key_pgdn(@_);             };
   @key{multi_91_65}          = sub { return key_up(@_);               };
   @key{multi_91_66}          = sub { return key_down(@_);             };
   @key{multi_91_67}          = sub { return key_right(@_);            };
   @key{multi_91_68}          = sub { return key_left(@_);             };
   @key{multi_91_49_59_50_65} = sub { return key_shift_up(@_);         };
   @key{multi_91_49_59_50_66} = sub { return key_shift_down(@_);       };

   # populate the gaps so the code knows to traverse through all the
   # characters in the definition instead of just the last one.
   for my $key (grep {/^multi_/} keys %key) {
      my @list = split('_',$key);
      while($#list >= 1) {
         pop(@list);
         @key{join('_',@list)} = 1 if(!defined @key{join('_',@list)});
      }
   }
}

sub command_init
{
   delete @command{keys %command};
   @command{send}          = sub { return cmd_send(@_);                    };
   @command{blurred}       = sub { return cmd_blurred(@_);                 };
   @command{focused}       = sub { return cmd_focused(@_);                 };
   @command{stat}          = sub { return cmd_stat(@_);                    };
   @command{world}         = sub { return cmd_world(@_);                   };
   @command{quit}          = sub { return cmd_quit(@_);                    };
   @command{reload}        = sub { return cmd_reload(@_);                  };
   @command{dc}            = sub { return cmd_dc(@_);                      };
   @command{listsockets}   = sub { return cmd_listsockets(@_);             };
   @command{l}             = sub { return cmd_listsockets(@_);             };
   @command{recall}        = sub { return cmd_recall(@_);                  };
   @command{version}       = sub { return cmd_version(@_);                 };
   @command{help}          = sub { return cmd_help(@_);                    };
   @command{web}           = sub { return cmd_web(@_);                     };
   @command{port}          = sub { return cmd_port(@_);                    };
   @command{key_tab}       = sub { return key_tab(@_);                     };
   @command{key_esc_w}     = sub { return key_esc_w(@_);                   };
   @command{key_ctl_l}     = sub { return key_ctl_l(@_);                   };
   @command{key_up}        = sub { return key_up(@_);                      };
   @command{key_down}      = sub { return key_down(@_);                    };
   @command{key_pgdn}      = sub { return key_pgdn(@_);                    };
   @command{key_pgup}      = sub { return key_pgup(@_);                    };
   @command{web_size}      = sub { return cmd_web_size(@_);                };
   @command{repeat}        = sub { return cmd_repeat(@_);                  };
   @command{echo}          = sub { return cmd_echo(@_);                    };
   @command{ps}            = sub { return cmd_ps(@_);                      };
   @command{kill}          = sub { return cmd_kill(@_);                    };
   @command{def}           = sub { return cmd_def(@_);                     };
   @command{listdef}       = sub { return cmd_listdef(@_);                 };
   @command{listworlds}    = sub { return cmd_listworlds(@_);              };
   @command{ssl}           = sub { return cmd_ssl(@_);                     };
   @command{add}           = sub { return cmd_addworld(@_);                };
   @command{addworld}      = sub { return cmd_addworld(@_);                };
   @command{rc}            = sub { return read_tfrc("@ENV{HOME}/.tfrc");   };
   @command{keepalive}     = sub { return cmd_keepalive(@_);               };
   @command{color}         = sub { return cmd_color(@_);                   };
   @command{update}        = sub { return cmd_update(@_);                  };
   @command{sync}          = sub { return cmd_sync(@_);                    };
   @command{mobile}        = sub { return cmd_mobile(@_);                  };
   @command{allow}         = sub { return cmd_allow(@_);                   };
   @command{set}           = sub { return cmd_set(@_);                     };
   @command{log}           = sub { return cmd_log(@_);                     };
   @command{more}          = sub { return cmd_more(@_);                    };
   @command{common}        = sub { return cmd_common(@_);                  };
   @command{console}       = sub { return cmd_console(@_);                 };
   @command{utf8}          = sub { return cmd_utf8(@_);                    };
   @command{fansi}         = sub { return cmd_fansi(@_);                   };
   @command{latin}         = sub { return cmd_latin(@_);                   };
   @command{input_size}    = sub { return cmd_input_size(@_);              };
   @command{isize}         = sub { return cmd_input_size(@_);              };
   @command{perl}          = sub { return cmd_perl(@_);                    };
   @command{quote}         = sub { return cmd_quote(@_);                   };
   @command{window}        = sub { return cmd_window(@_);                  };
   #-----------------------------------------------------------------------#
   @command{clock}         = sub { return cmd_null(@_);                    };
   @command{lcd}           = sub { return cmd_null(@_);                    };
   @command{hilite_page}   = sub { return cmd_null(@_);                    };
   @command{hilite_whisper}= sub { return cmd_null(@_);                    };
   @command{status_rm}     = sub { return cmd_null(@_);                    },
   # @command{set}           = sub { return cmd_null(@_);                    };
   @command{load}          = sub { return cmd_null(@_);                    };
   @command{loadworld}     = sub { return load(@_);                        };
   @command{visual}        = sub { return cmd_null(@_);                    };
   @command{isize}         = sub { return cmd_null(@_);                    };
   @command{idleit}        = sub { return cmd_null(@_);                    };
   @command{saveworld}     = sub { return cmd_null(@_);                    };
}

sub cbreak {
    $term->setlflag($noecho);
    $term->setcc(VTIME, 1);
    $term->setattr($fd_stdin, TCSANOW);
}

sub normal {
    $term->setlflag($oterm);
    $term->setcc(VTIME, 0);
    $term->setattr($fd_stdin, TCSANOW);
}

#----------------------------------------------------------------------------#
#                                                                            #
#  modules                                                                   #
#                                                                            #
#----------------------------------------------------------------------------#

sub module_enabled
{
   my $txt = shift;

   if(!defined @state{"mod_$txt"} || @state{"mod_$txt"} == -1) {
      return 0;
   } else {
      return 1;
   }
 
}

#
# load_modules
#    There are probably a lot of better ways to do this, but the idea
#    is to provide a minor amount of help on those modules which are
#    required and allow the code to work around those which are not
#    required.
#
sub load_modules
{
   @state{modules} = [];
   my $type;

   for my $key (keys %mod) {
      if(!defined @state{"mod_@mod{$key}"} || @state{"mod_@mod{$key}"} == -1) {
         @state{"mod_$key"} = 1;
         eval "use $key; 1;" or @state{"mod_$key"} = -1;

         if(@state{"mod_$key"} == -1) {
            if(@mod{$key}->{fatal} != -1) {
               if(@mod{$key}->{fatal}) {
                  $type = "FATAL";
                  @state{fatal} = 1;
               } else {
                  $type = "WARNING";
               }
               
               push(@{@state{modules}},sprintf("module %s is missing for %s.\n",
                    $key,@mod{$key}->{for}));
            }
         }
      }
   }
   
   if(@state{fatal}) {
      for my $i (0 .. $#{@state{modules}}) {
         printf("%s",@state{modules}->[$i]);
      }
   }
   exit() if @state{fatal};
}


#----------------------------------------------------------------------------#
#                                                                            #
#  ansi support                                                              #
#    Routines taken from teenymush. This should probably be turned into a    #
#    module if i liked using multiple files.                                 #
#                                                                            #
#----------------------------------------------------------------------------#
#
# ansi_debug
#    Convert an ansi string into something more readable.
#
sub ansi_debug
{
    my $txt = shift;

    $txt =~ s/\e/<ESC>/g;
    return $txt;
}


#
# ansi_char
#    Returns one character of the current string. Due to the nature of the
#    ansi functions, this will only return characters not in ansi character
#    strings. While this is silly to use a function to do this, this helps
#    abstract the data set for situations in which the ansi functions are
#    replaced by standard string functions.
#
sub ansi_char
{
   my ($data,$pos) = @_;

   return @{$$data{ch}}[$pos];
}


sub is_ansi_string
{
   my $txt = shift;

   if(ref($txt) ne "HASH" ||
      !defined $$txt{ch} ||
      !defined $$txt{snap} ||
      !defined $$txt{code}) {
      return 0;
   } else {
      return 1;
   }
}


sub ansi_reset
{
   my ($data,$pos) = @_;

   my $string = (is_ansi_string($data)) ? $data : ansi_init($data);

   return $string if $pos < 0;                               # sanity check

   my $code = $$string{code};
   my $array = $$code[$pos];

   # check to see if the last code is a reset, or no codes at all
   if($#$array == -1 || $$array[$#$array] ne "\e[0m") {
      push(@$array,"\e[0m");
   }
   return $string;
}
#
# ansi_add
#   Add a character or escape code to the data array. Every add of a
#   character results in a new element, escape codes are added to existing
#   elements as long as a character has not been added yet. The ansi state
#   is also kept track of here.
#
sub ansi_add
{
   my ($data,$type,$txt) = @_;

   my $ch   = $$data{ch};                      # make things more readable
   my $code = $$data{code};
   my $snap = $$data{snap};

   if($#$ch == -1 || $$ch[$#$ch] ne undef) {
      $$ch[$#$ch+1] = undef;
      $$code[$#$ch] = [];
      $$snap[$#$ch] = [];
   }

   if($type) {
     for my $c (split(//,$txt)) {                 # add multiple characters
        $$ch[ $#$ch + ((@$ch[$#$ch] ne undef) ? 1 : 0) ] = $c;
        @$code[$#$ch] = [] if(!defined @$code[$#$ch]);
        @$snap[$#$ch] = [ @{@$data{state}} ];
     }
   } else {                                           # add escape sequence
      push(@{$$code[$#$ch]},$txt);
      if($txt eq "\e[0m") {
         $$data{state} = [];
      } else {
         push(@{$$data{state}},$txt);
      }
   }
}


#
# ansi_init
#    Read in a string and convert it into a data structure that can be
#    easily parsed / modified, i hope.
#
#     {
#       code => [ [ array of arrays containing escape codes ] ]
#       ch   => [ Array containing each character one by one ]
#       snap => [ [ array of arrays containing all active escape codes
#                   at the time the character was encountered ] ]
#       state=> [ internal, current state of active escape does ]
#     }
#
sub ansi_init
{
   my $str = shift;
   my $digest;

   if(module_enabled("Digest::MD5")) {
      $digest = Digest::MD5::md5_hex(encode_utf8($str));
      @state{init_cache} = {} if(!defined @state{init_cache});

      if(defined @state{init_cache}->{$digest}) {
          @state{init_cache_count}++;
          return @state{init_cache}->{$digest};
      }
   }

   my $data = { ch => [], code => [], state  => [], snap   => [] };

   while($str =~ /\e\[([\d;]*)([a-zA-Z])/) {
      $str = $';
      ansi_add($data,1,$`) if $` ne undef;
      ansi_add($data,0,"\e[$1$2");
   }
   ansi_add($data,1,$str) if($str ne undef);

   if(module_enabled("Digest::MD5")) {
      @state{init_cache}->{$digest} = $data;
   }

   return $data;
}

#
# ansi_clone
#   Clone the ansi escape codes at a particular position to the new
#   string.
#
sub ansi_clone
{
   my ($str,$pos,$txt) = @_;

   if(ref($str) ne "HASH") {
      $str = ansi_init($str);
   }

   my $snap = $$str{snap};

   if($#$snap >= 0 && $#$snap > $pos) {
      return join('',@{@$snap[$pos]}) . $txt . "\e[0m";
   } else {
      return $txt;
   }
}

#
# ansi_string
#    Take ansi data structure and return
#        type => 0 : everything but the escape codes
#        type => 1 : original string [including escape codes]
#
sub ansi_string
{
   my ($data,$type) = @_;
   my $buf;

   for my $i (0 .. $#{$$data{ch}}) {
      $buf .= join('', @{@{$$data{code}}[$i]}) if($type);
      $buf .= @{$$data{ch}}[$i];
   }
   return $buf;
}



sub dearray
{
   my $data = shift;
   my $buf;

   for my $i (0 .. $#{$$data{ch}}) {
      $buf .= join('', @{@{$$data{code}}[$i]});
      $buf .= @{$$data{ch}}[$i];
   }
   return $buf;
}

sub txt
{
   my @data = @_;
   my @out;

   for my $i (0 .. $#data) {
      push(@out,dearray(@data[$i]));
   }
   return @out;
}


#
# ansi_substr
#    Do a substr on a string while preserving the escape codes.
#
#    no-ansi flag : do not copy over escape sequences
#
sub ansi_substr
{
   my ($data,$start,$count,$noansi) = @_;
   my ($result,$i);

   $data = ansi_init($data) if(ref($data) ne "HASH");
   $start = 0 if($start !~ /^\s*\d+\s*$/);                 # sanity checks
   if($count !~ /^\s*\d+\s*$/) {
      $count = ansi_length($data);
   } else {
      $count += $start;
   }
   return undef if($start < 0);                         # no starting point

   my $new = { ch => [], code => [], state  => [], snap   => [] };

   my $pos = 0;
   # copy each "character" w/attached ansi codes
   for($i = $start;$i < $count && $i <= $#{$$data{ch}};$i++) {
      # add each escape code one at a time
      $$new{code}->[$pos] = [];

      if(!$noansi) {
         for my $x (0 .. $#{$$data{code}->[$i]}) {
            $$new{code}->[$pos]->[$x] = $$data{code}->[$i]->[$x];
         }

         for my $x (0 .. $#{$$data{snap}->[$i]}) {
            $$new{snap}->[$pos]->[$x] = $$data{snap}->[$i]->[$x];
         }
      }
      $$new{ch}->[$pos] = $$data{ch}->[$i];
      # add the character that follows the escape code (if any)
      $pos++;
   }

   # add ending clear of all attributes to prevent bleeding
   
   if($i >= 1 && $#{$$data{snap}->[$i-1]} != -1) {
      $$new{ch}->[$pos] = "";
      $$new{code}->[$pos] = [ chr(27) . "[0m" ];
      $$new{snap }->[$pos] = [];
   }


#   ansi_add($new,0,chr(27) . "[0m") if($#{$$data{snap}->[$i-1]} != -1);

   return $new;
}


#
# ansi_length
#    Return the length of a string without counting all those pesky escape
#    codes.

sub ansi_length
{
   my $txt = shift;
   my $data = shift;

   if(ref($txt) eq "HASH") {                           # already inited txt?
      $data = $txt;
   } else {
      return length(ansi_remove($txt));
      $data = ansi_init($txt);
   }

   if($#{$$data{ch}} == -1) {                                       # empty
      return 0;
   } elsif(@{$$data{ch}}[-1] eq undef) {               # last char pos empty?
      return $#{$$data{ch}};
   } else {
      return $#{$$data{ch}} + 1;                        # last char populated
   }
}
#
# ansi_remove
#    remove any escape codes from the string
#
sub ansi_remove
{
#   my $txt = ansi_init(shift);
#   return ansi_print($txt,0);

   my $txt = shift;
   $txt =~ s/\e\[[\d;]*[a-zA-Z]//g;
   return $txt;
}


#----------------------------------------------------------------------------#
#                                                                            #
#  pmc support                                                               #
#                                                                            #
#----------------------------------------------------------------------------#

# sub TELQUAL_IS   { 0; }
# sub TELQUAL_SEND { 1; }
# sub TELOPT_MXP   { 91; }
# sub TELOPT_MSP   { 90; }
# 
# sub negotiation {
#     my ($conn, $option, $is_remote, $is_enabled, $was_enabled,
#         $buf_position)= @_;
#     $is_remote||=0;
#     $is_enabled||=0;
#     $was_enabled||=0;
#     my ($noecho, $linemode);
# 
# #    debug("negotiation: $option rem:$is_remote is_en:$is_enabled ".
# #          "was_en:$was_enabled");
# 
#     if ($option==TELOPT_TTYPE) {
#         send_iac($conn,chr(TELNET_SB).
#                  chr(TELOPT_TTYPE).
#                  chr(TELQUAL_IS).
#                  $ENV{TERM}.
#                  chr(TELNET_IAC).
#                  chr(TELNET_SE)
#                 );
#     } elsif($option == TELOPT_NAWS) {
#         send_naws($conn,1);
#     } elsif ($option==TELOPT_ECHO) {
#         if ($is_enabled) {
#             $noecho=1;
#         } else {
#             $noecho=0;
#         }
#         switch_echo();
#     } elsif ($option==TELOPT_SGA) {
#         if ($linemode && $is_enabled) {
#             debug('char-mode');
#             ReadMode(4);
#         } elsif (!$is_enabled && !$linemode) {
#             debug('line-mode');
#             ReadMode(0);
#         }
#         $linemode= !$is_enabled;
#     } elsif ($option==TELOPT_MXP || $option==TELOPT_MSP) {
#     } else {
#     }
# }
# 
# sub send_iac {
#     my ($conn,$neg) = @_;
# 
#     syswrite $conn, chr(TELNET_IAC).$neg, length($neg)+1, 0;
# }
# 
# sub check_mcp_naws {
#    return 0;
# }
# 
# sub send_naws {
#     my ($conn,$from_telopt)= @_;
# 
# #    my ($height,$width)= $term->get_screen_size();
#     my ($height,$width) = (24,80);
#     if (check_mcp_naws() && !$from_telopt) {
#         mcp_send('dns-com-vmoo-client-screensize',
#                 jols => $width, rows => $height);
#     } else {
#         send_iac($conn,chr(TELNET_SB).chr(TELOPT_NAWS).chr($width/256).
#                  chr($width%256).chr($height/256).chr($height%256).
#                  chr(TELNET_IAC).chr(TELNET_SE));
#     }
# }

#----------------------------------------------------------------------------#
#                                                                            #
#  tcp code                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

#
# BEGIN statement with including code, and most of socket_connect were
# copied from from: http://aspn.activestate.com/ASPN/Mail/Message/
# perl-win32-porters/1449297.
#
# BEGIN {
#    # This nonsense is needed in 5.6.1 and earlier -- I'm too lazy to
#    # test if it's been fixed in 5.8.0.
#    if( $^O eq 'MSWin32' ) {
#       *EWOULDBLOCK = sub () { 10035 };
#       *EINPROGRESS = sub () { 10036 };
#       *IO::Socket::blocking = sub {
#           my ($self, $blocking) = @_;
#           my $nonblocking = $blocking ? "0" : "1";
#           ioctl($self, 0x8004667e, $nonblocking);
#       };
#    } else {
#       require Errno;
#       import  Errno qw(EWOULDBLOCK EINPROGRESS);
#    }
# }

# sub socket_connect
# {
#    my ($world,$host,$port,$ssl) = ( lc(shift), @_ );
# 
#    if(defined @socket{$world} && @socket{$world}->{sock}) {
#       return echo("%% Already connected to %s",$world);
#    }
# 
#    @history{$world} = [];
#    @pending{$world} = [] if !defined @pending{$world};
#    @socket{$world} = { name      => $world,
#                        host      => $host,
#                        port      => $port,
#                        more      => 0,
#                        more_last => 0,
#                        last_read => -1,
#                      };
#    @state{world} = $world;
#    @socket{$world}->{pos} = scalar keys %socket;
# 
#    my $s = new Pmc::Telnet( $host, $port, $ssl, Timeout => 10);
#    loggit("name=$world,host=$host,port=$port");
# 
#    if(!$s) {
#       draw_bar();
#       return echo("%% Connection Failed.");
#    }
# 
#    $s->option_callback(\&negotiation);
#    $s->option_accept( Do   => TELOPT_SGA,
#                       Do   => TELOPT_TTYPE,
#                       Do   => TELOPT_NAWS,
#                       Do   => TELOPT_ECHO,
#                       Dont => TELOPT_MXP,
#                       Dont => TELOPT_MSP,
#                       Wont => TELOPT_MXP,
#                       Wont => TELOPT_MSP,
#                       Will => TELOPT_SGA,
#                       Will => TELOPT_TTYPE,
#                       Will => TELOPT_NAWS,
#                       Will => TELOPT_ECHO);
#    @socket{$world}->{sock} = $s;
#    echo("%% Connection to %s succeeded.",$world);
#    if(defined @address{$world}->{user} && defined @address{$world}->{pass}) {
#       out($world,
#            "connect %s %s\n",
#            @address{$world}->{user},
#            @address{$world}->{pass}
#           );
#    }
#    draw_bar();
# }

sub socket_connect
{
   my ($conn,$world,$host,$port,$ssl,$opt) =
      (shift,lc(shift),shift,shift,shift,shift);
   my $s;


   $opt = {} if $opt eq undef;
   if(defined @socket{$world} && @socket{$world}->{sock}) {
      return echo("%% Already connected to %s",$world);
   }

   # initialize history buffer
   @history{$world} = [] if(!defined @history{$world});
 
   if(defined @socket{$world}) { # address may have changed?
      @socket{$world}->{host} = $host;
      @socket{$world}->{port} = $port;
   } else {
      # define connection with everything that is needed.
      @socket{$world} = { name      => $world,
                          host      => $host,
                          port      => $port,
                          more      => -1,
                          more_count=> 0,
                          last_read => -1,
                          history_pos => -1,
                          history_pos_partial => -1,
                        };
   }

   if(!defined @address{$world}->{decode}) {      # default to utf8 decoding.
       @address{$world}->{decode} = "utf8";
   }

   @socket{$world}->{pos} = ++@state{pos_sequence};
#   Monitor::monitor(@socket{$world}, "hash");

   
   if($ssl && !module_enabled("IO::Socket::SSL")) {
      return echo("%% module IO::Socket::SSL is required for SSL connections.");
   } elsif($ssl) {
      $s = IO::Socket::SSL->new( PeerAddr => $host,
                                 PeerPort => $port,
                                 Proto => 'tcp',
                                 SSL_use_cert => 0,
                                 SSL_verify_mode => 0,
                                );
   } else {
      $s = IO::Socket::INET->new(Proto => 'tcp',
                                 Blocking => 0) ||
         return echo("%% Connect %s : Socket error : %s",$world,$!);

      my $iaddr = inet_aton(trim($host)) ||
         return echo("%% Connect %s : Unknown host '%s'",$world,$host);

      my $paddr = sockaddr_in($port,$iaddr);

      my $ret = connect($s,$paddr);

      if(!$ret && ! $!{EINPROGRESS}) {
         return echo("%% Connect %s : Unable to connect",$world);
      }
   }

   if(!$s) {
      draw_bar();
      return echo("%% Connection Failed.");
   }


   @socket{$world}->{sock} = $s;
   switch_world($conn,$world);

   $ws_server->{select_readable}->add( $s );

   @socket_lookup{$s} = $world;
   delete @socket{muddler};

   () = IO::Select->new($s)->can_write(.2)    # see if socket is pending
      or @socket{$world}->{socket_pending} = 1;

   if(defined @socket{$world}->{socket_pending} &&
      defined @socket{$world}->{socket_pending} == 1) {
      echo("%% Connection to %s started, connection is pending.",$world);
   } else {
      echo("%% Connection to %s succeeded.",$world);
   }

   if(!defined $$opt{l} && 
      @address{$world}->{user} && 
      defined @address{$world}->{pass}) {
      out($world,
           "connect %s %s\n",
           @address{$world}->{user},
           @address{$world}->{pass}
          );
   }

   draw_bar();
}

#
# wc_init
#    Connect to the websocket server at the port defined in the command
#    line or default to localhost:9001.
#
sub wc_init
{
   my $gui = shift;
   my ($host,$port) = @_;

   if(defined @state{remote_address}) {
      if(@state{remote_address} =~ /^\s*([^:]+)\s*:\s*(\d+)\s*$/) {
         ($host,$port) = ($1,$2);
      } else {
         die("Invalid format to remote address, expected  --remote=host:port");
      }
    } else {
         ($host,$port) = ("127.0.0.1",9001);
    }

    $wc = IO::Socket::SSL->new(PeerAddr => $host,
                                  PeerPort => $port,
                                  Proto => 'tcp',
                                  SSL_startHandshake => 0,
                                     #($proto eq 'wss' ? 1 : 0),
                                  Blocking => 1) or
       err("Failed to connect to $host on port $port:  $@");

   $client = Protocol::WebSocket::Client->new(
       url => "ws://$host:$port");

   # setup handlers
   $client->on( write   => sub { wc_write(@_); } );
   $client->on( connect => sub { wc_connect(@_); } );
   $client->on( error   => sub { wc_error(@_); } );
   $client->on( read    => sub { wc_read(@_); } );

   # add connection to the listener
   $ws_server->{select_readable}->add($wc);

   # connect to the server
   $client->connect;
}

#
# err
#    Save the error in the state variable. The END declarition will
#    then reset the terminal and show the messaqe afterwards.
#
sub err
{
   my $msg = shift;

   @state{err} = $msg;
   exit();
}

sub wc_write
{
   my ($client,$txt) = @_;

   syswrite($wc,$txt);
}

sub wc_connect
{
   my ($client,$txt) = @_;

   # the y size has 3 characters removed from it for better rendering,
   # but isn't needed when doing the internal client.. so remove the
   # fudge factor here by adding 3.
   wc_out("/web_size %s,%s\n",@state{size_x},@state{size_y}+3);

   if(defined @state{window_value}) {
      wc_out("/window socket=@state{window_value}\n");
   } else {
      wc_out("/key_ctl_l\n",@state{size_x},@state{size_y});
      wc_out("/focused\n");
   }
}

sub wc_error
{
   my ($client,$buf) = @_;

   loggit("WC_ERROR: '%s'\n",$buf);
}

sub wc_out
{
   my ($fmt,@args) = @_;

   return if(!defined $client);
#   loggit("SEND: 't$fmt'\n",@args);
   $client->write(sprintf("t$fmt",@args));
}

sub wc_read
{
   my ($client,$buf) = @_;

   my $tmp=$buf;
   $tmp =~ s/\r|\n//g;
#   loggit("#> %s\n",$tmp);
   if($buf =~ /^m\r\n/) {
      printf("%s\n",$');
   } elsif($buf =~ /^d\r\npassword$/) {
      if(defined @state{p_password}) {
         wc_out("%s\n",@state{p_password});
      } else {
         show_banner();
         draw_bar();
         echo("%s","%% Enter muddler session password:");
      }
   } elsif(defined @state{monitor_value}) {
      return;
   } elsif($buf =~ /^(d|\*)\r\n/) {
      clear_screen();
   } elsif($buf =~ /^t\r\n/) {
      echo_console("%s",$');
   } elsif($buf =~ /^b\r\n/) {
      @state{remote_bar} = $';
      @state{remote_bar} =~ s/ /_/g;
      draw_bar();
   } else {
      loggit("Ignored: '%s'\n",$buf);
   }
}

sub is_enabled
{
    my $opt = shift;
 
    if(is_in($opt,"DO_SGA","DO_TTYPE","DO_NAWS","DO_ECHO","DONT_MXP",
             "DONT_MSP","WONT_MXP","WONT_MSP","WILL_SGA","WILL_TTYPE",
             "WILL_NAWS","WILL_ECHO")) {
       return 0;
    } else {
       return 0;
    }
}

sub telnet_ch_init
{
   delete @telnet_ch{keys %telnet_ch};

   @telnet_ch{normal} = 
      sub {
         my ($world,$ch) = @_;
        
         if($ch eq @state{IAC}) {
            return (undef, @state{IAC});
         } else {
            return $ch;
         }
      };

   @telnet_ch{@state{IAC}} =
      sub {
         my ($world,$ch) = @_;

         if($ch eq @state{IAC}) {
            return (@state{IAC}, 'normal');
         } elsif(is_in($ch,@state{DO},@state{DONT},@state{WILL},@state{WONT},
                 @state{SB})) {
            return (undef,$ch);
         } elsif($ch eq @state{NOP}) {                       # keep-a-live?
            return (undef, 'normal');
         } else {
            return (undef, 'normal');
         }
      };

   @telnet_ch{@state{DO}} =
      sub {
         my ($world,$opt, $mode) = @_;
 
#         loggit("telnet[$world]: %s %s",(@state{ord($mode)} || ord($mode)),
#             ($options[ord($opt)] || ord($opt)));
         my $wopt = $options[ord($opt)] || ord($opt);
         if(is_enabled((@state{ord($mode)} || ord($mode)) . "_" .
             ($options[ord($opt)] || ord($opt)))) {
            if ($mode eq @state{DO})   { 
#                loggit("telnet_send: IAC WILL $wopt");
                out_noret($world,@state{IAC}.@state{WILL}.$opt);
            } elsif ($mode eq @state{DONT}) {
#                loggit("telnet_send: IAC WONT $wopt");
                out_noret($world,@state{IAC}.@state{WONT}.$opt);
            } elsif ($mode eq @state{WONT}) {
#                loggit("telnet_send: IAC DONT $wopt");
                out_noret($world,@state{IAC}.@state{DONT}.$opt);
            } elsif ($mode eq @state{WILL}) {
#                loggit("telnet_send: IAC DO $wopt");
                out_noret($world,@state{IAC}.@state{DO}  .$opt);
            }
         } else {
            if ($mode eq @state{DONT}) {
#                loggit("telnet_send: IAC WILL $wopt");
               out_noret($world,@state{IAC}.@state{WILL}.$opt);
            } elsif ($mode eq @state{DO}) {
#                loggit("telnet_send: IAC WONT $wopt");
               out_noret($world,@state{IAC}.@state{WONT}.$opt);
            } elsif ($mode eq @state{WILL}) {
#                loggit("telnet_send: IAC WILL $wopt");
               out_noret($world,@state{IAC}.@state{DONT}.$opt);
            } elsif ($mode eq @state{WONT}) {
#                loggit("telnet_send: IAC WONT $wopt");
               out_noret($world,@state{IAC}.@state{DO}  .$opt);
            }
         }
         return (undef, 'normal');
      };

   @telnet_ch{@state{SB}} =
      sub {
         my ($world,$c) = @_;
         return (undef, 'sbiac') if $c eq @state{IAC};
         @state{telnet_sb_buffer} .= $c;
         return;
       };

   @telnet_ch{sbiac} =
       sub {
          my ($world,$c) = @_;

          if ($c eq @state{IAC}) {
              @state{telnet_sb_buffer} .= @state{IAC};
              return (undef, @state{SB});
          }

          if ($c eq @state{SE}) {
              _telnet_complex_callback(@state{telnet_sb_buffer});
              @state{telnet_sb_buffer} = '';
              return (undef, 'normal');
          }

          # IAC followed by something other than IAC and SE.. what??
          require Carp;
          Carp::croak "Invalid telnet stream: IAC SE ... IAC $c (chr ".chr($c).") ...";
      };
   $telnet_ch{@state{DONT}} = 
       $telnet_ch{@state{WILL}} = 
       $telnet_ch{@state{WONT}} =
       $telnet_ch{@state{DO}};
}

sub _parse
{
    my ($world,$in) = @_;
    my $out = '';

    # optimization: if we're in normal mode then we can quickly move all the
    # input up to the first IAC into the output buffer.
    if (@state{telnet_mode} eq 'normal') {
        # if there is no IAC then we can skip telnet entirely
        $in =~ s/^([^@state{IAC}]*)//o;
        return $1 if length $in == 0;
        $out = $1;
    }

    
    for my $c (split '', $in) {
        my ($o, $m) = $telnet_ch{@state{telnet_mode}}->
            ($world,$c, @state{telnet_mode});

        $out .= $o;
#        defined $o and $out .= $o;
        defined $m and @state{telnet_mode} = $m;
    }

    return $out;
}

sub socket_disconnect
{
   my $s = shift;

   $ws_server->{select_readable}->remove( $s );
   if(defined @socket_lookup{$s}) {
       delete @socket{@socket_lookup{$s}}->{sock};
       delete @socket_lookup{$s};
   }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  websocket support                                                         #
#    A mudding client with an http/websocket server? why not.                #
#                                                                            #
#----------------------------------------------------------------------------#

sub web
{
    return (@state{web} == 1) ? 1 : 0;
}

#
# server_hostname
#    lookup the hostname based upon the ip address
#
sub server_hostname
{
   my $sock = shift;
   my $ip = $sock->peerhost;                           # contains ip address

   my $name = gethostbyaddr(inet_aton($ip),AF_INET);

   if($name =~ /^\s*$/ || $name =~ /in-addr\.arpa$/) {
      return $ip;                            # last resort, return ip address
   } else {
      return $name;                                         # return hostname
   }
}


#
# remote
#    Determine if muddler is remotely 'viewing' a session or displaying
#    just information via another window. This should probably be two
#    different tests?
#
sub remote
{
   if((defined @state{remote} && @state{remote}) ||
      defined @state{window_value}) {
      return 1;
   } else {
      return 0;
   }
}

sub listener_init
{
   $ws_server->{select_readable}->add( \*STDIN );

   $fd_stdin = fileno(STDIN);

   $term     = POSIX::Termios->new();
   $term->getattr($fd_stdin);
   $oterm     = $term->getlflag();

   $echo     = ECHO | ECHOK | ICANON;
   $noecho   = $oterm & ~$echo;
}

sub ws_init
{
  
   # no websocket interface when using remote console
   return if remote();

   if(use_secure()) {
      $http_listen = IO::Socket::SSL->can_ipv6->new( LocalPort =>@state{p_port},
                                                     Listen    => 5,
                                                     Reuse     => 1,
                                                     timeout   => .1,
                                                   );
      if(!defined $http_listen) {
         echo("%% http server [Port:@state{p_port}] start failed: $!");
         return 0;
      }
      $ws_listen = IO::Socket::SSL->new(Listen             => 5,
                                        LocalPort          => @state{p_port}+1,
                                        Proto              => 'tcp',
                                        SSL_startHandshake => 0,
                                        SSL_cert_file      => @state{p_cert},
                                        SSL_key_file       => @state{p_key},
                                       );
      if(!defined $ws_listen) {
          echo("%% websocket server [Port:@state{p_port}] start failed: $!");
          return 0;
      }
      IO::Socket::Timeout->enable_timeouts_on($ws_listen);
      IO::Socket::Timeout->enable_timeouts_on($http_listen);
      $ws_listen->read_timeout(.5);
      $ws_listen->write_timeout(.5);
      $http_listen->read_timeout(.5);
      $http_listen->write_timeout(.5);

      $ctx = IO::Socket::SSL::SSL_Context->new(
          SSL_server => 1,
          SSL_cert_file => 'cert.pem',
          SSL_key_file  => 'key.pem',
          SSL_verify_mode => 0x00,  # SSL_VERIFY_PEER | 
                                    # SSL_VERIFY_FAIL_IF_NO_PEER_CERT
          ) or die "cannot create context: $SSL_ERROR";
      @state{secure} = 1;
   } else {
      $http_listen = IO::Socket::INET->new( LocalPort => @state{p_port},
                                            Listen    => 1,
                                            Reuse     => 1,
                                          )
      or die "failed to set up httpd listener: $!";
      $ws_listen = IO::Socket::INET->new( LocalPort => @state{p_port} + 1,
                                          Listen    => 1,
                                          Reuse     => 1,
                                        )
       or die "failed to set up websocket listener: $!";
      @state{secure} = 0;
   }

#   $ws_server = Net::WebSocket::Server->new(
#      listen => $ws_listen,
#      tick_period => 1,
#      on_connect => sub { my( $serv, $conn ) = @_;
#                          $conn->on( ready =>      sub{ ws_login_screen(@_); },
#                                     utf8  =>      sub{ ws_process( @_, 0 ); },
#                                     disconnect => sub{ ws_disconnect(@_);   },
#                                   );
#                        },
#      );
   @state{web} = 1;
   $ws_server->{select_readable}->add($ws_listen);
   $ws_server->{select_readable}->add($http_listen);
   $ws_server->{conns} = {};
   if(!console()) {
      printf("%% WEb enabled, connect via: http://localhost:@state{p_port}\n");
      printf("%%    Password: @state{p_password}\n");
   }
   return 1;
}

sub ws_disconnect
{
   my $conn = shift;
   my $sock;

#   loggit("ws_disconnect: '%s' [%s]\n",$conn,@ws{$conn});
   eval {             # don't know how to test if $conn{sock} is valid
      $sock = $conn->{sock};
      $ws_server->{select_readable}->remove( $sock );
      delete $ws_server->{conns}{$sock};
   };
   delete @ws{$conn};
   # $sock->close;
}

sub allowed
{
   my $ws = shift;

   if(defined @state{p_allow}) {
      for my $host (split(/,/,@state{p_allow})) {
         my $pat = glob2re($host);
         return 1 if(@ws{$ws}->{ip} =~ /$pat/i);
      }
   }
   return 0;
}

sub ws_login_screen
{
   my $ws = shift;
#   ws_echo($ws,"t",@state{version},1);

   if(defined @state{p_color}) {
      ws_echo($ws,"d","theme @state{p_color}",1);
   }

   if(allowed($ws)) {
      @ws{$ws}->{auth} = 1;
      echo("%% Allowed web connection from: %s",@ws{$ws}->{ip});
   } else {
      ws_echo($ws,"d","password",1);
   }
   
#   redraw_screen();
}

#
# ws_echo
#    The send might crash if the websocket has disconnected the evals should
#    probably be removed once this is more stable. With that in mind,
#    currently crash will be treated as a disconnect.
#
sub ws_echo
{
   my ($ws, $type, $msg,$force) = @_;

   # only show something if authorized or those exceptions when logging in
   return if(@ws{$ws}->{auth} eq 0 && !$force);

   # this might crash if the websocket dies, the evals should
   # probably be removed once this is more stable. With that in mind,
   # currently crash will be treated as a disconnect.

   #loggit("ws_echo: $type, $msg\n");

   if(defined @state{reverse_window} &&
      defined @state{reverse_window}->{$ws} &&
      $type ne "m") {
      return;
   }
   eval {
#      $ws->send('',$type . encode_utf8($msg) . "\r\n");
      $ws->send('',$type . "\r\n" . encode_utf8($msg));
   };
   if($@) {
      ws_disconnect($ws) if($@);
      loggit("FATALs: $@");
   }
}

#
# server_address
#    lookup the hostname based upon the ip address
#
sub server_address
{
   my $sock = shift;
   my $ip = $sock->peerhost;                           # contains ip address

   my $name = gethostbyaddr(inet_aton($ip),AF_INET);

   if($name =~ /^\s*$/ || $name =~ /in-addr\.arpa$/) {
      return $ip;                            # last resort, return ip address
   } else {
      return $name;                                         # return hostname
   }
}


#
# io
#    Handle any input / output such as http, https, websockets, secure
#    websockets, and keyboard.
#
sub io
{
   my $buf;
   

   my ($sockets) = IO::Select->select($ws_server->{select_readable},
                                      $ws_server->{select_writeable},
                                      undef,
                                      1
                                     );

   for my $sock (@$sockets) {
      if($sock eq \*STDIN) {
         sysread($sock,$buf,1);
         key_process($buf) if(console());
      } elsif(defined @socket_lookup{$sock}) {
         my $w = @socket_lookup{$sock};

         if(sysread($sock,$buf,10240) <= 0) {
            socket_disconnect($sock);                     # socket closed

            if(defined @socket{$w}->{socket_pending} == 1) {
               history($w,"% Connection timed out to ". name($w) . "-$sock");
            } else {
               history($w,"% Connection closed to ". name($w) . "-$sock");
            }
         } else {
            if(defined @socket{$w}->{socket_pending}) {
               delete @socket{$w}->{socket_pending};
            }
            @socket{$w}->{last_recv} = time();

            if(module_enabled("Encode")) {
               if(!defined @address{$w}->{decode}) {
                  @address{$w}->{decode} = "utf8";
               }
               @socket{$w}->{buf} .= decode(@address{$w}->{decode},
                                            _parse($w,$buf)
                                           );
            } else {
               @socket{$w}->{buf}.= _parse($w,$buf);
            }
   
            while(defined @socket{$w}->{sock} &&
                  @socket{$w}->{buf} =~ /\n/) {
                history($w,$`);
                @socket{$w}->{buf} = $';
             }
         }
      } elsif( $sock == $ws_listen ) {
         my $s = $ws_listen->accept or die("Couldn't accept connection");
         next unless $s;

         if(@state{secure}) {
             IO::Socket::SSL->start_SSL(
                 $s,
                 SSL_server    => 1,
                 SSL_reuse_ctx => $ctx,
             ) or do {
                loggit("ssl handshake failed: $!,$SSL_ERROR");
                $s->close;
                return;
             };
         }

         my $conn = new Net::WebSocket::Server::Connection(
                    socket => $s, server => $ws_server);
   
         $ws_server->{conns}{$s} = { conn     => $conn,
                                     lastrecv => time,
                                     ip       => server_hostname($s)
                                   };
         $ws_server->{select_readable}->add( $s );
         $ws_server->{on_connect}($ws_server, $conn );
         @ws{$conn} = {};
         @ws{$conn}->{conn} = $conn;
         @ws{$conn}->{start} = time();
         @ws{$conn}->{auth} = 0;
         @ws{$conn}->{ip} = server_hostname($s);
         @ws{$conn}->{port} = @state{p_port} + 1;
         @ws{$conn}->{world} = @state{world};
         @ws{$conn}->{active} = 1;            # assume window/tab is active
      } elsif($sock == $http_listen) {
         my $s;
         eval {
            $s = $sock->accept;
         };
         next unless $s;           # wrong type of connection http to https?

         $s->autoflush(1);

         if(@state{secure}) {
             IO::Socket::SSL->start_SSL(
                 $s,
                 SSL_server    => 1,
                 SSL_reuse_ctx => $ctx,
             ) or do {
                loggit("ssl handshake failed: $!,$SSL_ERROR");
                $s->close;
                return;
             };
         }
         $ws_server->{select_readable}->add($s);
         @http{$s} = { sock    => $s,
                       data    => {},
                       address => server_address($s)
                     };
      } elsif(defined @http{$sock}) {
         http_io($sock);
      } elsif( $ws_server->{watch_readable}{$sock} ) {
         $ws_server->{watch_readable}{$sock}{cb}( $ws_server , $sock );
      } elsif( $ws_server->{conns}{$sock} ) {
         my $connmeta = $ws_server->{conns}{$sock};
         $connmeta->{lastrecv} = time;
         $connmeta->{conn}->recv();
      } elsif( remote() && $sock == $wc) {
         if(sysread($sock,$buf,10240) <= 0) {
            err("%% Fatal : connection closed to remote muddler session");
         } else {
            $client->read($buf);
         }
      } else {
         loggit("filehandle $sock became readable, but no handler took " .
              "responsibility for it; removing it");
         loggit("listener: $ws_listen");
         $ws_server->{select_readable}->remove( $sock );
      }
   }
}


sub http_data_init
{
   my ($end,$pos);
   my ($fn,$src);

   delete @http_data{keys %http_data};
   # PAR archive will have the PAR_0 environment variable set
   if(@ENV{PAR_0}) {                              # read data from data segment
      return if defined @state{par_http_data_init};
      $src = do { local $/; <main::DATA> };          # note: will not change
      @state{par_http_data_init} = 1;
   } else {
      open($fn,$0) || return;                                 # read from file
      $src = do { local $/; <$fn> };                # which lets file change
      close($fn);
   }

   for my $line (split(/\n/,$src)) {
      s/\r//g;
      if($line =~ /^START: (.*)\s*$/) {
         ($pos,$end) = ($1,"__$2__");
      } elsif($pos ne undef) {
         s/^   //;
         @http_data{$pos} .= $line . "\n";
      }
   }
}

sub http_io
{
   my $sock = shift;
   my $buf;

   return http_disconnect($sock) if(!defined @http{$sock});
   @http{$sock}->{data} = {} if(!defined @http{$sock}->{data});
   my $data = @http{$sock}->{data};

   if(sysread($sock,$buf,1024) <= 0) {
      http_disconnect($sock);
   } else {
      $buf =~ s/\r//g;
      @http{$sock}->{buf} .= $buf;

      while(defined @http{$sock} && @http{$sock}->{buf} =~ /\n/) {
         @http{$sock}->{buf} = $';
         http_process_line($sock,$`);
      }
   }
}

sub http_timestamp
{
   my $seconds = shift;

   my @day = ("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
   my @month = ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
   my @list = gmtime($seconds);

   return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
                  @day[@list[6]],
                  @list[3],
                  @month[@list[4]], @list[5] + 1900,
                  @list[2],
                  @list[1],
                  @list[0]);
}

sub http_disconnect
{
   my $sock = shift;
   $ws_server->{select_readable}->remove($sock);
   delete @http{$sock};
   $sock->close;
}


sub http_process_line
{
   my ($sock,$txt) = @_;

   return http_disconnect($sock) if(!defined @http{$sock});
   @http{$sock}->{data} = {} if(!defined @http{$sock}->{data});
   my $data = @http{$sock}->{data};

   if($txt =~ /^GET (.*) HTTP\/([\d\.]+)$/i) {              # record details
      $$data{get} = $1;
   } elsif($txt =~ /^([\w\-]+): /) {
      http_error($sock,"%s","POST REQUEST TO BIG") if($' > 4096);
      $$data{"VAR_" . lc($1)} = $';
   } elsif($txt =~ /^\s*$/ && defined $$data{get}) {         # end of request
      $$data{get} =~ s/\// /g;
      $$data{get} =~ s/^\s+|\s+$//g;

      if($$data{get} eq undef) {
         $$data{get} = "muddler_client.html";
         my $tmp = @http_data{$$data{get}};
         my $port = @state{p_port} + 1;
         $tmp =~ s/9001/$port/;
         http_reply($sock,$data,"%s",$tmp);
      } elsif(!defined @http_data{$$data{get}}) {
         http_error($sock,"%s","Invalid path");
      } elsif(-e $$data{get}) {
         http_reply($sock,$data,"%s",getfile($$data{get}));
      } else {
         http_reply($sock,$data,"%s",@http_data{$$data{get}});
      }
   } else {
      http_error($sock,"Malformed Request");
   }
}

sub getfile
{
   my $fn = shift;
   my ($content,$file);
   open($file,$fn) || return undef;
   {
      local $/;
      $content = <$file>;
   }
   close($file);
   return $content;
}

#
# http_error
#    Something has gone wrong, inform the broswer.
#
sub http_error
{
   my ($s,$fmt,@args) = @_;

   #
   # show the invalid page responce
   #
   http_out($s,"HTTP/1.1 404 Not Found");
   http_out($s,"Date: %s",scalar localtime());
   http_out($s,"Last-Modified: %s",http_timestamp());
   http_out($s,"Connection: close");
   http_out($s,"Content-Type: text/html; charset=ISO-8859-1");
   http_out($s,"");
   http_out($s,"<html><meta name=\"viewport\" content=\"initial-scale=.5, maximum-scale=1\">");
   http_out($s,"<style>");
   http_out($s,".big {");
   http_out($s,"   line-height: .7;");
   http_out($s,"   margin-bottom: 0px;");
   http_out($s,"   font-size: 100pt;");
   http_out($s,"   color: hsl(0,100%,30%);");
   http_out($s,"}");
   http_out($s,"div.big2 {");
#   http_out($s,"   border: 2px solid red;");
   http_out($s,"   line-height: .2;");
   http_out($s,"   display:inline-block;");
   http_out($s,"   -webkit-transform:scale(2,1); /* Safari and Chrome */");
   http_out($s,"   -moz-transform:scale(2,1); /* Firefox */");
   http_out($s,"   -ms-transform:scale(2,1); /* IE 9 */");
   http_out($s,"   -o-transform:scale(2,1); /* Opera */");
   http_out($s,"   transform:scale(2,1); /* W3C */");
   http_out($s,"}");
   http_out($s,"</style>");
   http_out($s,"<body>");
   http_out($s,"<br>");
   http_out($s,"<table width=100%>");
   http_out($s,"   <tr>");
   http_out($s,"      <td width=30px>");
   http_out($s,"         <div class=\"big\">404</div><br>");
   http_out($s,"         <center>");
   http_out($s,"            <div class=\"big2\">Page not found</div>");
   http_out($s,"         </center>");
   http_out($s,"      </td>");
   http_out($s,"      <td width=30px>");
   http_out($s,"      </td>");
   http_out($s,"      <td>");
   http_out($s,"         <center><hr size=2>$fmt<hr></center>",@args);
   http_out($s,"         <pre>%s</pre>\n",code("long"));
   http_out($s,"      </td>");
   http_out($s,"      </td>");
   http_out($s,"      <td width=30px>");
   http_out($s,"      </td>");
   http_out($s,"   </tr>");
   http_out($s,"</table>");
   http_out($s,"</body>");
   http_out($s,"</html>");
   http_disconnect($s);
}

#
# http_out
#     Send something out to an http socket if its still connected.
#
sub http_out
{
   my ($sock,$fmt,@args) = @_;

   if(defined @http{$sock}) {
      printf({@{@http{$sock}}{sock}} "$fmt\r\n", @args);
   }
}


#
# http_reply_simple
#     A simple http reply with no evaluation.
#
sub http_reply
{
   my ($s,$data,$fmt,@args) = @_;
   my $type = "text/text";

   my $msg = sprintf($fmt,@args);
   http_out($s,"HTTP/1.1 200 Default Request");
   http_out($s,"Date: %s",http_timestamp(time()));
   http_out($s,"Last-Modified: %s",http_timestamp(time()));
   if(ref($data) eq "HASH") {
      if($$data{get} =~ /.js$/) {
         $type = "text/javascript";
      } elsif($$data{get} =~ /.html$/) {
         $type = "text/html";
      } elsif($$data{get} =~ /.css$/) {
         $type = "text/css";
      } 
   }
   http_out($s,"Content-Type: %s; charset=ISO-8859-1",$type);
   http_out($s,"Content-Length: %s",length($msg));
   http_out($s,"Connection: close");
   http_out($s,"");
   printf({@{@http{$s}}{sock}} "%s",$msg);
   http_disconnect($s);
}

#
# ws_process
#    A message has come in via the websocket, hand it off to the MUSH
#    via the server_proces_line() function. The websocket client sends
#    a flag via the first character (text, html, and publeo, etc).
#    Currently, that flag is just being stripped and ignored. Maybe
#    later?
#
sub ws_process
{
   my( $conn, $msg, $ssl ) = @_;
   $msg =~ s/\r|\n//g;

   $ssl = $ssl ? ',SSL' : '';

   my $input = substr($msg,1);
#   loggit("%s[%s]> %s\n",$conn,(defined @ws{$conn}) ? 1 : 0,$msg);
   return if !defined @ws{$conn};

   # if unathorized check password before allowing any input. Websize
   # is sent on connect, so exclude that.
   if((!defined @ws{$conn} || @ws{$conn}->{auth} eq 0) &&
           $input !~ /^\/(version|web_size|focused|blured|key_ctl_l|monitor|window)/) {
      if($input eq @state{p_password}) {
         @ws{$conn}->{auth} = 1;
         redraw_screen($conn);
         ws_echo($conn,"t","%% Password validated.") if (no_world());
         echo("%% Authenticated web connection from: %s",@ws{$conn}->{ip});
      } else {
         ws_echo($conn,"t","%% Invalid Password.",1);
         echo("%% Failed web connect from: %s",@ws{$conn}->{ip});
         ws_disconnect($conn);
      }
   } elsif(do_cmd(world($conn),$input,$conn)) {
#      loggit("do_cmd: '%s'\n",$input);
      # do_cmd runs the command.
   } elsif(no_world()) {
     # do nothing
   } elsif(defined @socket{world($conn)} && 
           defined @socket{world($conn)}->{sock}) {
      out(world($conn),"%s\n",$input);
   }
#   unshift(@input,@state{line});                        # store keyboard history
}

sub ws_all
{
   my ($type,$txt) = @_;

   return if !web();
   my $hash = $ws_server->{conns};

   for my $key ( keys %$hash) {
      my $client = $$hash{$key}->{conn};
      next if(@ws{$client}->{auth} eq 0);

      eval {
          ws_echo($client,$type,$txt);
      };
      if($@) {
         ws_disconnect($client);
      }
   }
}

sub lord
{
   my $txt = shift;
   my @result;
#   $txt =~ s/\e/<ESC>/g;
#   return $txt;

   for my $i (0 .. (length($txt)-1)) {
      push(@result,ord(substr($txt,$i,1)));
   }
   return join(',',@result);
}


sub echo_wrap
{
   my $txt = shift;

   if(console()) {
      for my $line (ansi_wrap($txt)) {
         echo_console("%s",txt($line));
      }
   }
   if(web()) {
      my $hash = $ws_server->{conns};
   
      for my $key ( keys %$hash) {            # cycle all websocket connections
         my $c = $$hash{$key}->{conn};
         next if(@ws{$c}->{auth} eq 0);
   
         # get width of the websocket session, or default to console
         my $y=(defined @ws{$c}->{size_y}) ? @ws{$c}->{size_y} : @state{size_y}; 
   
         eval {                                   # protect against the unknown
            if($txt eq undef) {
               ws_echo($c,'t',$txt);
            } else {
               for my $line (ansi_wrap($txt,$y)) {
                  ws_echo($c,"t",txt($line));
               }
            }
         };
         if($@) {                                         # error, disconnect
            ws_disconnect($c);
         }
      }
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  console code                                                              #
#                                                                            #
#----------------------------------------------------------------------------#

sub console
{
   return @state{console};
}

#
# in_hist
#    Is the current world reviewing the history buffer?
#
sub in_hist
{
   my $w = shift;

   if(no_world() || !defined @socket{$w}) {
      return 0;
   } elsif(defined @socket{$w}->{hist_pos}) {
      return 1;
   } else {
      return 0;
   }
}

#
# hist_pos
#    Return if the history buffer position, set it, or delete it.
#
sub hist_pos
{
   my ($w,$action,$offset) = @_;

   $w = @state{world} if $w eq undef;
   if(no_world()) {
      return;
   } elsif($action eq "delete") {
      delete @socket{$w}->{hist_pos};
      delete @socket{$w}->{hist_offset};
   } elsif($action ne undef) {
      @socket{$w}->{hist_pos} = $action;
      @socket{$w}->{hist_offset} += $offset;
      if(@socket{$w}->{hist_offset} == 0) {
         delete @socket{$w}->{hist_offset};
         delete @socket{$w}->{hist_pos};
      }
   } elsif(defined @socket{$w}) {
      return @socket{$w}->{hist_pos};
   }
}


sub pending
{
   my $w = shift;
   my $flag = shift;

   return undef if $w eq undef || !defined @socket{$w};

   if(!defined @socket{$w}->{pending}) {
      return 0;
   } elsif(@socket{$w}->{pending} < 0) {
      @socket{$w}->{pending} = 0;
      return 0;
   } else {
      return @socket{$w}->{pending};
   }
}

sub pending_fix
{
   my $w = shift;
   $w = @state{world} if $w eq undef;
   my ($start, $txt_start);
   my $count = 0;

   return if !defined @socket{$w};

   my $hist = @history{$w};

   if(history_pos_partial($w) == -1) {
      $start = history_pos($w) + 1;   # prev partial line, start on same line
   } else {
      $start = history_pos($w);       # prev partial line, start on same line
   }

   for(my $i=$start;$i <= history_max($w);$i++) {
      if(!$$hist[$i]->{gagged}) {
         if($i == history_pos($w) && history_pos_partial($w) >= -1) {
            $start = history_pos($w);
            $txt_start = history_pos_partial($w);
         } else {
            $start = history_pos($w) + 1;
            $txt_start = 0; # but at character $
         }
         $count +=scalar ansi_wrap(ansi_substr(
             @history{$w}->[$i]->{txt},$txt_start));
      }
   }
   
   @socket{$w}->{pending} = $count;
}

sub history_pos
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{history_pos} = $value;
      @socket{$w}->{history_pos_partial} = -1;
   } else {
      $w = @state{world} if($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{history_pos}) {
         return @socket{$w}->{history_pos};
      }
   }
   return undef;
}

sub history_pos_partial
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{history_pos_partial} = $value;
   } else { 
      $w = @state{world} if ($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{history_pos_partial}) {
         return @socket{$w}->{history_pos_partial};
      }
   }
   return undef;
}


sub hist_pos_partial
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{hist_pos_partial} = $value;
   } else { 
      $w = @state{world} if ($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{hist_pos_partial}) {
         return @socket{$w}->{hist_pos_partial};
      }
   }
   return undef;
}

sub history_max
{
   my $w = shift;

   if($w ne undef && defined @history{$w}) {
      return $#{@history{$w}};
   } else {
      return undef;
   }
}

#
# no_world
#   test to see if no worlds have been opened yet.
#
sub no_world
{
   return (!defined @state{world} || @state{world} eq undef) ? 1 : 0;
}

#
# echo
#    Echo output to the console. If there is pending output or we're in the
#    history buffer, through the output into the pending queue.
#
sub echo
{
   my $fmt = shift;
   my $msg = sprintf("$fmt",@_);

   $msg =~ s/([\n\r]+)$//;
 
   ws_all("t",$msg);
   echo_console("%s",$msg);
}

#
# echo_console
#    Echo output to the console. If there is pending output or we're in the
#    history buffer, through the output into the pending queue.
#
sub echo_console
{
   my $fmt = shift;

   my $msg = sprintf("$fmt",@_);
 
   return if(!console());

   if(@state{optimize_output} <= 1) { 
      update_scroll_region("output");
      xy(output_end(),1);
      @state{optimize_output} = 2 if(@state{optimize_output} == 1);
   }

   printf("\n%s",$msg);
#   printf("\n%s",encode_utf8($msg));

   if(@state{optimize_output} == 0) {
      update_scroll_region("input");
      xy(input_x(),input_y());
   }
}

#
# pausable_check
#    Check to see if the socket should have "more" turned on based upon
#    activity, weather conditions, and whatever else I think of.
#
sub more_check
{
   my ($conn,$w) = @_;
   my ($last, $count, $start);

   return if(!defined @history{$w});                          # no history yet
   return if(more($w));                                           # already on
   
   # non shown output is already to big
   if($#{@history{$w}}>overlap() && pending($w) > output_end()- overlap()){
      @socket{$w}->{more} = history_pos();
      return;
   }


   # check recent activity
   my $hist = @history{$w};
  
   return if(more($w));              # no need to enable more, its enabled

   # scan forward for hits 
   for(my $i=history_pos($w);$i >= 0 && $$hist[$i]->{ts} > time() - 3;$i--) {
      if(!$$hist[$i]->{gagged}) {
         $count += scalar cache_wrap($conn,$w,$i);
      }
   }

   # found enough, stop
   if($count > 3) {
      @socket{$w}->{more} = $start if($count > 3);
      @socket{$w}->{more_count} = $count;
      return;
   }

   # scan backwards for hits
   for(my $i = history_max($w);$i >= 0 && $$hist[$i]->{ts} > time() - 3;$i--) {

      if(!$$hist[$i]->{gagged}) {
         $count += scalar cache_wrap($conn,$w,$i);
         if($count > 3) {
            if($start ne undef) {
               @socket{$w}->{more} = $start - 1;
               @socket{$w}->{more_count} = $count;
            } else {
               @socket{$w}->{more} = history_pos();
               @socket{$w}->{more_count} = $count;
            }
            return;
         }
      }
   }
}

#
# more_update
#
#    Manage the more and more_needed. This should be called after more
#    has been set and after a page full of lines have been shown.
#
#    Events should flow like this:
#
#       o Signal more should be turned on by setting the more variable.
#       o Show a page full of lines
#       o Require that a tab be pressed by setting the more_needed variable
#         before any more pending output is shown.
#
sub more_update
{
   my $w = shift;

   return if(!defined @history{$w} || !more($w));
   if(pending($w) <= 0) {
      @socket{$w}->{more} = -1;
      @socket{$w}->{more_count} = 0;
   }
   draw_bar();
}

#
# paused
#    More might be on but should new output be paused?
#
sub paused
{
   my $w = shift;
   my $debug = shift;
   $w = @state{world} if($w eq undef);

   if(@state{p_more} == 0) {                       # more disabled by user
      return 0;
   } elsif(in_hist($w)) {
      return 1;
   } elsif(more($w) && @socket{$w}->{more_count} >= output_end() - overlap()) {
      return 1;
   } else {
      return 0;
   }
}


#
# more
#    Show the status for the current world and optionally fix it.
#
sub more
{
  my $world = shift;
  $world = @state{world} if($world eq undef);

  if(in_hist($world)) {         # in history buffer is just a version of more
     return 1;
  } elsif(!@state{p_more}) {
     return 0;
  } elsif(!defined @socket{$world}) {
     return 0;
  } elsif(@socket{$world}->{more} >= 0) {
     if(pending($world) == 0) {
        @socket{$world}->{more} = -1;
        @socket{$world}->{more_count} = 0;
        return 0;
     }
     return 1;
   } else {
     return 0;
   }
}


#
# recent
#   Scan through the most recent output from the world and determine how
#   many lines have happened in $howlong seconds. This is used by to determine
#   if more should be turned on.
#
sub recent
{
   my ($w,$howlong) = @_;
   my $count = 0;

   return undef if(!defined @history{$w});

   my $array = @history{$w};

   for(my $i = $#$array;$i >= 0 && time() - $$array[$i]->{ts};$i--) {
      # always count original to make counting easier but not gagged.
      # In the situation of a text being replaced, we technically we should
      # count just the modifed version but then you have figure out how to
      # count the original version when not modified. Gagged output should
      # never be "original".
      if(!$$array[$i]->{gagged} && $$array[$i]->{original}) {
         $count++;
      }
   }
   return $count;
}

#
# replace
#    This should be replaced by something more generic. Currently it is
#    being used to remove the nospoof flag output by mushes.
#
sub replace
{
   my ($world,$txt) = @_;

   if($txt =~ /^\[([^\]]+)\(([^\]]+)\)([^\]]*)\] / ||
      $txt =~ /^\[([^:]+):\] /)  {
      return $';
   }
   return undef;
}

#
# history_add
#    Add a line to the pending input buffer and determine if more needs
#    to be turned on. This function probably should have been run against
#    unwrapped text but its probably more accurate to treat a really big
#    line as multiple hits instead of just one for weighted accuracy.
#
sub history_add
{
   my ($world,$line,$gagged,$original) = @_;

   my $array = @history{$world};

   # this should be a push() but i muffed something up and it was
   # screwing up the array.. so i just rewrote it this way since i didn't
   # see the obvious problem.
   $$array[$#$array+1] = { txt       =>  $line,
                           ts        => time(),             # add entry
                           gagged    => $gagged,     # was line gagged?
                           pend_code => code(),
                           original  => $original
                         };

   if(!$gagged) {
      @socket{$world}->{pending} += 
          scalar cache_wrap(@state{world},$world,$#$array);
   }
}

sub gagged
{
   my ($w,$txt) = (shift,ansi_remove(shift));
   my $match;

   if(defined @state{window} && ref(@state{window}) eq "HASH") {
      for my $id (keys %{@state{window}}) {
         my $window = @state{window}->{$id};
         if(!defined $$window{sock} && time() - $$window{created} > 60) {
            delete @state{window}->{$id};         #  connect took to long
         } elsif(defined $$window{sock} && !defined @ws{$$window{sock}}) {
            delete @state{window}->{$id};          # must have disconnected?
            ws_disconnect($$window{sock});
         } elsif(defined $$window{sock} && $txt =~ /$$window{regexp}/i) {
            ws_echo($$window{sock},"m",
                    join("\n                 ",
                     txt(ansi_wrap(sprintf("%s %-7s | %s\n",
                            t(),
                            substr(world($w),0,7),
                            $txt
                           ),@ws{$$window{sock}}->{size_y} - 17)
                   )));
         }
      }
   }

   for my $key (keys %def) {
      if(@def{$key}->{world} eq undef || 
         lc(@def{$key}->{world}) eq lc($w)) {
         if(@def{$key}->{atr} =~ /g/) {
            my $pat = @def{$key}->{txt};
            $pat = glob2re($pat) if(@def{$key}->{match} ne "regexp");
            eval {
               $match = 1 if($txt =~ /$pat/);
            };
            return 1 if $match;
         }
      }
   }
   return 0;
}

#
# history
#    add a line of input into the history queue
#
sub history
{
   my ($world,$txt,$gagged) = @_;
   $txt =~ s/\r|\n//g;
   my ($gag,$str, $mod);

   # no keypresses in 2 minutes, turn more on before input processed.
   if(time() - @state{key_last} > 120) {
      @socket{$world}->{more} = history_max($world);
   }
   @history{$world} = [] if !defined @history{$world};

   my $str = replace($world,$txt);
   $mod = 1 if ($str ne undef);
   $str = $txt if $str eq undef;
   $gag = gagged($world,$str);

   if($gag || $mod) {
      history_add($world,$txt,1,1);                          # store orig
   }

   if(!$gag) {                                 # show output if not gagged
      history_add($world,$str,0,($gag || $mod) ? 0 : 1);
      @state{activity}->{$world} = 1 if(!world_visible($world));
      release_pending_pagefull("n/a",$world);
   }
}

#
# echo_world
#    send the output to any console/websocket connection that is currently
#    on the world in question.
#
sub echo_world
{
   my ($world,$console,$web) = @_;

   if(@state{world} eq $world) {
      echo_console("%s",$console);
   } 
#   loggit("# %s\n",$console);

   my $hash = $ws_server->{conns};

   for my $key (keys %$hash) {
      my $c = $$hash{$key}->{conn};

      next if(@ws{$c}->{auth} eq 0);
 
      if(@ws{$c}->{world} eq $world) {
         my $y=(defined @ws{$c}->{size_y}) ? @ws{$c}->{size_y}:@state{size_y}; 

         if($web eq undef) {
            ws_echo($c,"t");
         } else {
            for my $line (ansi_wrap($web,$y)) {
               ws_echo($c,"t",txt($line));
            }
         }
      }
   }
}

#
# world_visible
#   Determine if the world is currently being viewed by the console or
#   any websocket connection.
#
sub world_visible
{
   my $world = shift;

   if(console() && $world eq @state{world}) {
      return 1;
   } else {
      for my $key (keys %ws) {
         if(@ws{$key}->{world} eq $world && @ws{$key}->{active}) {
            return 1;
         }
      }
   }
   return 0;
}

#
# min_visible
#    determine the smallest visible window that is viewing the world,
#    as this is the size that should be catered too.
#
sub min_visible
{
   my $world = shift;
   my $min;

   $min = output_end() if($world eq @state{world});

   for my $key (keys %ws) {
      if(@ws{$key}->{world} eq $world && @ws{$key}->{size_y} < $min) {
         $min = @ws{$key}->{size_x};
      }
   }

   return $min || @state{size_x};
}


#
# release_pending_pagefull
#    Scan through the history and find upto a pagefull of data to let the
#    user see.
#
sub release_pending_pagefull
{
   my ($conn,$w,$force) = @_;
   my ($max,$end,$start,$txt_start);
   my $s = @socket{$w};

   return if(!world_visible($w));

   more_check($conn,$w);
   return if(in_hist($w) || paused($w));

   # find max number of lines to show
   $max = @state{p_more} ? (min_visible($w) - overlap()) : history_max($w);

   # determine starting point to start showing text from
   if(history_pos_partial($w) == -1) {    # last line shown was fully shown
      $start = history_pos($w) + 1;                    # start on next line
      $txt_start = 0;
   } else {                                # last line only partially shown,
      $start = history_pos($w);                       # start where left off
      $txt_start = history_pos_partial($w);
   }

   optimize_start();
   my $hash = $ws_server->{conns};

   for(my $i=$start;@socket{$w}->{more_count} <= $max && 
                     $i <= history_max($w);$i++) {
      my @list = ansi_wrap(ansi_substr(@history{$w}->[$i]->{txt},$txt_start));
      history_pos($w,$i);                                # update history_pos

      if(@history{$w}->[$i]->{gagged}) {             # ignore gagged output
         history_pos_partial($w,-1);
         next;
      }

      if($#list > 0 && $s->{more_count} + $#list + 1 >= $max) { # fullentrywill
         my $end = $max - $s->{more_count};                       # *not* fit
         @socket{$w}->{more} = history_pos($w);        

         # since line size could vary, record how many characters were shown
         history_pos_partial($w,$txt_start + 
                                ansi_length(join("",@list[0 .. ($end-1)])));
         echo_world($w,
                    join("\n",txt(@list[0 .. ($end-1)])),
                    txt(ansi_substr(@history{$w}->[$i]->{txt},
                                $txt_start,
                                history_pos_partial()
                               ))
                   );
         @socket{$w}->{pending} -= $end;
         @socket{$w}->{more} = history_pos($w);        
         @socket{$w}->{more_count} += $end;

         more_update();
         optimize_end();                                    # done, clean up
         draw_bar();
         return;
      } else {                                       # full entry can be shown
         @socket{$w}->{pending} -= $#list + 1;
         echo_world($w,
                    join("\n",txt(@list)),
                    txt(ansi_substr(@history{$w}->[$i]->{txt},$txt_start))
                   );
         history_pos_partial($w,-1);
         @socket{$w}->{more_count} += $#list + 1 if(more($w));
      }
      $txt_start = 0;
   }

   # fix pending if there is nothing to be shown
   @socket{$w}->{pending} = 0 if($start > history_max($w));

   more_update();
   optimize_end();
   draw_bar();
}

#
# return the X position of the input cursor
#
sub input_x
{
   my $offset = shift;

   my $x = input_start() + 
#           @state{buffer_pos} + 
           sprintf("%d",(@state{line_pos} - $offset -
                        ((@state{size_y} - 1) * @state{input_offset})) /
                        (@state{size_y} - 1));

   return ($x > @state{size_x}) ? @state{size_x} : $x;
}

#
# return the Y position of the input cursor
#
sub input_y
{
   my $offset = shift;
   return 1 + ((@state{line_pos}  - $offset) % (@state{size_y} - 1));
}

#
# output_end
#    The line number where the output region ends.
#
sub output_end
{
   return @state{size_x} - input_size() - 1;
}

#
# cache_wrap
#    Text will get wrapped several times, so cache the results
#
sub cache_wrap
{
   my ($conn,$world,$id) = @_;

   @state{cache} = {} if !defined @state{cache};
   my $cache = @state{cache};
   if(defined @history{$world} && defined @history{$world}->[$id]) {
      my $y = is_web($conn) ? @ws{size_y} : @state{size_y};
      if(!defined $$cache{$world} ||
         !defined $$cache{$world}->{$id} ||
         !defined $$cache{$world}->{$id}->{$y}) {
         $$cache{$world}={} if !defined $$cache{$world};
         $$cache{$world}->{$id}={} if !defined $$cache{$world}->{$id};
         if(!defined $$cache{$world}->{$id}->{$y}) {
           $$cache{$world}->{$id}->{$y}={};
         }
         $$cache{$world}->{$id}->{$y}->{txt} = 
            ansi_wrap(@history{$world}->[$id]->{txt},$y);
         $$cache{$world}->{$id}->{$y}->{ts} = time(); 
         @state{cached}++;
      } else {
         @state{nocache}++;
         $$cache{$world}->{$id}->{$y}->{ts} = time();     # update timestamp
      }
      return $$cache{$world}->{$id}->{$y}->{txt};
   }
}

#
# wrap_garbage_collect
#    Look at the cache for wrapped lines and delete any wrapped text
#    that haven't been used in over 15 minutes.
#
sub wrap_garbage_collect
{
   @state{cache} = {} if !defined @state{cache};
   my $cache = @state{cache};
   for my $w (keys %$cache) {
      for my $id (keys %{$$cache{$w}}) {
         for my $y (keys %{$$cache{$w}->{$id}}) {
            if(time() - $$cache{$w}->{$id}->{$y}->{ts} > 900) {
               delete @$cache{$w}->{$id}->{$y};
            }
         }
         if(scalar keys %{$$cache{$w}->{$id}} == 0) {
            delete $$cache{$w}->{$id};
         }
      }
   }
}

#
# ansi_wrap
#    Wrap text appropriate for the client connected while keeping
#    ansi sequences out of the counting process.
#
sub ansi_wrap
{
   my ($str,$size_y) = @_;
   $size_y = @state{size_y} if(!defined $size_y);
   my ($break, $start, @result);

   $str = ansi_init(shift) if(ref($_[0]) ne "HASH");

   my $i = 0;
   while($i <= $#{@$str{ch}}) {
      if($$str{ch}->[$i] eq "\n") {
         push(@result,ansi_substr($str,$start,$i - $start - 1));
         ($break,$start) = (undef,$i + 1);
      } elsif($i - $start >= $size_y - 1) {
         if(defined $break && $i - $break < 30) {
            push(@result,ansi_substr($str,$start,$break-$start));
            $start = $break;
         } else {
            push(@result,ansi_substr($str,$start,$i-$start));
            $start = $i + 1;
         }
         $break = undef;
      } elsif(is_in($$str{ch}->[$i],"["," ",",","\\","/","-",".")) {
         $break = $i+1;
      }
      $i++;
   }

   # add left overs
   push(@result,ansi_substr($str,$start)) if($start <= $#{@$str{ch}});
   return @result;
}





#
# ansi_cat
#    Add string $add to the end of $str
#
sub ansi_cat
{
   my ($str,$add) = @_;

   $str = ansi_init($str) if(ref($str) ne "HASH");
   $add = ansi_init($add) if(ref($add) ne "HASH");

   my $pos = $#{$$str{ch}} + 1;
   for my $i (0 .. $#{$$add{ch}}) {
      # add each escape code one at a time
      $$str{code}->[$pos] = [];
      for my $x (0 .. $#{$$add{code}->[$i]}) {
         $$str{code}->[$pos]->[$x] = $$add{code}->[$i]->[$x];
      }

      for my $x (0 .. $#{$$add{snap}->[$i]}) {
         $$str{snap}->[$pos]->[$x] = $$add{snap}->[$i]->[$x];
      }
      $$str{ch}->[$pos] = $$add{ch}->[$i];
      # add the character that follows the escape code (if any)
      $pos++;
   }

   if($#{$$str{snap}->[$pos-1]} != -1) {
      $$str{ch}->[$pos] = "";
      $$str{code}->[$pos] = [ chr(27) . "[0m" ];
      $$str{snap }->[$pos] = [];
   }
   return $str;
}



#
# overlap
#    shortcut to show how many lines should be overlapped so the user
#    can follow what happened.
#
sub overlap
{
   return @state{overlap};
}

#
# get_output
#    Find an appropriate number of lines of text to show in the output
#    region. Since text is wrapped this output could be different for
#    each client connected.
#
sub get_output
{
   my ($conn,$full) = @_;
   my ($start_pos,$partial,@out,@line,$x,$y,$max);

   if(is_console($conn)) {
      ($x,$y) = (@state{size_x},@state{size_y});
   } elsif(is_web($conn)) {
      ($x,$y) = (@ws{$conn}->{size_x},@ws{$conn}->{size_y});
   }

   my $w = world($conn);                                  # save some typing

   if(in_hist($w)) {                              # determine starting point
      $start_pos = hist_pos($w);
      $partial = hist_pos_partial($w);                    # start in history
   } else {
      $start_pos = history_pos($w);
      $partial = history_pos_partial($w);                   # regular output
   }

   my $hist = @history{$w};

   $max = $x - (($full) ? 0 : 3);
   for(my $i=$start_pos;
       $i >= 0 && $#out < $max && $i <= $#$hist;
       $i--) {
      next if $$hist[$i]->{gagged};

      if($i == $start_pos) {                   # possible partial line at end
         @line=ansi_wrap(ansi_substr($$hist[$i]->{txt},0,$partial),$y);
      } else {
         @line=ansi_wrap($$hist[$i]->{txt},$y);  # full line, may not use all
      }

      if($#line == -1 && $#out +1 < $x) {    # blank line, fix in ansi_wrap?
         unshift(@out,{ pos => $i, txt => ""});
      } else {                                   # add each line if possible
         for my $y (reverse 0 .. $#line) {
            if($#out - 1 < $x) {
               unshift(@out,{ pos => $i, 
                              txt => txt(@line[$y])
                            }
                      );
            }
         }
      }
   }

   while($#out + 1 < $x) {
      unshift(@out,{ pos => -2, txt => "\033[K"});
   }

   return @out;
}

#
# redraw_output
#    Redraw the output scroll region. Used when switching worlds or as needed.
#
sub redraw_output
{
   my ($conn,$flag) = @_;                    # don't show internal messages?
   my (@line,$size,$count,$start_pos,$partial,$start,$end);
   my ($w, $y,@out,$paused,$first);

   $w = world($conn);
   return if $w eq undef || !defined @socket{$w};
   my $last = history_pos($w) + 1;
   release_pending_pagefull($conn,$w);                       # show new lines?

   if(is_console($conn)) {
      optimize_start();
      for my $hash (get_output($conn,1)) {
         # show dashes before new output when switching to world
         if($$hash{pos} >= $last && $first eq undef) {
            echo_console("%s","=====");
            $first++;
         }
         echo_console("%s",$$hash{txt});
      }
      optimize_end();
   } elsif(is_web($conn)) {
      ws_echo($conn,"d","clear");          # clear output websocket window
      for my $hash (get_output($conn,1)) {
         if($$hash{pos} >= $last && $first eq undef) {
            # show dashes before new output when switching to world
            ws_echo($conn,"t","=====");
            $first++;
          }
          ws_echo($conn,"t",$$hash{txt});
      }
   }
}

sub redraw_input
{
   my $conn = shift;

   return if(!console());

   if(is_console($conn) || remote()) {
      update_scroll_region("input",1);
      xy(input_start(),1,1);
      my $start = @state{input_offset}+1;
      my $end = $start + input_size() - 1;
      for my $i (input_start() .. input_end()) {
         if($i >= $start && $i <= $end) {
            printf("%s\033[K%s",input_line($i),($i != $end) ? "\n" : "");
         } elsif($i == @state{size_x}) {
            printf("\033[K");
         } else {
            printf("\033[K\n");
        }
      }
      xy(input_x(),input_y(),1);
   }
}


sub redraw_screen
{
   my ($conn,$flag) = @_;

   return if defined @state{monitor_value};
   my $clear = shift;

   return if(!console());
   printf("\033[r\033[2J") if(is_console($conn) && $clear);
   clear_screen($conn);
   redraw_output($conn,$flag);
   draw_bar(1);
   redraw_input($conn);
}

#
# scan_history
#    Find the where to start showing output when moving up/down in the
#    history. The show_output() function will actually handle outputing
#    the text once this subroutine is done.
#
sub scan_history_new
{
   my ($conn,$inc,$max) = @_;
   my $count = 0;
   my ($pos, $size);
   
   my $w = world($conn);
   return if $w eq undef || !defined @socket{$w};

   if($inc > 0 && (!in_hist($w) || hist_pos($w) == $#{@history{$w}})) {
      hist_pos($w,"delete");
      return 0;
   } elsif(abs($inc) != 1) {
      die("scan_history incrament must be -1 or +1");
   } elsif($inc < 0 && !in_hist($w)) {
      $pos = $#{@history{$w}};
   } else {
      $pos = hist_pos($w);
   }

   if(@state{world} eq $w) {
      $size = output_end() - overlap();
   } elsif(is_web($conn)) {
      $size = @ws{$conn}->{size_x} - overlap();
   } else {
      $size = output_end() - overlap();
   }
   loggit("SIZE: '%s', POS: '$pos'\n",$size);

#   $size = $max if($max ne undef);
      
   my $hist = @history{$w};
   while($pos > 0 && $pos <= $#$hist && $count < $size) {
      my $sub = 0;
      if(!$$hist[$pos]->{gagged} && $$hist[$pos]->{internal} == 0) {
         for my $line (reverse ansi_wrap($$hist[$pos]->{txt})) {
            loggit("sh[$pos-$count]: %s\n",txt(ansi_substr($line,0,50)));
            $sub += ansi_length($line);
            $count++;
            if($count > $size) {
              loggit("POS: '%s' [%s]\n",$pos,$#$hist);
              hist_pos($w,$pos,$count * $inc);
              loggit("# %s\n",$$hist[$pos]->{txt});
              hist_pos_partial($w,
                  ansi_length($$hist[$pos]->{txt}) - $sub);
#                  $sub);
               return 1;
            }
         }
      }
      $pos += $inc;
   }

   $pos++ if($pos == 0);
   $pos = $#$hist if ($pos > $#$hist);

   if($pos == $#$hist && $inc > 0) {
      hist_pos($w,"delete");
      return 1;
   } elsif($count == 0) {
      # do nothing;
      return 0;
   } else {
      loggit("POS: $pos, %s\n",$count * $inc);
      hist_pos($w,$pos,$count * $inc);
      return 1;
   }
}
sub scan_history
{
   my ($conn,$inc,$max) = @_;
   my $count = 0;
   my ($pos, $size);

   my $w = world($conn);
   return if $w eq undef || !defined @socket{$w};

   if($inc > 0 && (!in_hist($w) || hist_pos($w) == $#{@history{$w}})) {
      hist_pos($w,"delete");
      return 0;
   } elsif(abs($inc) != 1) {
      die("scan_history incrament must be -1 or +1");
   } elsif($inc < 0 && !in_hist($w)) {
      $pos = $#{@history{$w}};
   } else {
      $pos = hist_pos($w);
   }

   if(@state{world} eq $w) {
      $size = output_end() - overlap();
   } elsif(is_web($conn)) {
      $size = @ws{$conn}->{size_x} - overlap();
   } else {
      $size = output_end() - overlap();
   }

#   $size = $max if($max ne undef);

   my $hist = @history{$w};
   while($pos > 0 && $pos <= $#$hist && $count <= $size) {
      if(!$$hist[$pos]->{gagged} && $$hist[$pos]->{internal} == 0) {
         @state{hist_start} += $inc;
         for my $line (ansi_wrap($$hist[$pos]->{txt})) {
            $count++;
         }
      }
      $pos += $inc;
   }
   $pos++ if($pos == 0);
   $pos = $#$hist if ($pos > $#$hist);

   if($pos == $#$hist && $inc > 0) {
      hist_pos($w,"delete");
      return 1;
   } elsif($count == 0) {
      # do nothing;
      return 0;
   } else {
      hist_pos($w,$pos,$count * $inc);
      return 1;
   }
}


sub key_shift_up
{
  loggit("Key: shift up");
}

sub key_shift_down
{
  loggit("Key: shift down");
}
#
# key_pgup
#    Move up a screen full in the history. This will pause all output
#    as well.
#
sub key_pgup
{
   my ($conn,$size) = @_;
   my $count = -1;

   return wc_out("/key_pgup") if(remote());

   if(scan_history($conn,-1,$size)) {
      draw_bar();
      redraw_output($conn);

      if(is_console($conn)) {                  # keep any webclients in sync
         for my $s (keys %ws) {
#            redraw_output($s) if(@ws{$s}->{world} eq $conn);
         }
      } elsif(@ws{$conn}->{world} eq @state{world}) {
         redraw_output(@state{world});                # keep console in sync
      }
   }
}

#
# key_pgdn
#    Move a screen down in the history.
#
sub key_pgdn
{
   my ($conn,$size) = @_;

   return wc_out("/key_pgdn") if(remote());

   if(scan_history($conn,1,$size)) {
      redraw_output($conn);
      draw_bar();

      if(is_console($conn)) {                  # keep any webclients in sync
         for my $s (keys %ws) { 
            redraw_output($s) if(@ws{$s}->{world} eq $conn);
         }
      } elsif(is_web($conn) && @ws{$conn}->{world} eq @state{world}) {
         redraw_output(@state{world});                # keep console in sync
      }
   } else {
      key_tab(@_);
   }
}

sub print_state
{
   my $out;

   my %skip = (
      pos_sequence => 1,
      240 => 1,
      241 => 1,
      250 => 1,
      251 => 1,
      252 => 1,
      253 => 1,
      254 => 1,
      255 => 1,
      DO  => 1,
      DONT=> 1,
      IAC => 1,
      SB  => 1,
      SE  => 1,
      WILL=> 1,
      WONT=> 1,
      activity=> 1,
      ansi_wrap=> 1,
      cache => 1,
      chksum => 1,
      console => 1,
      ctl_c => 1,
      help => 1,
      init_cache => 1,
      init_cache_count => 1,
      init_cache_count => 1,
      key_last => 1,
      last_active => 1,
      pending =>1,
      pid =>1,
      region =>1,
      secure =>1,
      size_x =>1,
      size_y =>1,
      tick_last => 1,
      web => 1,
      world => 1,
      world_last => 1,
      wrap_garbage_collect_last => 1,
      nocache => 1,
      mush => 1,
      optimize_output => 1,
      cached => 1,
      ta => 1,
      spelling_error => 1,
      telnet_mode => 1,
#      hist_start => 1,
      state => 1,
      World_last => 1,
   );

   $out = sprintf("\@state = {\n");
   for my $key (sort keys %state) {
      if(ref(@state{$key}) eq undef && 
         !defined @skip{$key} &&
         $key !~ /^(mod|bar|p)_/) {
         $out .= sprintf("   %s = %s\n",$key,@state{$key});
      }
   }
   $out .= "}\n";
   for my $i (-1) {
      $out .= sprintf("%s : %s\n",$i,join('',@{@input[$i]}));
   }
   $out .= sprintf("x/y: %s,%s\n",input_x(),input_y());
   return $out;
}

sub key_ctl_f
{
   @input[-1] = [ split(//,"Many a hand has scaled the grand old face of the plateau Some belong to strangers and some to folks you know Holy ghosts and talk show hosts are planted in the sand To beautify the foothills and shake the many hands Nothing on the top but a bucket and a mop And an illustrated book about birds See a lot up there but don't be scared Who needs action when you got words") ];
   @state{buffer_pos} = 2;
   @state{input_offset} = 3;
   @state{input_pos} = 196;
   @state{line_pos} = 196;
   @state{overlap} = 3;
   @state{pos_sequence} = 72;
}

#
# key_dump
#   Write out the data in the history variable for debuging purposes.
#
sub key_dump
{
   my $file;

   loggit("Dumping files");

    return loggit("%s\n",print_state(\%state));
#   for my $key (keys %history) {
#      open($file,"> history.$key.log") || return;
#      binmode($file, ":utf8");
#      eval {
#      @address{$key}->{decode} = "utf8" if !defined @address{$key}->{decode};
#      printf($file "%s\n",
#             decode(@address{$key}->{decode},
#             print_var(@history{$key}))
#            );
#      };
#      close($file);
#   }
}


#
# key_ctl_p
#    Move down into the keyboard input history
#
sub key_ctl_p
{
   my ($conn,$txt) = @_;

   if(!defined @state{input_pos} || @state{input_pos} == -1) {  # first time
      if($#{@input[-1]} >= 0) {              # store initial text if it exists
         push(@input,[]);
         @state{input_pos} = $#input - 1;
      } else {
         @state{input_pos} = $#input;                 # no text, point to top
      }
   } elsif(@state{input_pos} <= 0) {
      @state{input_pos} = $#input;                              # wrap around
   }

   @{@input[-1]} = @{@input[@state{input_pos} -1]};         # overwrite input

   # set offset so just the end of the line is shown if the whole line is
   # not visible.
   if(max_input() > input_size()) {
      @state{input_offset} = max_input() - input_size();
   } else {
      delete @state{input_offset};
   }
   @state{input_pos}--;
   @state{line_pos} = $#{@input[-1]} + 1;
   redraw_input($conn);
}

#
# key_ctl_n
#    Move down in the keyboard input history
#
sub key_ctl_n
{
   my ($conn,$txt) = @_;

   if(!defined @state{input_pos} || @state{input_pos} == -1) {  # first time
      push(@input,[]) if($#{@input[-1]} >= 0); # store initial text if it exists
      @state{input_pos} = $#input - 1;
   }

   if(@state{input_pos} == $#input -1) {
      @state{input_pos} = 0;
   } else {
      @state{input_pos}++;
   }

   @{@input[-1]} = @{@input[@state{input_pos}]};           # overwrite input
   @state{line_pos} = $#{@input[-1]} + 1;

   # set offset so just the end of the line is shown if the whole line is
   # not visible.
   if(max_input() > input_size()) {
      @state{input_offset} = max_input() - input_size();
   } else {
      delete @state{input_offset};
   }
   redraw_input($conn);
}

#
# key_ctl_R
#    Reload the code without typing in any commands.
#
sub key_ctl_r
{
   @state{ansi_wrap} = 0;
   reload_code();

   wc_out("/reload\n") if(remote());
}

#
# key_ctl_l
#    Redraw the screen.
#
sub key_ctl_l
{
   my ($conn,$txt) = @_;

   # screen seems to have some sort of bug where it stop sending winch
   # signals after a month of use but yet GetTerminalSize is still returning
   # the correct size. So update the screen size when a control-l is done as
   # a "work around". This shouldn't cause an impact on cpu usage.

   if(module_enabled("Term::ReadKey")) {
      (@state{size_y},@state{size_x}) = GetTerminalSize();
   } else {
      (@state{size_x},@state{size_y}) = 
         `stty size`=~/(\d+)\s+(\d+)/?($1,$2):(80,25);
   }
   pending_fix(world($conn));
   redraw_screen($conn,1);

   if(remote()) {
      wc_out("/web_size @state{size_x},@state{size_y}\n");
      draw_bar();
      redraw_input($conn);
   } else {
      pending_fix(world($conn));
      redraw_screen($conn,1);
   }
}
   

#
# key_tab
#    Show the next screen full of data if more/history is enabled.
#
sub key_tab
{
   my ($conn,$txt) = @_;

   return wc_out("/key_tab") if(remote());

   my $w = world($conn);
   return if $w eq undef || !defined @socket{$w};
   if(in_hist($w)) {                      # same as key_pgdn, just call it
      key_pgdn(@_);
   } elsif(more($w)) {
      # move the starting point down to the last line shown
      my $max = output_end() - overlap();
      @socket{$w}->{more} = history_pos();
      @socket{$w}->{more_count} = 0;

      release_pending_pagefull($conn,$w,1);
      if(pending($w) <= 0) {
         @socket{$w}->{more} = -1;
         @socket{$w}->{more_count} = 0;
      }
      #pending_fix($w);
   }
}

# key_ctl_u
#    Clear keyboard input
#
sub key_ctl_u
{
   my ($conn,$txt) = @_;

   if(is_console($conn)) {
      @input[-1] = [];
      @state{line_pos} = 0;
      delete @state{input_offset};
      xy(input_x(),input_y());
      printf("\033[J") if console();
   }
}

#
# key_ctl_w
#    Delete the last word before the cursor
#
sub key_ctl_w
{
   my $count = 0;
   my $i;

   # delete any initial spaces
   for($i = @state{line_pos}-1;$i >= 0 && @input[-1]->[$i] eq " ";$i--) {
      key_delete();
   }

   # delete any non-spaces after the spaces
   for(;$i >= 0 && @input[-1]->[$i] ne " ";$i--) {
      key_delete();
   }
}


#
# key_escape
#    The escape key has been found. This could be part of a escape sequence
#    for something like an arrow key or something like escape-w. Signal the
#    escape has been found by setting the multikey variable for later use.
#
sub key_escape
{
   @state{multikey} = [];
}

#
# key_esc_j
#    Jump to the end of the world buffer without displaying all the output
#    Output can still be done via history or /recall.
#
sub key_esc_j
{
   my ($conn,$txt) = @_;

   history_pos($conn,$#{@history{$conn}});
   delete @socket{$conn}->{more};
   delete @socket{$conn}->{more_count};
   delete @socket{$conn}->{pending};
   @socket{$conn}->{pending} = 0;
   redraw_screen($conn,1);
}

#
# out
#    send a message out to the world with some basic error checking
#
sub out
{
   my $world = shift;
   my ($fmt,@args) = @_;

   $world = @state{world} if($world eq undef);
   if(defined @socket{$world} && defined @socket{$world}->{sock}) {
      my $msg = sprintf("$fmt",@args);
      $msg .= "\n" if($msg !~ /\n$/);               # add returns if needed.

#      loggit("$world> %s",$msg);
      my $sock = @socket{$world}->{sock};
      printf($sock "%s",$msg);

      # keep track of last send time for sending keepalives
      @socket{$world}->{last_send} = time();
   }
}
   
sub out_noret
{
   my ($world,$fmt,@args) = @_;

   return;
   if(defined @socket{$world} && defined @socket{$world}->{sock}) {
      my $sock = @socket{$world}->{sock};
      printf($sock $fmt, @args);
      @socket{$world}->{last_send} = time();
   }
}


#
# key_return
#    The return key has been pressed, now what?
#
sub key_return
{
   my ($conn,$txt) = @_;
   my $array = @input[-1];
   my $input = join('',@$array);

   if(do_cmd(@state{world},$input,$conn)) {
      # do_cmd runs the command
   } elsif(no_world()) {
     # do nothing
   } elsif(defined @socket{@state{world}}->{sock}) {
      out(@state{world},"%s\n",$input);
   }
   @state{input_pos} = -1;                        # reset keyboard history pos
   push(@input,[]);
   @state{line_pos} = 0;
   @state{buffer_pos}++ if(@state{buffer_pos} < input_size());
   delete @state{input_offset};

   # just entered input, don't be so quick to show the more
   if(!no_world()) {
      @socket{@state{world}}->{more_last} = $#{@history{@state{world}}};
   }
   input_clear();
#   printf("\n");
   xy(input_x(),input_y());
}

sub input_lines
{
    my $pos = shift;
    $pos = -1 unless $pos;
    my $chars;

    # there may only be X characters but the cursor might be one past it.
    if(@state{line_pos} > $#{@input[$pos]}) {
       $chars = @state{line_pos};
    } else {
       $chars = $#{@input[$pos]};
    }

    my $result = sprintf("%d",($chars + 1) / (@state{size_y} - 1));
    return $result + 1 if(($chars + 1) % (@state{size_y} - 1) >= 1);
    return $result;
}

sub input_on_line
{
    my $result = sprintf("%d",@state{line_pos} / (@state{size_y} - 1));
    return $result + 1 if(@state{line_pos} % (@state{size_y} - 1) >= 1);
    return $result;
}

#
# max_input
#   Max number of input lines in the keyboard buffer
#
sub max_input
{
    my $result = sprintf("%d",($#{@input[-1]}+1) / (@state{size_y} - 1));
    return $result + 1 if(($#{@input[-1]}+1) % (@state{size_y} - 1) >= 1);
    return $result;
}


#
# key_delete
#    Handle when the user presses the delete key.
#
sub key_delete
{
   my $ch = shift;

   return if !console();
   update_scroll_region("input");
   
   if(@state{line_pos} < 1) {                        # nothing left to delete
      return;
   } elsif(@state{line_pos} < $#{@input[-1]}) {          # delete in middle

      if((@state{line_pos}-1)-(@state{input_offset}*(@state{size_y} - 1))==-1){
         # at begining of visible buffer, input window needs to be erased
         # and redrawn. key_left will do this + move cursor one over.

         splice(@{@input[-1]},@state{line_pos}-1,1);        # remove character
         key_left($ch);
      } else {                          # deleting in the middle of a line.
         my $bol =                                  # [find begining of line] 
             (@state{size_y} - 1) *           # number of characters per line
             (@state{input_offset} +            # number of lines not visible
             input_x() - input_start());            # number of visible lines

         # loop from current line to end of screen horizontally
         for my $i (0 .. (@state{size_x} - input_x())) {
            my $nbol = $bol += @state{size_y} - 1;      # next begin of line

            if($i == 0) {
               xy(input_x(),input_y()-1);
               printf("\033[P");                   # delete ch before cursor
            } else {
               xy(input_x() + $i,0);       # delete char at begining of line
               printf("\033[P");                   # for wrap around effect
            }
            xy(input_x() + $i,79);                 # add char at end of line
            printf("%s",@input[-1]->[$nbol]);
           
            $bol = $nbol;
         }
         splice(@{@input[-1]},@state{line_pos}-1,1);      # remove character
         @state{line_pos}--;
         xy(input_x(),input_y());                            # return cursor
      }
   } elsif(@state{line_pos} >= 1) {                           # delete at EOL
      @state{line_pos}--;                          # move cursor pos back one
      pop(@{@input[-1]});                           # remove char from buffer
      xy(input_x(),input_y());             # move cursor back incase it moved
      printf("\033[P");                       # delete character under cursor

      # check to see if the cursor needs to go up a line, and therefor needs
      # to redraw the line.
      if((@state{line_pos}-1)-(@state{input_offset}*(@state{size_y} - 1))==-2){
         xy(input_x(),1);                   # move cursor to begining of line
         @state{input_offset}--;               # move input focus one line up
         printf("%s",input_line(input_on_line()));               # print line
         # xy() - no need to move cursor to right location, its there.
      }
   }
}

#
# make_string_bold
#    Given a word/string in the input buffer that immediate preceeds where
#    the cursor is, make it bold.
#
sub make_string_bold
{
   my ($txt,$bold) = @_;

   return if $txt =~ /^\s*$/;

   my $i = @state{line_pos} - length($txt);

   # move cursor to begingin of word
   xy(input_x(length($txt)),input_y(length($txt)));

   printf("\033[1m") if($bold);                                  # start bold
   for my $ch (split('',$txt)) {

      # determine if character would be off the screen, if so done.
      if($i >= ((@state{size_y}-1) * input_size()) + 
               (@state{input_offset} * (@state{size_y}-1))) {
         last;
      }

      # determine if we should drop down a line before next character
      if($i % (@state{size_y}-1) == 0 && $i != @state{line_pos}-length($txt)){
         printf("\n");
      }
      printf("%s",$ch);                                # print out character
      $i++;
   }
   printf("\033[0m") if($bold);                               # turn off bold
}

#
# key_default
#    Default key handler for all normal characters.
#
sub key_default
{
   my ($conn,$ch) = @_;
   my $out;

   return if !console();
   update_scroll_region("input");

   # spell checker code
   if($ch eq " " && module_enabled("Text::Aspell")) {
      if(substr(join('',@{@input[-1]}),0,@state{line_pos}) =~ 
            /(^| |^:|^"|^@)([a-zA-Z']+)([\.!"']{0,1})(\s*)$/) {
         @state{speller} = Text::Aspell->new if(!defined @state{speller});
         if(!@state{speller}->check($2)) {
             make_string_bold("$2$3$4",1);
             @state{spelling_error} = 1;
         } elsif(@state{spelling_error} == 1) {  # this will not unbold every
             make_string_bold("$2$3$4",0);              # thing, improve later?
             @state{spelling_error} = 0;
         }
      }
   }

   splice(@{@input[-1]},@state{line_pos},0,$ch);         # add ch to buffer
   @state{line_pos}++;                          # move cursor position over 1
   printf("%s",$ch);                                     # print out new char

   # redraw all characters in front of current character as the terminal
   for my $i (@state{line_pos} .. $#{@input[-1]}) {

      # determine if character would be off the screen, if so done.
      if($i >= ((@state{size_y}-1) * input_size()) + 
               (@state{input_offset} * (@state{size_y}-1))) {
         printf("%s",$out);
         xy(input_x(),input_y());
         return;                                # nothing more to draw, done
      }

      # determine if we should drop down a line before next character
      if($i % (@state{size_y}-1) == 0 && $i != 0) {
         $out .= "\n";
      }
      $out .= @input[-1]->[$i];                   # add next char in buffer
   }
   printf("%s",$out);                                   # output generated txt

   # if the input has gotten bigger then the input window, send a return now
   # plus the next line.
   if(input_lines() - @state{input_offset} > input_size()) {
      printf("\n%s",input_line(input_on_line()+1));
      @state{input_offset}++;
   }
   xy(input_x(),input_y());
}

#
# key_ctl_a
#    Move the cursor to the begining of the line
#
sub key_ctl_a
{
   my ($conn,$key) = @_;
   my $offset = @state{input_offset};

   @state{input_offset} = 0;                    # reset the cursor location
   @state{line_pos} = 0;

   if($offset > 0) {     # line is not fully viewable, so a redraw is needed.
      redraw_input($conn);
   } else {                                            # just move the cursor
      xy(input_x(),input_y());
   }
}

#
# key_ctl_e
#    Move the cursor to the end of the line
#
sub key_ctl_e
{
   my ($conn,$key) = @_;

   input_lines();
   return;
   my $original = @state{input_offset};

   # determine the number of lines that aren't being shown for offset
   if($#{@input[-1]} / (@state{size_y} - 1)+1 > input_size()) {
      @state{input_offset} = sprintf("%d",$#{@input[-1]} / (@state{size_y}
          - 1) + 1 - input_size());
   } else {
      @state{input_offset} = 0;
   }
   @state{line_pos} = $#{@input[-1]} + 1;

   if(@state{input_offset} != $original) {
      redraw_input($conn);
   } else {
      xy(input_x(),input_y());
   }
}

#
# input_size
#    Shortcut for stored variable with default to a size of 2.
#
sub input_size
{
   return nvl(@state{p_input_size},2);
}



#
# key_left
#    Move the cursor one character to the left
#
sub key_left
{
   return if !console();

   my $ret = "\n";
   if(@state{input_offset} > 0 && @state{line_pos} % (@state{size_y}-1)==0 &&
      input_x() == input_start()) {
      @state{input_offset}--;
      for my $i (input_on_line() .. input_lines()) {
         last if(input_size() < $i - @state{input_offset});
         my $start = ($i-1) * (@state{size_y} -1);
         my $stop = $start + @state{size_y}-2;

         # only draw lines that are currently visible.
         if(input_size() < $i + 1 - @state{input_offset}) {
            $ret = undef;                          # last line? no return
         }
         printf("\033[J%s$ret",join('',@{@input[-1]}[$start .. $stop]));
      }
   }
   if(@state{line_pos} >= 1) {
      @state{line_pos}--;
      xy(input_x(),input_y());
   }
}


#
# input_line
#   Returns the keyed in input for a line on the screen.
#
sub input_line
{
   my ($line,$pos) = @_;
   $pos = -1 if $pos eq undef;

   my $start = ($line - 1) * (@state{size_y} -1);
   my $stop = $start + @state{size_y}-2;
   return join('',@{@input[$pos]}[$start .. $stop]);
}

sub name
{
   my $name = lc(shift);

   return undef if($name eq undef && @state{world} eq undef);
   $name = lc(@state{world}) if $name eq undef;

   if(defined @address{$name} && defined @socket{$name}) {
      return ((defined @socket{$name}->{sock}) ? "" : "!") .
             @address{$name}->{name};                      # correct case?
   } elsif($name eq "muddler") {
      return "muddler";
   } else {
      return "(Unnamed)";
   }
}

#
# state
#    Simplify the retriveal / storage of values from the current state
#    that may exist in one of two different locations.
#
sub mstate
{
   if($#_ == 1) {
      if(is_console(@_[0])) {
         return @state{@_[1]};
      } elsif(is_web(@_[0])) {
         return @ws{@_[0]}->{@_[1]};
      }
   } elsif($#_ == 2) {
      if(is_console(@_[0])) {
         return @state{@_[1]} = @_[2];
      } elsif(is_web(@_[0])) {
         return @ws{@_[0]}->{@_[1]} = @_[2];
      }
   }
}

#
# key_up
#   Move up one world and switch to it.
#
#   The structure is less then ideal for switching up a world, so it
#   needs to scanned for and then optionally a backup instead of just
#   grabbing the next entry (which may or may not exist any more).
#   
sub key_up
{
   my ($conn,$txt) = @_;
   my $w = world($conn);
   my $first;

   return wc_out("/key_up") if(remote());

   return if($w eq undef || !defined @socket{$w});
   my $pos = @socket{$w}->{pos};

   # if active, switch to it.. but also switch back one last time.
   if(mstate($conn,"last_active") ne undef || 
      scalar keys %{@state{activity}} > 0) {
      if(scalar keys %{@state{activity}} > 0) {
         mstate($conn,"last_active","");
      } else {
         mstate($conn,"last_active",world($conn));
      }
      return key_esc_w(@_);
   }

   for my $key (sort {@socket{$a}->{pos} <=> @socket{$b}->{pos}} keys %socket){
      if(@socket{$key}->{pos} > $pos &&
         (defined @socket{$key}->{sock} || pending($key) > 0)) {
         return switch_world($conn,$key);
      }
      $first = $key if($first eq undef);
   }

   switch_world($conn,$first) if($first ne undef);
}

#
# key_down
#   Move down one world and switch to it.
#
#   The structure is less then ideal for switching up a world, so it
#   needs to scanned for and then optionally a backup instead of just
#   grabbing the next entry (which may or may not exist any more).
#   
sub key_down
{
   my ($conn,$txt) = @_;
   my ($prev,$last);

   return wc_out("/key_up") if(remote());

   my $w = world($conn);
   return if $w eq undef || !defined @socket{$w};
   my $pos = @socket{$w}->{pos};

   # if active, switch to it.. but also switch back one last time.
   if(mstate($conn,"last_active") ne undef || 
      scalar keys %{@state{activity}} > 0) {
      if(scalar keys %{@state{activity}} > 0) {
         mstate($conn,"last_active","");
      } else {
         mstate($conn,"last_active",world($conn));
      }
      return key_esc_w(@_);
   }

   for my $key (sort {@socket{$a}->{pos} <=> @socket{$b}->{pos}} keys %socket){
      if(@socket{$key}->{pos} < $pos &&
         (defined @socket{$key}->{sock} || 
         pending($key) > 0)) {
         $prev = $key;
      }
      if(defined @socket{$key}->{sock} || pending($key) > 0) {
         $last = $key;
      }
   }
   if($prev ne undef) {
      switch_world($conn,$prev);
   } elsif($last ne undef) {
      switch_world($conn,$last);
   }
}

sub key_right
{
   return if !console();

   if(@state{line_pos} <= $#{@input[-1]}) {
      if(@state{line_pos} % (@state{size_y}-1)==@state{size_y} - 2 &&
         input_x() == @state{size_x}) {
         @state{input_offset}++;
         printf("\n%s",input_line(input_on_line()+1));
      }
      @state{line_pos}++;
      xy(input_x(),input_y());
   }
}

#
# switch_world
#    Switch the current world or all of them.
#
sub switch_world
{
   my ($conn,$world) = @_;

   return if $world eq undef;

   if(@state{p_sync} == 1) {                       # switch all interfaces
      @state{world_last} = @state{world};
      @state{world} = $world;
      for my $key (keys %ws) {
         @ws{$conn}->{world_last} = @state{world};
         @ws{$conn}->{world} = $world;
      }
   } elsif(is_web($conn)) { # switch websocket
      @ws{$conn}->{world_last} = @ws{$conn}->{world};
      @ws{$conn}->{world} = $world;
   } else {
      @state{world_last} = @state{world};
      @state{world} = $world;
   }

   delete @state{activity}->{$world};

   if(@state{p_sync} == 1) {
      redraw_output(@state{world},0);
      for my $key (keys %ws) {
         redraw_output(@ws{$key}->{conn},0);
      }
   } else {
      redraw_output($conn,0);
   }
   draw_bar();
}

#
# key_esc_w
#   Go to the next active world
#
sub key_esc_w
{
   my ($conn,$txt) = @_;

   return wc_out("/key_esc_w") if(remote());

   # try next active world
   my $new = (keys %{@state{activity}})[0];

   if($new eq undef) {
      if(is_web($conn)) {
         return switch_world($conn,@ws{$conn}->{world_last});
      } else {
         return switch_world($conn,@state{world_last});
      }
   }

   # fall back to previous world the client was showing.

   if($new eq undef) {                    # use last world if no activity
      if(is_console($conn)) {
         $new = @state{world_last};
      } elsif(is_web($conn)) {
         $new = @ws{$conn}->{world_last};
      }
   }

   # nothing found, do nothing.
   return if $new eq undef;

   switch_world($conn,$new);
}

#
# update_scroll_region
#   Send the escape sequence to set a scroll region in the terminal.
#   The region will not be set if the region is already in affect unless
#   $force is true.
#
sub update_scroll_region
{
   return if !console();
   return if defined @state{monitor_value};

   my ($region,$force) = @_;
   my ($start,$stop);

   if($region eq "input") {                           # supported region input
      $start = @state{size_x} - input_size() + 1;
      $stop  = @state{size_x};
   } elsif($region eq "output") {                    # supported region output
      $start = 1;
      $stop = output_end();
   } else {                                              # unsupported region
      die("Invalid region '$region' specified.");
   }

   if(@state{region} ne "$start,$stop" || $force) {           # do the work
      printf("\033[%s;%sr",$start,$stop);
      @state{region} = "$start,$stop";
   }
}

sub is_in
{
   my ($txt,@list) = @_;

   for my $i (0 .. $#list) {
      return 1 if($txt eq @list[$i]);
   }
   return 0;
}

#
# key_multi
#   Process multiple character keys. key_escape will start the sequence
#   off and this will grab characters till it makes a match or no match
#   can be made. This should be more of a decision tree instead of an
#   emulated tree.
#
sub key_multi
{
   my ($conn,$ch) = @_;

   my $array = @state{multikey};
   push(@$array,ord($ch));

   if($#$array >= 10) {             # shoudln't happen but protect against it
      delete @state{multikey};
      key_process($ch);                       # process character generically
   }


   if(defined @key{"multi_" . join("_",@$array)}) {
      if(ref(@key{"multi_" . join("_",@$array)}) eq "CODE") {
         delete @state{multikey};
         return &{@key{"multi_" . join('_',@$array)}}(@state{world},$ch);
      }
   } else {                                                        # error?
      delete @state{multikey};
      key_process($ch);                       # process character generically
   }
}

#
# key_process
#    Process input one key at a time while allowing for multi character
#    keys that begin with a escape and are followed by an arbitrary number
#    of letters afterwards (1 to 2?).
#
sub key_process
{
   my $input = shift;
   return unless defined $input;

   @state{key_last} = time();
   for my $ch (split(//,$input)) {
#      loggit("ch: '%s' -> '%s'",ord($ch),$ch);
      if(defined @key{ord($ch)}) {
         &{@key{ord($ch)}}(@state{world},$ch);
      } elsif(defined @state{multikey}) {
         &{@key{multi}}(@state{world},$ch);
      } else {
         # clear suggestion list on new character.
         if(defined @state{suggest}) {
            delete @state{suggest};
            delete @state{suggest_pos};
         }
         &{@key{def}}(@state{world},$ch);
      }
   }
}

sub is_console
{
   my $conn = shift;

   return ($conn eq "muddler" || defined @socket{$conn}) ? 1 : 0;
}

sub is_web
{
   my $conn = shift;

   return (defined @ws{$conn}) ? 1 : 0;
}

sub clear_screen
{
   my $conn = shift;
   return if defined @state{monitor_value};

   if(is_console($conn) && console()) {
      for my $line (1 .. @state{size_x}) {
         if($line == @state{size_x}) {
            printf("\033[K");
         } else {
            printf("\033[K\n");
         }
      }
   } elsif(is_web($conn)) {
      ws_echo($conn,"d","clear");          # clear output websocket window
   }
}

#
# x,y
#    Move the cursor to a location. This should be able to be optimized
#    when we are sure we always know where the cursor is all the time.
#
sub xy
{
   my ($x,$y,$use_the_force_luke) = @_;

   return if !console();
   return if defined @state{monitor_value};
   printf("\033[%s;%sH",$x,$y);
}

#
# more_bar
#    Determine what the more text should look like on the bar.
#
sub more_bar
{
   my $conn = shift;

   my $w = world($conn);
   return if $w eq undef || !defined @socket{$w};

   if(in_hist($w)) {
      return sprintf("\033[7mHist %4s\033[0m",abs(@socket{$w}->{hist_offset}));
   } elsif(more(world($conn))) {
      return sprintf("\033[7mMore %4s\033[0m",pending($w));
   }
   return undef;
}

sub world
{
   my $conn = shift;

   if(is_console($conn)) {
      return @state{world};
   } elsif(is_web($conn)) {
      return @ws{$conn}->{world};
   } else {
      return "muddler";
   }
}

sub size_x
{
   my $conn = shift;

   if(is_web($conn)) {
      return @ws{$conn}->{size_x} if(defined @ws{$conn});
   } else {
      return @state{size_x};
   }
}

sub size_y
{
   my $conn = shift;

   if(is_web($conn)) {
      return @ws{$conn}->{size_y} if(defined @ws{$conn});
   } else {
      return @state{size_y};
   }
}

#
# draw_bar
#    draw/redraw the input bar if need.
#
sub draw_bar
{
   return if defined @state{window_value};
   my $force = shift;
   my $new = time();
   my ($hr,$min,$active) = ((localtime($new))[2,1]);
   $hr -= 12 if($hr > 12);
   $hr = 12 if $hr == 0;

   if(remote()) {
      if(@state{size_x}.@state{size_y} ne @state{bar_size} ||
         @state{remote_bar} ne @state{bar_remote} ||
         @state{bar_name} ne name(@state{world})) {
         @state{bar_time} = "$hr$min";
         @state{bar_size} = @state{size_x}.@state{size_y};
         @state{bar_prev} = "_" if(!defined @state{bar_prev});
         @state{bar_prev} = @state{remote_bar};
            xy(@state{size_x} - input_size(),0);
            printf("%s%s%s:%02d",
                   @state{remote_bar},
                   "_" x (@state{size_y} - ansi_length(@state{remote_bar}) - 
                       length($hr) - 3),
                   $hr,
                   $min
                  );
            update_scroll_region("input");
            xy(input_x(),input_y());
      }
      return;
   } elsif(console() && ($force || "$hr$min" ne @state{bar_time} ||
      @state{bar_activity} ne scalar keys %{@state{activity}} ||
      @state{bar_name} ne name(@state{world}) ||
      @state{bar_more} ne pending(@state{world}) ||
      @state{bar_pos} ne hist_pos(@state{world}) ||
      @state{size_x}.@state{size_y} ne @state{bar_size})) {
      #---
      @state{bar_time} = "$hr$min";
      @state{bar_name} = name(@state{world});
      @state{bar_more} = pending(@state{world});
      @state{bar_pos} = hist_pos(@state{world});
      @state{bar_size} = @state{size_x}.@state{size_y};
      @state{bar_activity} = scalar keys %{@state{activity}};
      if(scalar keys %{@state{activity}} > 0) {
         if(@state{size_y} < 50) {
            $active = sprintf("(Act: %d)",scalar keys %{@state{activity}});
         } else {
            $active = sprintf("(Active: %d)",scalar keys %{@state{activity}});
         }
      }

      my $more = more_bar(@state{world});
      #---
      xy(@state{size_x} - input_size(),0);

      printf("%s%s_%s%s_%s_%s_%s:%02d",
             "_" x (9 - ansi_length($more)),
             $more,
             name(),
             "_" x (10 - length(name())),
             $active,
             "_" x (@state{size_y} - length("$active$hr")-26),
             $hr,
             $min
            );
      update_scroll_region("input");
      xy(input_x(),input_y());
   }


   my $hash = $ws_server->{conns};
   for my $key ( keys %$hash) {
      
      my $conn = $$hash{$key}->{conn};

      if(!defined @ws{$conn}) {
         ws_disconnect($conn);
         next;
      }
      if($force || "$hr$min" ne @ws{$conn}->{bar_time} ||
         @ws{$conn}->{bar_activity} ne scalar keys %{@state{activity}} ||
         @ws{$conn}->{bar_name} ne name(world($conn)) ||
         @ws{$conn}->{bar_more} ne pending(world($conn)) ||
         @ws{$conn}->{bar_pos} ne hist_pos(world($conn))) {
         #---
         @ws{$conn}->{bar_time} = "$hr$min";
         @ws{$conn}->{bar_name} = name(world($conn));
         @ws{$conn}->{bar_more} = pending(world($conn));
         @ws{$conn}->{bar_pos} = hist_pos(world($conn));
         @ws{$conn}->{bar_activity} = scalar keys %{@state{activity}};

         if(scalar keys %{@state{activity}} > 0) {
            if(@ws{$conn}->{size_y} < 50) {
               $active=sprintf("(Act: %d)",scalar keys %{@state{activity}});
            } else {
               $active=sprintf("(Active: %d)",scalar keys %{@state{activity}});
            }
         }
         my $more = more_bar($conn);
         ws_echo($conn,
                 "*",
                 sprintf("%s:%02d    ",$hr,$min)
                );
         ws_echo($conn,
                 "b",
                 sprintf("%-*s %-10s %s",
                         9 - ansi_length($more),
                         $more,
                         name(@ws{$conn}->{world}),
                         $active
                        )
               );
      }
   }
}

sub ws_all
{
   my ($type,$txt) = @_;

   return if !web();
   my $hash = $ws_server->{conns};

   for my $key ( keys %$hash) {
      my $client = $$hash{$key}->{conn};
      next if(@ws{$client}->{auth} eq 0);

      eval {
          ws_echo($client,$type,$txt);
      };
      if($@) {
         ws_disconnect($client);
      }
   }
}

#
# input_start
#    Return the starting line number of the input window.
#
sub input_start
{
   return @state{size_x} - input_size() + 1;
}

#
# input_end
#    Return the line ending line of the console. This function exists
#    mostly to make things more readable.
#
sub input_end
{
   return @state{size_x};
}

#
# revert_console
#    Send whatever is needed to reset the terminal to normal operation.
#    i.e. turning off scroll regions.
#
sub revert_console
{
   if(!console() || @state{fatal} || $term eq undef) {
      return;
   } else {
      normal();
      printf("\033[r\033[2J");
      xy(24,1);
   }
}


#
# log
#    Write a to the muddler.log file if debugging is enabled. Output to
#    the screen probably won't be readable.
#
sub loggit
{
   my ($fmt,@args) = @_;
   my $file;

   #   die("no debug - " . code()) if !@state{p_debug};
   return if !@state{p_debug};

   my $msg = sprintf("$fmt",@args);
   $msg .= "\n" if($msg !~ /\n/);

   # syswrite on closed filehandle. Happens when the websocket client
   # is closed. Can't seem to stop these, so lets ignore them.
#   return if $msg =~ /syswrite/;
   open($file,">> muddler.log");
   binmode($file, ":utf8");
   printf($file "%s",$msg);
   close($file);
}

#
# code
#    Provide just the list of line numbers from perl's stack of what sub-
#    routines or optionally the full output. The line numbers will be
#    adjusted as code is reloaded because the numbers will change.
#
sub code
{
   my $type = shift;
   my @stack;

   my $prev = @state{chksum};
   if(!$type || $type eq "short") {
      for my $line (split(/\n/,Carp::shortmess)) {
         if($line =~ /at ([^ ]+) line (\d+)\s*$/) {
            my ($fun,$ln) = ($1,$2);
            if(defined $$prev{$fun}) {
               push(@stack,(@{$$prev{$fun}}{line} + $ln) . "[$fun]");
            } else {
               push(@stack,"$ln*");
            }
         }
      }
      return join(',',@stack);
   } else {
      return Carp::shortmess;
   }
}

sub input_clear
{
   return if !console();
   update_scroll_region("input");
   my $start = @state{size_x} - input_size() + 1;
   xy($start,0);
   for my $i ($start .. @state{size_y}) {
      printf("\033[K\n");
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  commands                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

sub key_esc_q
{
   my ($conn,$txt) = @_;
   my ($spell, $found);

   if(module_enabled("Text::Aspell")) {
      if(substr(join('',@{@input[-1]}),0,@state{line_pos}) =~ 
            /(^| |^:|^"|^@)([a-zA-Z']+)([\.!"']{0,1})(\s*)$/) {

         if(!defined @state{suggest}) {                   # no saved results
            @state{speller} = Text::Aspell->new if(!defined @state{speller});
            if(!@state{speller}->check($2)) {             # not spelled right
               @state{suggest} = [ (@state{speller}->suggest($2))[0.. 4] ];
           
               @state{suggest_pos} = 0;
               echo("%s : %s",$2,join(", ",@{@state{suggest}})); # show results

               if($#{@state{suggest}} == -1) {               # no suggestions
                  delete @state{suggest};
                  return;
               } else {
                  push(@{@state{suggest}},$2);    # add original word to list
               }

               @state{suggest_pos} = $#{@state{suggest}};
            }
            return;
         }

         for my $i (1 .. length($2 . $3 . $4)) {
            key_delete();
         }

         @state{suggest_pos}++;
         if(@state{suggest_pos} > $#{@state{suggest}}) {
            @state{suggest_pos} = 0;
         }

         for my $ch (split('',@{@state{suggest}}[@state{suggest_pos}]."$3$4")){
            key_default($conn,$ch);
         }
      }
   }

   return;

   my $input = join('',@{@input[-1]});

   $input =~ s/[^a-zA-Z0-9 ]+//g;
   open($spell,"echo $input | aspell -a -S |") ||
      return echo("%% Unable to run aspell");
   while(<$spell>) {
      if(/^& ([^ ]+) [^:]+: /) {
         my @data = split(/,/,$');
         echo("%% %-15s  =>  %s",$1,join(', ',(split(/,/,$'))[0..4]));
         $found++;
      }
   }
   close($spell);
   echo("%% No misspelled words found.") if (!$found);
}

#
# glob2re
#    Convert a global pattern into a regular expression
#
sub glob2re
{
    my ($pat) = trim(shift);

    return "^\s*\$" if $pat eq undef;
    $pat =~ s{(\W)}{
        $1 eq '?' ? '(.)' :
        $1 eq '*' ? '(*PRUNE)(.*?)' :
        '\\' . $1
    }eg;

    $pat =~ s/\\\(.\)/?/g;

#    return "(?mnsx:\\A$pat\\z)";
    return "(?msix:\\A$pat\\z)";
}

#
# single
#    Take the input and smash it together into one line by removing any
#    returns or linefeeds.
#
sub single
{
    my $txt = shift;
    $txt =~ s/\r|\n//g;
    return $txt;
}

sub cmd_window
{
#-# ------------------------------------------------------------------------
#-# /window <pattern>
#-#
#-#      Fires off another terminal window that will only show those
#-#      lines that match <pattern> as they show up. 
#-#
#-#      Behind the scenes:
#-#         This command will startup another instance of muddler in
#-#         another window. That additional instance will connect via
#-#         websockets to the first instance. The two copies of muddler
#-#         will then relay the text that matches <pattern>.
#-#
#-#         For this to work, the following settings need to be set:
#-#
#-#            /web on
#-#            /set terminal=<your prefered xterm>
#-#            /password <secure password>
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;


   if($txt =~ /^\s*kill\s*$/) {
      delete @state{window};
   } elsif($txt =~ /^\s*socket\s*=\s*(\d+)$/) {
      if(defined @state{window} && 
         defined @state{window}->{$1}) {
         @state{window}->{$1}->{sock} = $conn;
         @state{reverse_window}->{$conn} = $conn;
      } else {
         echo("%% Window session $1 does not exist");
         ws_disconnect($conn);
      }
   } elsif($txt =~ /^\s*value\s*=\s*(\d+)\s*/) {
      @state{window} = {} if !defined @state{window};
      @state{reverse_window} = {} if !defined @state{reverse_window};

      @state{window}->{$1} = {
         glob => trim($'),
         regexp => glob2re(trim($')),
         created => time()
      };
   } elsif(remote() || is_web($conn)) {
      my $t = time();
      wc_out("/window value=%s %s\n",time(),$txt);
      if(length $txt) {
         @state{terminal_app} = "/usr/bin/xfce4-terminal -x ";

         loggit("Starting: @state{terminal_app} ./muddler --remote=192.168.1:9001 --window=$t\n");
         system("@state{terminal_app} perl ./muddler --remote=192.168.1.8:9001 --window=$t &");
      }
   } elsif(!length $txt) {
      if(!defined @state{window} || scalar keys %{@state{window}} == 0) {
         echo("%% No window monitoring patterns defined.");
      } else {
         echo("%15s | %-15s | %20s | %s\n", "Id","Status","Host","Pattern");
         for my $key (keys %{@state{window}}) {
            my $hash = @state{window}->{$key};
            if(!defined $$hash{sock} && time() - $$hash{created} > 60) {
               echo("%15s | %-15s | %20s | %s\n",
                    $key,
                    "timeout-deleted",
                    $$hash{glob}
                   );
               delete @state{window}->{$key};
            } elsif(!defined $$hash{sock}) {
               echo("%15s | %-15s | %20s | %s\n",
                    $key,
                    "unconnected",
                    "N/A",
                    $$hash{glob});
            } elsif(!defined @ws{$$hash{sock}}) {
               echo("%15s | %-15s | %20s | %s\n",
                    $key,
                    "active",
                    "orphaned?",
                    $$hash{glob}
                   );
            } else {
               echo("%15s | %-15s | %20s | %s\n",
                    $key,
                    "active",
                    @ws{$$hash{sock}}->{ip},
                    $$hash{glob}
                   );
            }
         }
      }
   } else {
      # show usage?
   }
}

#
# cmd_blurred
#   The browser has just told muddler that the document/tab/whatever
#   is no longer focused. This will be used for activity notifications.
#
sub cmd_blurred
{
   my ($conn,$txt) = @_;

   @ws{$conn}->{active} = 0 if(is_web($conn));
}

#
# cmd_blurred
#   The browser has just told muddler that the document/tab/whatever
#   is no focus. This will be used for activity notifications.
#
sub cmd_focused
{
   my ($conn,$txt) = @_;

   @ws{$conn}->{active} = 1 if(is_web($conn));
}

#
# cmd_dc
#   Disconnect from a the current world.
#
sub cmd_dc
{
   my ($conn,$txt) = @_;

   if(defined @socket{$conn} && defined @socket{$conn}->{sock}) {
      history(world($conn),"% Connection closed to $conn.");
      socket_disconnect(@socket{$conn}->{sock});
   } else {
      history(world($conn),"% Connection already closed.");
   }
}

sub cmd_stat
{
   my ($conn,$txt) = @_;
   my (%stat, $max,$sock);

   for my $world (keys %history) {
      $max = length($world) if length($world) > $max;
      for my $i (0 .. $#{@history{$world}}) {
         @stat{$world} += length(@history{$world}->[$i]->{txt});
      }
   }
   for my $world (keys %stat) {
      if(defined @socket{$world} && defined @socket{$world}->{sock}) {
         $sock = @socket{$world}->{sock};
      } else {
         $sock = "N/A";
      }
      echo("%% %*s : %10s    %s",$max,$world,@stat{$world},$sock);
   }

   for my $world (keys %stat) {
      if(!defined @socket{$world} || !defined @socket{$world}->{sock}) {
         delete @socket{$world};
         delete @history{$world};
      }
   }
}


sub cmd_perl
{
   my ($conn,$txt) = @_;
#-# ------------------------------------------------------------------------
#-# /perl <command>
#-#
#-#      Runs the specified command directly via eval(); The <command> 
#-#      needs to be valid perl command(s).    
#-#
#-# ------------------------------------------------------------------------
   eval($txt);
}

sub vencode
{
   my ($conn,$value) = @_;
   my $enc;

   if($value =~ /^\s*(utf8|cp437|iso-8859-1)\s*$/i) {
      $enc = lc($1);
   } elsif($value =~ /^\s*fansi\s*$/) {
      $enc = "cp437";
   } elsif($value =~ /^\s*latin\s*$/) {
      $enc = "iso-8859-1";
   } elsif($value =~ /^\s*\+\s*([^ ]+)\s*$/) {
      $enc = $1;
   } else {
      echo("%% Recommended encodings are utf, fansi, and latin.");
      return echo("%% Non-tested encodings can be set with: " . 
          "/set encode = + <encoding_name>");
   }

   if(!defined @address{world($conn)}) {
      return echo("%% Not connected to a world");
   }

   eval {
      decode($enc,"this is a test");
   };
   if($@) {
      return echo("%% Encoding '%s' not supported.",$value);
   } else {
      @address{world($conn)}->{decode} = $1;
      save(world($conn));
   }
}

# undef= can value be undef/empty/null
# fn   = is the value a file name
# set  = should cmd_set save the variable
# fun  = function to run to handle variable
sub var_init
{
   delete @key{keys %var};
  
   @var{cert}    = { null=>1,fn=>1,set=>1                                  };
   @var{key}     = { null=>1,fn=>1,set=>1                                  };
   @var{isize}   = { set=>1,fun => sub { redraw_screen(@_);}               };
   @var{port}    = { set=>1                                                };
   @var{encode}  = { fun => sub { vencode(@_); }                           };
   @var{debug}   = { set=>1                                                },
   @var{password}= { set=>1                                                },
   @var{sync}    = { set=>1,chk => "on|off|0|1",
                    fun => switch_world(@_,@state{world})                 };
}

sub cmd_set
{
   my ($conn,$txt) = @_;
   my $enc;

   if($txt =~ /^\s*([^=]+?)\s*=\s*/) {
      my ($name,$val) = ($1,$');
      if(defined @var{$name}) {
         if(defined @var{$name}->{chk}) { 
            if($val =~ /^\s*(@var{$name}->{chk})\s*$/) {
               $txt = $1;
            } else {
               return echo("%% Expected a value of: %s\n",
                  join(", ",split(/\|/,@var{$name}->{chk})));
            }
         }
         if(!length $val) {
            if(@var{$name}->{null}) {
               echo("%% Variable '%s' has been removed.",$name);
            } else {
               return echo("%% A value is required for variable '%s'",$name);
            }
         } else {
            if(@var{$name}->{fn}) {
               echo("%% file '%s' does not exist.",$val);
            }
         }

         if(@var{$name}->{fun} ne undef) {
            return &{@var{$name}->{fun}}($conn,$val);
         }
         
         if(@var{$name}->{set}) {
            save("p_" . $name,trim($val));
            if(length $val) {
               echo("%% Variable %s has been set to '%s'\n",$name,trim($val));
            }
         }
      } else {
         echo("%% Unknown variable '%s'\n",@var{$name});
         echo("%% Valid variables are: \n");
         echo("%%    %s\n",join(', ',keys %var));
      }
   } elsif($txt =~ /^\s*$/) {
      cmd_showset(@_);
   } else {
      echo("%% All variables require a value: /set varible=value");
   }
}

sub cmd_fansi
{
#-# ------------------------------------------------------------------------
#-# /fansi
#-#
#-#      Enables cp437 encoding on the current world, which gives fansi
#-#      support. Default is utf8 which can be enabled with /utf8
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   @address{world($conn)}->{decode} = "cp437";
   save(world($conn),1);
   echo("%% Enabling fansi encoding.");
}

sub cmd_latin
{
#-# ------------------------------------------------------------------------
#-# /fansi
#-#
#-#      Enables cp437 encoding on the current world, which gives fansi
#-#      support. Default is utf8 which can be enabled with /utf8
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   @address{world($conn)}->{decode} = "iso-8859-1";
   save(world($conn),1);
   echo("%% Enabling latin encoding.");
}

sub cmd_utf8
{
#-# ------------------------------------------------------------------------
#-# /utf8
#-#
#-#      Enables utf8 encoding on the current world [default].
#-#
#-# Also see: /fansi
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   @address{world($conn)}->{decode} = "utf8";
   save(world($conn),1);
   echo("%% Enabling utf8 encoding.");
}

sub cmd_common
{
#-# ------------------------------------------------------------------------
#-# /common
#-#      Connect to a list of places that someone might frequent often.
#-# /common list
#-#      Shows the list of worlds that are currently setup within /common
#-# /common -world
#-#      Deletes a world from the list of common worlds.
#-# /common world
#-#      Adds a world to the list of common worlds.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my %list;

   for my $world (split(/:/,@state{p_common})) {
      @list{trim($world)} = 1;
   }

   if($txt =~ /^\s*list\s*$/) {
      echo("%% Worlds: %s\n",join(', ', keys %list));
   } elsif($txt =~ /^\s*$/) {
      if(scalar keys %list == 0) {
         echo("%% No worlds defined in /common.");
      } else {
         for my $world (keys %list) {
            cmd_world(@state{world},$world);
         }
      }
      return;
   } elsif($txt =~ /^\s*-\s*/) {
      if(defined @list{trim($')}) {
         delete @state{trim{$'}};
         save("p_common",join(":",keys %list));
      } else {
         echo("%% Worlds '%s' not defined in /common",trim($'));
      }
   } else {
      if(defined @list{trim($txt)}) {
         echo("%% Worlds '%s' already defined in /common",trim($txt));
      } else {
         @list{trim($txt)} = 1;
         save("p_common",join(":",keys %list));
      }
   }
}

sub cmd_log
{
#-# ------------------------------------------------------------------------
#-# /log <message>
#-#
#-#      Logs <message> to muddlers log file if debugging is enabled.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   loggit("log: $txt");
}

sub cmd_showset
{
#-# ------------------------------------------------------------------------
#-# /set
#-#
#-#      Lists all variables that have been set that are preserved 
#-#      across restarts of muddler.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $count = 0;

   echo("# cache hits      %s",@state{cached});
   echo("# cache misses    %s",@state{nocache});

   if(defined @state{cache}) {
      my $cache = @state{cache};
      for my $w (keys %$cache) {
         for my $id (keys %{$$cache{$w}}) {
            $count += scalar keys %{$$cache{$w}->{$id}}
         }
      }
      echo("# cache_size      %s",$count);
   }
   for my $key (keys %state) {
      if($key =~ /^p_/) {
         echo("# %-15s %s",$',@state{$key});
      }
   }
 
   if(defined @address{world($conn)} &&
      defined @address{world($conn)}->{decode}) {
      echo("# %-15s %s","encode",@address{world($conn)}->{decode});
   }
   echo("# %-15s %sx%s","screen size",@state{size_x},@state{size_y});
   
}

#
# cmd_mobile
#
sub cmd_mobile
{
#-# ------------------------------------------------------------------------
#-# /mobile [on|off]
#-#
#-#      Enable a tweaks for the web/webosocket interface that should make
#-#      mobile browsers more useable. This includes showing buttons for
#-#      keys which the mobile users may not have.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if(is_console($conn)) {
      return echo("%% /mobile is only for web/websocket sessions");
   } elsif(!is_web($conn)) {
      return echo("%% /mobile is only for web/websocket sessions");
   } elsif($txt =~ /^\s*(on|1|enable)\s*$/) {
      @ws{$conn}->{mobile} = 1;
      ws_echo($conn,"d","mobile on");                    # tell js to turn on
   } elsif($txt =~ /^\s*(off|1|disable)\s*$/) {
      @ws{$conn}->{mobile} = 0;
      ws_echo($conn,"d","mobile off");                  # tell js to turn off
   } elsif($txt =~ /^\s*$/) {
      if(@ws{$conn}->{mobile} == 1) {
         @ws{$conn}->{mobile} = 0;
         ws_echo($conn,"d","mobile off");            # tell js to turn on off
      } else {
         @ws{$conn}->{mobile} = 1;
         ws_echo($conn,"d","mobile on");                 # tell js to turn on
      }
   }
}

sub cmd_sync
{
#-# ------------------------------------------------------------------------
#-# /sync [on|off]
#-#
#-#      When connected via the web, each window can view a different
#-#      world. /sync can make it so that all windows show the same
#-#      world even as they are switched.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt =~ /^\s*(on|1|enable)\s*$/) {
      save("p_sync",1);
      echo("% Synchronization of the viewable world is enabled.");
      switch_world($conn,@state{world});
   } elsif($txt =~ /^\s*(off|0|disable)\s*$/) {
      save("p_sync",0);
      echo("% Synchronization of the viewable world is disabled.");
   }
}
   


sub cmd_update
{
#-# ------------------------------------------------------------------------
#-# /update
#-#
#-#      Downloads the newest copy of muddler from github and loads it.
#-#      muddler may need to be restarted to work properly but also may not.
#-#
#-# ------------------------------------------------------------------------
   my $update;

   open($update,"wget -q -O muddler.tmp --no-cache " .
        "https://github.com/c-hudson/muddler/raw/master/muddler " .
        " |") ||
      return echo("%% Unable to update muddler at this time. Does wget exist?");
   while(<$update>) {
   }
   close($update);

   unlink("muddler");
   rename("muddler.tmp","muddler");
   system("chmod u+x muddler");
   reload_code();
}

sub cmd_more
{
#-# ------------------------------------------------------------------------
#-# /more [on|off]
#-#
#-#      Enables or disables more prompting that pauses the screen if
#-#      text is arriving to quickly.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt =~ /^\s*(1|on)\s*$/) {
      save("p_more",1);
   } elsif($txt =~ /^\s*(0|off)\s*$/) {
      save("p_more",0);
   } elsif($txt =~ /^\s*$/) {
      echo("%% more is %s",(@state{p_more} eq 1) ? "on" : "off");
   } else {
      echo("% Invalid more syntax, syntax is: /more [on|off]");
   }
}

sub cmd_console
{
#-# ------------------------------------------------------------------------
#-# /console <on|off>
#-#
#-#      Turn the console on or off.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt =~ /^\s*(on|1|enable)\s*$/) {
      @state{console} = 1;
      cbreak();
      redraw_screen(@state{world},1);
   } elsif($txt =~ /^\s*(off|0|disable)\s*$/) {
      revert_console();
      clear_screen($conn);
      @state{console} = 0;
      if(@state{web} == 0) {
         cmd_web($conn,"on");
         printf("%% WeB enabled due to disabling console. Connect via:\n");
         printf("%%   http://localhost:@state{p_port}, Password: @state{p_password}");
      }
   } else {
      echo("%% usage: /console <on|off>");
   }
}
sub cmd_color
{
#-# ------------------------------------------------------------------------
#-# /color [dark|light]
#-#
#-#      Set the theme of muddler when used in the web to either dark or
#-#      light.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt =~ /^\s*(dark|light)\s*$/) {
      ws_all("d","theme $txt");
      save("p_color",$txt);
   } else {
      echo("%% color expects either dark or light.");
   }
}

sub cmd_keepalive
{
#-# ------------------------------------------------------------------------
#-# /keepalive <text>
#-#
#-#      Set what is sent to the current world when the socket is idle
#-#      to keep the connection from timing out.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt eq undef) {
      for my $key (keys %socket) {
         if(defined @address{$key}->{keepalive}) {
             echo("%-15s   '%s'",$key,@address{$key}->{keepalive});
         }
      }
   } else {
      @address{world($conn)}->{keepalive} = $txt;
      save(world($conn),1);
      echo("% Keepalive for %s set to: %s",world($conn),$txt);
   }
}

sub cmd_ssl
{
#-# ------------------------------------------------------------------------
#-# /ssl <name> [<user> <pass>] <host> <port>
#-#
#-#      Adds a world or overwrites an existing world.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   my @field = split(/ /,$txt);

   # trim all fields and lc the first field
   for my $i (0 .. $#field) {
      if($i == 0) {
         @field[0] = lc(trim(@field[0]));
      } else {
         @field[$i] = trim(@field[$i]);
      }
   }
   my $append = 0;

   $append = 1 if(!defined @address{trim(lc(@field[0]))});

   if(trim(@field[0]) =~ /^p_/) {
      echo("%% World names may not start with 'p_' at this time");
   } elsif($#field == 1) {
      @address{@field[0]} = { host => @field[1],
                              port => @field[2],
                              name => @field[0],           # preserve case
                              ssl  => 1
                            };
   } elsif($#field == 4) {
      @address{@field[0]} = { name => @field[0],           # preserve case
                              user => @field[1],
                              pass => @field[2],
                              host => @field[3],
                              port => @field[4],
                              ssl  => 1
                            };
   } elsif($#field == 5) {                                         # has type
      @address{@field[0]} = { name => @field[0],              # preserve case
                              user => @field[2],                  # skip type
                              pass => @field[3],
                              host => @field[4],
                              port => @field[5],
                              ssl  => 1
                            };
   } else {
      return cmd_help($conn,"addworld");
   }
   save(lc(@field[0]));
}

sub cmd_addworld
{
#-# ------------------------------------------------------------------------
#-# /addworld <name> [<user> <pass>] <host> <port>
#-#
#-#      Adds a world or overwrites an existing world.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   my @field = split(/ /,$txt);

   # trim all fields and lc the first field
   for my $i (0 .. $#field) {
      if($i == 0) {
         @field[0] = lc(trim(@field[0]));
      } else {
         @field[$i] = trim(@field[$i]);
      }
   }
   my $append = 0;

   $append = 1 if(!defined @address{trim(lc(@field[0]))});

   if(trim(@field[0]) =~ /^p_/) {
      echo("%% World names may not start with 'p_' at this time");
   } elsif($#field == 2) {
      @address{@field[0]} = { host => @field[1],
                              port => @field[2],
                              name => @field[0],           # preserve case
                            };
   } elsif($#field == 4) {
      @address{@field[0]} = { name => @field[0],           # preserve case
                              user => @field[1],
                              pass => @field[2],
                              host => @field[3],
                              port => @field[4],
                            };
   } elsif($#field == 5) {                                         # has type
      @address{@field[0]} = { name => @field[0],              # preserve case
                              user => @field[2],                  # skip type
                              pass => @field[3],
                              host => @field[4],
                              port => @field[5],
                            };
   } else {
      return cmd_help($conn,"addworld");
   }
   save(lc(@field[0]));
}

#
# save
#    Save muddlers address and settings to .muddler
#
sub save
{
   my ($item,$value,$force) = @_;
   my $append = 0;
   my $file;


   # redefining a world will cause a full dump of the file
#   $append = 1 if(!defined @address{$item});

   open($file,($append ? ">>" : ">") . " @ENV{HOME}/.muddler") ||
      return echo("%% Unable to open @ENV{HOME}/.muddler for writing.");

   for my $world (keys %address) {
      if(!$append || ($append && $world eq $item)) {
         printf($file "%s {\n",$world);
         printf($file "   type:address\n",$world);
         for my $key (keys %{@address{$world}}) {
            printf($file "   %s:%s\n",$key,single(@address{$world}->{$key}));
         }
         printf($file "}\n");
      }
   }

   if($value eq undef) {
      delete @state{$item};
   } else {
      @state{$item} = $value;
   }

   for my $key (keys %state) {
      if(!$append && $key =~ /^p_/) {
         printf($file "state:%s:%s\n",$key,@state{$key});
      } elsif($append && $key eq $item) {
         printf($file "state:%s:%s\n",$key,trim($value));
      }
   }
   close($file);

#   echo("%% %s worlds written to @ENV{HOME}/.muddler",scalar keys %address) if(!$append);
}

sub load
{
   my $quiet = shift;
   my ($file,$name,$data);

   if(!open($file,"@ENV{HOME}/.muddler")) {
      if(!$quiet) {
         return echo("%% Unable to open @ENV{HOME}/.muddler for reading");
      }
   }

   while(<$file>) {
      s/\r|\n//g;
      if(/^\s*state:([^:]+):/) {                    # state variable values
         @state{$1} = $';
      } elsif(/^\s*([^ ]+)\s*{\s*$/) {                   # start of segment
         $name = $1;
         delete @$data{keys %$data};
      } elsif(/^\s*([^:]+)\s*:\s*/) {                      # segment value
         if($name eq undef) {
            return echo("% Corrupted .muddler file found on line $.");
         }
         $$data{$1} = $';
      } elsif(/^\s*}\s*$/) {                             # end of segment
         if($$data{type} eq "address") {          # segment was an address
            @address{$name} = { %$data };
         }
         $name = undef;
      } else {
        return echo("% Corrupted @ENV{HOME}/.muddler file found on line $.");
      }
   }
   close($file);
}

sub cmd_null
{
#-# ------------------------------------------------------------------------
#-# /null
#-#      Do nothing
#-# ------------------------------------------------------------------------
   # do nothing for now
}

#
# connected:
#    Determine if a world is connected or not.
#
sub connected
{
   my $world = lc(shift);

   if(defined @socket{$world} && 
      defined @socket{$world}->{sock} &&
      @socket{$world}->{sock}->connected()) {
      return 1;
   } else {
      return 0;
   }
}

sub cmd_allow
{
#-# ------------------------------------------------------------------------
#-# /allow <hosts>
#-#
#-#      Define a list of host that do not need to provide a password to
#-#      login to the web interface. The multiple hosts may be supplied
#-#      but need to be seperated by commas. Wild cards may be provided
#-#      as well.
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   save("p_allow",trim($txt),1);
   if(!length trim($txt)) {
      echo("%% Allow list has been removed.");
   } else {
      echo("%% Allow list has been set to: %s",trim($txt));
   }
}

sub cmd_send
{
   my ($conn,$txt) = @_;
   my $hit = 0;
   my $opt = {};

   my $str = getopt("w:Wn",$txt,$opt);

   # send to all worlds & send to just one world can't be defined
   if(defined $$opt{w} && defined $$opt{W}) {
      return echo("%% send: You may not use -w and -W at the same time.");
   }

   # default to current world.
   if(!defined $$opt{W} && !defined $$opt{w}) {
      $$opt{w} = world($conn);
   }

   for my $key (keys %socket) {
      if((defined $$opt{W} || (defined $$opt{w} && lc($$opt{w}) eq $key)) &&
         connected($key)) {
         $hit++;
         out($key,"%s\n",$str);
      }
   }

   if(!$hit && defined $$opt{w}) {
      return echo("%% send: Not connected.");
   } elsif(!$hit) {
      return echo("%% send: Not connected to any worlds.");
   }
}


sub cmd_listdef
{
#-# ------------------------------------------------------------------------
#-# /listdef <pattern>
#-#
#-#      Lists all defines or any matching <pattern>
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $opt = {};
   my $pat;

   my $str = getopt("sSm:t:b:B:E:T:h:a:P:iIw:",$txt,$opt);

   history(world($conn),
           sprintf("%-15s %4s %-8s %s","NAME","ATTR","WORLD","STRING")
          );

   $pat = glob2re(trim($str)) if($str !~ /^\s*$/);
   
   for my $key (keys %def) {
      next if @def{$key}->{atr} !~ /g/;
      my $count = 0;

      if(($pat eq undef || $key =~ /^$pat$/i) &&
         (!defined $$opt{w} || lc(@def{$key}->{world}) eq lc($$opt{w}))) {
        for my $line (ansi_wrap(@def{$key}->{txt},49)) {
           if($count++ == 0) {
               history(world($conn),sprintf("%-15s %4s %-8s %s",
                    $key,
                    @def{$key}->{atr},
                    @def{$key}->{world},
                    txt($line)
                   ));
            } else {
               history(world($conn),sprintf("%-15s %4s %-8s %s",
                    "",
                    "",
                    "",
                    txt($line)
                   ));
            }
         }
      }
   }
}

sub cmd_listworlds
{
#-# ------------------------------------------------------------------------
#-# /listworlds <pattern>
#-#
#-#      Lists all worlds or any matching <pattern>
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = (shift,trim(@_));

   my $w = world($conn);
   my $pat;
#   my $opt = {};

#   my $str = getopt("sSm:t:b:B:E:T:h:a:P:iI");

   history($w,sprintf("%-15s %33s %6s %s","NAME","HOST","PORT","CHARACTER"));

   $pat = glob2re($txt) if($txt ne undef);
   for my $key (keys %address) {
      if($txt eq undef || $key =~ /$pat/) {
         history($w,sprintf("%-15s %33s %6s %s",
                            $key,
                            @address{$key}->{host},
                            @address{$key}->{port},
                            @address{$key}->{user},
                            @address{$key}->{pass}
                           )
                );
      }
   }
}

sub cmd_def
{
#-# ------------------------------------------------------------------------
#-# /def <options> <name>
#-#
#-#      Options
#-#      -a<attributes>   Specifies what should happen when the text is
#-#                       matched.
#-#
#-#                       Attributes:
#-#                          g      : Text will be not be shown when
#-#                                   matched.
#-#
#-#      -w<world>        Match will be limited to a specific world
#-#      -t"text"         Text to match. May include wild cards.
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $opt = {};

   my $str = getopt("m:n:E:t:h:b:B:p:c:w:T:Fa:P:fiIq1",$txt,$opt);

   @def{trim($str)} = { atr   => $$opt{a},
                        txt   => $$opt{t},
                        world => $$opt{w},
                        match => $$opt{m},
                      };
}

sub first
{
   my $str = shift;

   return $1 if(/^\s*([^ ]+)/);
}

#
# cmd_ps
#    List all running processes
#
sub cmd_ps
{
#-# ------------------------------------------------------------------------
#-# /ps
#-#    List any running processes such as /repeat.
#-#
#-# ------------------------------------------------------------------------
   echo("%-5s %-8s %-11s %-8s %8s %s","PID","NEXT","WORLD","PTIME","COUNT",
        "COMMAND"
       );
   for my $i (keys %pid) {
      my $tl = @pid{$i}->{last} + @pid{$i}->{tick} - time();
      $tl = 0 if($tl <= 0);
      echo("%-5s %-8s %-11s %-8s %8s %s",
           $i,
           to_hhmmss($tl),
           @pid{$i}->{world},
           to_hhmmss(@pid{$i}->{tick}),
           @pid{$i}->{count},
           @pid{$i}->{cmd},
          );
   }
}

sub cmd_kill
{
#-# ------------------------------------------------------------------------
#-# /kill <pid>
#-#    Kill a running process listed in /ps.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   if($txt =~ /^\s*(\d+)\s*$/) {
      if(defined @pid{$1}) {
         delete @pid{$1};
      } else {
         echo("% KILL: no process %s",$1);
      }
   } else {
      echo("% KILL: invalid or missing numeric arguement");
   }
}

sub cmd_echo
{
#-# ------------------------------------------------------------------------
#-# /echo <message>
#-#    Echo <message> to the screen
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   echo($txt);
}
sub cmd_repeat
{
#-# ------------------------------------------------------------------------
#-# /repeat <options> <time> <command>
#-#    <time> A time between commands should be specified in hour, minute,
#-#    second format using -00:00:00.
#-#
#-#    -0          Sepecify seconds between commands.
#-#    -00:00      Sepecify hours minutes between commands.
#-#    -00:00:00   Sepecify hours, minutes, seconds  between commands.
#-#
#-#    <command>   The command that will be sent to the world.
#-#
#-#    <options>
#-#      -w<world>   Which would should the commands be run on.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my ($count,$sec,$min,$hr);
   my $opt = {};
   my $orig = $txt;

   if($txt =~ /(^| )\-(\d+)( |$)/) {
      $sec = $2;
      $txt = "$` $'";
   } elsif($txt =~ /(^| )\-(\d+):(\d+)( |$)/) {
      ($hr,$min) = ($2,$3);
      $txt = "$` $'";
   } elsif($txt =~ /(^| )\-(\d+):(\d+):(\d+)( |$)/) {
      ($hr,$min,$sec) = ($2,$3,$4);
      $txt = "$` $'";
   }
   my $txt = getopt("w:nSP",$txt,$opt);

   if($txt =~ /^\s*(\d+)\s*/ && $1 > 0 && $1 < 20) {
      $count = $1;
      $txt = $';
   } else {
      echo("%% Invalid repeat count (%s)",first($txt));
   }

   my $tick = $sec + ($min * 60) + ($hr * 3600);
   $tick = 1 if($tick <= 1);

   @pid{++@state{pid}} = { cmd   => $txt,
                           count => $count,
                           last  => time() - $tick - $tick,
                           tick  => $tick,
                           world => ($$opt{w} eq undef) ? @state{world} : 
                                    $$opt{w},
                         };
}

sub to_hhmmss
{
   my $secs = shift;
   my ($hr,$min);

   if($secs >= 3600) {
      $hr = sprintf("%d",$secs / 3600);
      $secs = $secs - ($hr * 3600);
   }
   if($secs >= 60) {
      $min = sprintf("%d",$secs / 60);
      $secs = $secs - ($min * 60);
   }

   return sprintf("%02d:%02d:%02d",$hr,$min,$secs);
}

sub run_pid
{
   my $id = shift;

   if(defined @pid{$id}) {
      if(@pid{$id}->{count} <= 0) {                       # done, don't run
         delete @pid{$id};
      } else {
         @pid{$id}->{last} = time();
         @pid{$id}->{count}--;
         do_cmd(@pid{$id}->{world},@pid{$id}->{cmd});
      }
   }
}
     
#
# do_cmd
#   Run an internal command.
# 
sub do_cmd
{
   my ($world,$input,$conn) = @_;

   if(remote() && $input !~ /^\s*\/(window|quit|key_ctl_l)\s*/) {
#      loggit("send: $input\n");
      return wc_out($input);
   }

   if($input =~ /^\/([^ ]+)\s*/) {
      if(defined @command{lc($1)}) {
         &{@command{lc($1)}}($conn,$');
         return 1;
      } else {
         echo("%% %s: no such command or macro",lc($1));
         return 1;
      }
  }
  return 0;
}

#
# cmd_web_size
#    Set tell muddler the size of the websocket connection.
#
sub cmd_web_size
{
#-# ------------------------------------------------------------------------
#-# /web_size <height>,<width>
#-#
#-#      Sets the height and width of the browser in number of characters
#-#      that can be displayed. This is used internally and should not be
#-#      needed to be set by the user.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($conn ne undef) {
      my (@size) = split(',',$txt);

      if(@size[0] =~ /^\s*(\d+)\s*$/) {
         @ws{$conn}->{size_x} = $1;
      }
      if(@size[1] =~ /^\s*(\d+)\s*$/) {
         @ws{$conn}->{size_y} = $1 - 3;
      }
   }
   redraw_output($conn,1);
}

sub nvl
{
   my ($value,$default) = @_;

   if($value eq undef) {
      return $default;
   } else {
      return $value;
   }
}

sub use_secure
{
   # required for ssl so the socket doesn't hang too long on a non SSL connect
   if(!module_enabled("IO::Socket::Timeout")) {
      return 0;
   } elsif(defined @state{p_key} && defined @state{p_cert}) {
      return 1;
   } else {
      return 0;
   }
}

sub cmd_web
{
#-# ------------------------------------------------------------------------
#-# /web                : Shows the current status of the web interface
#-# /web [on|off]       : Enables / Disables the web interface
#-# /web cert = <file>  : Specifies the cert file location
#-# /web key = <file>   : Specifies the key file location
#-#
#-# NOTE: If both the cert & key file are defined, muddler will enable the
#-#       https protocol.
#-#
#-#       A non-self signed cert/key is required for https to work. Without
#-#       one your browser will fail to connect.
#-# ------------------------------------------------------------------------
   my ($conn,$status) = @_;

   if(remote()) {
      return echo("%% Web/Websocket is disabled when --remote is enabled.");
   } elsif(!module_enabled("Net::WebSocket::Server")) {
      return echo("%% Web/Websocket disabled due to missing " .
         "Net::WebSocket::Server module");
   } elsif($status =~ /^\s*$/) {
      echo("Web Interface: %s",@state{web} ? "on" : "off");
      echo("   Protocol:      %s",use_secure() ? "https [secure]" :
          "http [non-secure]");
      echo("   Cert file:     %s",nvl(@state{p_cert},"Not defined"));
      echo("   Key file:      %s",nvl(@state{p_key},"Not defined"));
   } elsif($status =~ /^\s*(key|cert)\s*=(.*)$/i) {

      if(! length trim($2)) {
         echo("%% Certificate will no longer be used.");
      } else {
         return echo("%% Could not locate file: %s",trim($2)) if(!-e trim($2));
         echo("%% %s file is now: %s",lc($1),trim($2));
      }
      save("p_" . lc($1),trim($2));
   } elsif($status =~ /^\s*on\s*$/i) {
      if(@state{web} == 1) {
         echo("%% Web already enabled, Connect via: http%s://localhost:%s",
              use_secure() ? "s" : "",
              @state{p_port}
             );
          echo("%%    Password: %s",@state{p_password});
      } else {
         if(ws_init()) {
            echo("%% Web enabled, Connect via: http%s://localhost:%s",
                 use_secure() ? "s" : "",
                 @state{p_port}
             );
             echo("%%    Password: %s",@state{p_password});
         }
      }
   } elsif($status =~ /^\s*off\s*$/i) {
      if(@state{web} == 0) {
         echo("%% Web/Websocket server is already disabled.");
      } else {
         echo("%% Web/Websocket server has been disabled.");
         for my $key (keys %http) {
            @http{$key}->{sock}->close;
         }
         @state{web} = 0;
         eval { # manually shutdown http/websock. Calling websock's
                # way will shut everything down. This is good for their
                # code but not ours.
            for my $s (keys %ws) { 
               @ws{$s}->{conn}->disconnect;
               delete @ws{$s};
            }
            for my $s (keys %http) {
               @http{$s}->{sock}->close();
               delete @http{$s};
            }

            if($ws_listen ne undef) {
               $ws_server->{select_readable}->remove($ws_listen);
               $ws_listen->shutdown(2);
               $ws_listen = undef;
            }

            if($http_listen ne undef) {
               $ws_server->{select_readable}->remove($http_listen);
               $http_listen->shutdown(2);
               $http_listen = undef;
            }
         };
      }
   }
}

sub cmd_help
{
#-# ------------------------------------------------------------------------
#-# /help [<command>]
#-#      Shows the help for the specified command.
#-#
#-# Availible commands:
#-# ------------------------------------------------------------------------
   my ($conn,$cmd) = @_;
   

   if(!defined @state{help}) {
      echo("% No help loaded.");
   } elsif(trim($cmd) eq undef) {
      echo("\n%s",@state{help}->{cmd_help});
      for my $line (ansi_wrap(join(", ",sort grep {!/key_/} keys %command),
         @state{size_y}-5)) {
         echo("   %s",trim($line));
      }
   } elsif(defined @state{help}->{"cmd_" . lc(trim($cmd))}) {
      echo("\n%s",@state{help}->{"cmd_" . lc(trim($cmd))});
   } else {
      echo("%% Help on subject %s not found.",lc(trim($cmd)));
   }
}

sub cmd_version
{
   my ($conn,$txt) = @_;
#-# ------------------------------------------------------------------------
#-# /version
#-#      Shows the current version at startup of muddler. This is currently
#-#      not refreshed when the code is reloaded.
#-# ------------------------------------------------------------------------
   for my $line (split(/\n/,@state{version})) {
      ws_echo($conn,center($line));
#      echo("%s",center($line),1);
   }
}


sub remove_quotes
{
   my $txt = shift;

   if($txt =~ /^('|")(.*)('|")$/) {
      return $2;
   } else {
      return $txt;
   }
}

sub get_segment_end
{
   my $txt = shift;
   my ($in_single, $in_double);

   for(my $i=0;$i <= length($txt);$i++) {
      my $ch = substr($txt,$i,1);

      if($ch eq "\\") {
         $ch++;
      } elsif($ch eq "\"" && !$in_single) {
         $in_double = !$in_double;
      } elsif($ch eq "\'" && !$in_double) {
         $in_single = !$in_single;
      } elsif($ch eq " " && !$in_single && !$in_double) {
         return $i;                                       # done
      }
   }
   return length($txt);
}

sub getopt
{
   my ($opts,$txt,$result,$time) = @_;
   my ($in_arg,%lookfor,$prev,$end);

   for(my $i = 0;$i < length($opts);$i++) {     # determine what to look for
      my $ch = substr($opts,$i,1);
      if($ch eq ":") {
         @lookfor{$prev} = 2 if($prev ne undef); # populate hash with details
      } else {
         @lookfor{$ch} = 1;
      }
      $prev = $ch;
   }

   for(my $i = 0;$i <= length($txt);$i++) {         # take apart $txt string
      my $ch = substr($txt,$i,1);

      if($ch eq "\\") {                                       # escaped char
         $i++;
      } elsif($ch eq "-" && !$in_arg) {                  # start of   option 
         $in_arg = 1;
      } elsif($in_arg and $ch eq " ") {                      # end of option
         $in_arg = 0;
      } elsif($in_arg) {                                   # option contents
         if(defined @lookfor{$ch} || ($time && $ch =~ /^\d+$/)) {
            if(@lookfor{$ch} == 1) {                         # simple option
               $$result{$ch} = 1;
            } elsif(@lookfor{$ch} == 2 || ($time && $ch =~ /^\d+$/)) {
               # option w/value
               $end = get_segment_end(substr($txt,$i));      # scan to end
               if($time && $ch =~ /^\d+$/) {
                  $$result{time} = remove_quotes(trim(substr($txt,$i,$end))); 
                  $i += $end - 1;
               } elsif($end eq undef) {                      # nothing found
                  $$result{$ch} = "";
               } else {                                    # found something
                  $$result{$ch} = remove_quotes(trim(substr($txt,$i+1,$end))); 
                  $i += $end - 1;
               }
            }
         } else {
           # invalid option, probably should die/error out here
         }
      } else {                                  # store string minus options
         return substr($txt,$i);
      }
   }
}


sub t
{
   my $pm;
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime();
   if($hour > 12) {
      $pm = "p";
      $hour -= 12;
   } else {
      $pm = "a";
   }
   
   return sprintf("%2d:%02d%s",$hour,$min,$pm);
}
sub ts
{
   my $time = shift;

   $time = time() if $time eq undef;
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime($time);
   $mon++;

   return sprintf("%02d:%02d@%02d/%02d",$hour,$min,$mon,$mday);
}

sub cmd_quote
{
#-# ------------------------------------------------------------------------
#-# /quote [options] <command>
#-#
#-#      Quotes a command, file, or muddler command to a world.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $w = world($conn);
   my ($fd,$pre,$array,$when);
   my $world = $conn;
   my $opt = {};

   $txt = getopt("d:w:s",$txt,$opt,1);

   # future impliment?
   my $delay = 0;
   if(defined $$opt{time}) {
      if($$opt{time} =~ /^\s*([\d]+):([\d+]):([\d+])\s*/) {
         if($1 > 24) {
            return echo("%% QUOTE : there are only 24hrs in a day.");
         } elsif($2 > 59) {
            return echo("%% QUOTE : there are only 60 minutes in an hour.");
         } elsif($3 > 59) {
            return echo("%% QUOTE : there are only 60 seconds in an minute.");
         }
         $delay = ($1 * 3600) + ($2 * 60) + $3;
      } elsif($txt =~ /^\s*([\d]+):([\d+])\s*/) {
         if($1 > 59) {
            return echo("%% QUOTE : there are only 24hrs in a day.");
         } elsif($2 > 59) {
            return echo("%% QUOTE : there are only 60 minutes in an hour.");
         }
         $delay = ($1 * 60) + $2;
      } elsif($$opt{time} =~ /^\s*([\d]+)\s*/) {
         if($1 > 59) {
            return echo("%% QUOTE : there are only 60 seconds in an minute.");
         }
         $delay = $1;
      }
   }

   $$opt{w} = $conn if(!defined $$opt{w});
   $$opt{d} = "send" if(!defined $$opt{d});
   if($$opt{d} !~ /^(echo|send|exec|0|1|2)$/) {
      return echo("%% QUOTE -d: Invalid -d value \"$$opt{d}\".  Valid " .
         "values are: echo (0), send (1), exec (2)");
   }

   if(!defined @socket{$$opt{w}}) {
      return echo("%% QUOTE: Not connected to world $$opt{$w}");
   }

   if($txt =~ /^([^!`']+)!\s*/) {
      $pre = $1;
      open($fd,"$' |") ||
         return echo("%% Unable to run commmand '$''.");
   } elsif($txt =~ /^([^!`']+)'\s*/) {
      $pre = $1;
      open($fd,"< $'") ||
         return echo("%% Unable to open file '$txt' for reading.");
   } elsif($txt =~ /^([^!`']+)`\s*/) {
      $pre = $1;
      return echo("%% Quoting muddler commands not supported yet");
   } else {
      return echo("%% QUOTE: missing command character");
   }

  
   @socket{$$opt{w}}->{quote} = [] if(!defined @socket{$$opt{w}}->{quote});
   $array = @socket{$$opt{w}}->{quote} = [];
   $when = time();

   while(<$fd>) {
      # queue up output so it can be processed $when it is time, even
      # if that is now.
      push(@$array,{ when => $when,
                     what => $pre . $_,
                     how  => $$opt{d},
                   }
          );
      $when += $delay;
   }
   close($fd);
}

sub cmd_recall
{
#-# ------------------------------------------------------------------------
#-# /recall [<count>] <pattern>
#-#      Does a recall of ten lines from the current world's history
#-#      buffer that matches pattern. The amount of lines can be
#-#      changed by specifying a count.
#-#
#-# Patterns:
#-#      Patterns may contain text that will be matched as is but also
#-#      May contain * as a wild card or ? to match a single character.   
#-#
#-# Example:
#-#      /recall *pages*
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my ($count,$pat,@out,$gagged) = 10;
   my $opt = {};

   return echo("%% Not connected to a world.") if(no_world());
   $txt = getopt("a:t",$txt,$opt);
   my $w = world($conn);

   if($txt =~ /^\s*(\d+)\s*/) {
      $count = $1;
      $pat = $';
   } elsif($txt =~ /^\s*\/(\d+)\s*/) {
      $count = $1;
      $pat = $';
   } else {
      $pat = $txt;
   }

   $pat = "*" if $pat eq undef;

   # include gagged content?
   if($$opt{a} =~ /g/) {
      $gagged = 1;
   } else {
      $gagged = 0;
   }

   $pat = glob2re($pat);
   for(my $i=$#{@history{@state{world}}};$i >= 0 && $count > 0;$i--) {
      eval {
         if(((!$gagged && !@history{@state{world}}->[$i]->{gagged}) || 
            $gagged) &&
            ansi_remove(@history{@state{world}}->[$i]->{txt}) =~ /$pat/) {

            # order will be backwards, so store.
            if($$opt{t}) {
               unshift(@out,"[" . ts(@history{$w}->[$i]->{ts}) . "] " . 
                       @history{$w}->[$i]->{txt});
            } else {
               unshift(@out,@history{$w}->[$i]->{txt});
            }

            $count--;
         }
      };
   }
   for my $i (0 .. $#out) {
      echo_wrap(@out[$i]);                       # output in correct order
   }
}

sub small
{
   my $txt = shift;

   if($txt =~ /\(([^\)]+)\)/) {
      return $1;
   } else {
      return $txt;
   }
}

sub cmd_listsockets
{
#-# ------------------------------------------------------------------------
#-# /list_sockets
#-#      Shows all open connections and some minimal data about them.
#-# ------------------------------------------------------------------------
   echo("%-16s %-26s %-5s %-3s","NAME","HOST","PORT","Secure");
   for my $key (keys %ws) {
#       loggit("%s\n",print_var(@ws{$key}));
       echo("%-16s %-26s %-5s %-3s     %sx%s/%s",
            @ws{$key}->{auth} ? "Web [auth]" : "Web",
            @ws{$key}->{ip},
            @ws{$key}->{port},
            @state{secure} ? "Yes" : "",
            @ws{$key}->{size_x},@ws{$key}->{size_y},small($key));
   }
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock}) {
         echo("%-16s %-26s %-5s %-3s", 
              @address{$w}->{name},
              @address{$w}->{host},
              @address{$w}->{port},
              @address{$w}->{ssl} ? "Yes" : "");
      }
   }
}
sub cmd_quit
{
#-# ------------------------------------------------------------------------
#-# /quit
#-#      Exits out of muddler
#-# ------------------------------------------------------------------------
   revert_console();
   exit(1);
}

sub cmd_reload
{
#-# ------------------------------------------------------------------------
#-# /reload
#-#      Reloads the perl code for muddler without dropping connections.
#-#      As long as no new variables are set, there is a 80% chance
#-#      that the client will continue and not have issues.
#-# ------------------------------------------------------------------------
   reload_code();
#   for my $name (keys %socket) {
#      if(@socket{$name}->{name} eq "8bit") {
#         delete @socket_lookup{@socket{$name}->{sock}};
#         delete @socket{$name}->{sock};
#      }
#   }
}

sub cmd_world
{
#-# ------------------------------------------------------------------------
#-# /world <world>
#-#      Connects to the specified world if not connected or switches over
#-#      to that world if it is connected.
#-#
#-# Ex: /world puggy
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = (shift,lc(trim(shift)));
   my $opt = {};
   $txt = getopt("l",$txt,$opt);


   if($txt =~ /^\s*([^ ]+)\s*(\d+)$/) {
      for my $i (1 .. 100) {
         if(!defined @address{"(Unnamed_#" . $i . ")"}) {
            cmd_addworld($conn,"(Unnamed_#" . $i . ") $txt");
            $txt = "(Unnamed_#" . $i . ")";
            last;
         }
      }
   }

   if(!defined @address{$txt}) {
      return echo("% CONNECT: no such world '%s'",$txt);
   } elsif(defined @socket{$txt} && defined @socket{$txt}->{sock}) {
      switch_world($conn,$txt);
   } else {
      socket_connect($conn,
                     @address{$txt}->{name},
                     @address{$txt}->{host},
                     @address{$txt}->{port},
                     (!defined @address{$txt}->{ssl} ||
                      !@address{$txt}->{ssl}) ? 0 : 1,
                     $opt
                    );
   }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  misc code                                                                 #
#                                                                            #
#----------------------------------------------------------------------------#

END {
     revert_console();
     printf("%s\n",@state{err}) if(@state{err});
}

sub center
{
    my $txt = shift;

    return sprintf("%s%s",(" " x ((@state{size_y} - length($txt)-1) / 2)),$txt);
}

#
# optimize_start
#    Flag that the script will probably be doing multiple outputs. This flag
#    will cause the script to not reset the scroll regions after each output
#    until otimize_end is called.
#
sub optimize_start
{
   @state{optimize_output} = 1;
}

#
# optimize_end
#    The script has just finished sending a block of output to the screen.
#    Its now okay to set the scroll region and move the cursor back to where
#    the user is expecting.
#
sub optimize_end
{
   @state{optimize_output} = 0;
   update_scroll_region("input");
   xy(input_x(),input_y());
}

sub show_banner
{
   optimize_start();
   echo("%s",center('     ( A 90dies mud client written today ) '));
   echo("%s",center('    o               v1.0a                   '));
   echo("%s",center('   o _____                __  __ _          '));
   echo("%s",center(' _||_| u |    _ _  _ _ __| /_| /| |  __ ____'));
   echo("%s",center('(        |== / v \| | |  _ | _ || |/ -_) __/'));
   echo("%s",center('/-()---()   |_|_|_|___/\___\___/|_|\__/_/   '));
   echo("%s","");
   echo("%s","");
   echo("%s","");
   optimize_end();
}

#
# read_tfworlds
#    Quick and dirty subroutine to read tf's world file if named .tfworlds.
#
sub read_tfworlds
{
   my ($fn,$quiet) = @_;
   my ($file, $bad);

   return if remote();

   if(-e "@ENV{HOME}/.muddler" || !-e "@ENV{HOME}/.tfworlds") {
      return;
   } elsif(!module_enabled("Text::ParseWords")) {
      echo("%% .tfworlds may not be read without Text::ParseWords module");
   } else {
      if(!open($file,$fn)) {
         echo("%% Unable to open '%s' for reading",$fn) if (!$quiet);
         return;
      }
   
      while(<$file>) {
         s/\r|\n//g;
         if(/^\/test addworld\((.*)\)$/) {
            my @data = quotewords(',',0,$1);
            @address{lc(trim(@data[0]))} = {};
            @address{lc(trim(@data[0]))}->{host} = trim(@data[2]);
            @address{lc(trim(@data[0]))}->{port} = trim(@data[3]);;
            @address{lc(trim(@data[0]))}->{user} = trim(@data[4]);;
            @address{lc(trim(@data[0]))}->{pass} = trim(@data[5]);;
            @address{lc(trim(@data[0]))}->{name} = trim(@data[0]);
         } else {
            $bad++;
            echo("%% Unknown data: '%s'",$_);
         }
      }
      close($file);
      echo("%% %d worlds read from tfworlds file.",scalar keys %address);
   }
}

sub read_tfrc
{
   my $fn = shift;
   my ($file, $prev);

   return if remote();

   open($file,$fn) || return;

   while(<$file>) {
      s/\r|\n//g;
      if(/^\s*;/) {
         # comment;
      } elsif(/\s*\\\s*$/) {
         $prev .= $`;
      } elsif($prev . $_ !~ /^\s*\/set /) {
         do_cmd(undef,$prev . $_);
         $prev = undef;
      }
   }
   close($file);
}

sub get_checksums
{
   my ($file,$pos,%data);
   my $ln = 1;
#

   return if(!module_enabled("Digest::MD5"));
      
   open($file,$0) ||
     return echo("%% Unable to read source file, /reload will be disabled");

   for my $line (<$file>) {
      if($pos eq undef && $line =~ /^sub\s+([^ \n\r]+)\s*$/) {
         $pos = $1;
         @data{$pos} = { chk => Digest::MD5->new };
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{src} .= qq[#line 0 "$pos"\n] . $line;
         @data{$pos}->{line} = $ln;
         if($pos =~ /^cmd_/) {
            @state{help} = {} if not defined @state{help};
            delete @state{help}->{$pos} if defined @state{help}->{$pos};
         }
      } elsif($pos ne undef && $line =~ /^}\s*$/) {
         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{chk} = @data{$pos}->{chk}->hexdigest;
         @data{$pos}->{done} = 1;
         if($pos =~ /cmd_/) {
            @state{help}->{$pos} =~ s/\n$//;
         }
         $pos = undef;
      } elsif($pos ne undef) {
         if($pos =~ /cmd_/) {
            if($line =~ /^#-# -+$/) {
               # header ignored
            } elsif($line =~ /^#-# {0,1}/) {
               @state{help}->{$pos} .= $';
            }
         }

         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
      }
      $ln++;
   }
   close($file);

   for my $pos (keys %data) {
      if(!defined @data{$pos}->{done}) {
         echo("% Warning: Did not find end to %s",$pos);
      }
   }
   return \%data;
}

#
# reload_code
#    As long as the global variables do not change, the code can be
#    reloaded without dropping any connections.
#
sub reload_code
{
   my $nomodules = shift;
   my $count = 0;

   return http_data_init() if(@ENV{PAR_0});

   my $new = get_checksums();
   my $old = @state{chksum};
   $old = {} if $old eq undef;

   if(!module_enabled("Digest::MD5")) {
      return echo("%% Missing Digest::MD5 module, reloading code disabled");
   }

   for my $key (keys %$new) {
      if((@state{state} eq "init" || 
         (!defined $$old{$key} || $$old{$key}->{chk} ne $$new{$key}->{chk}))) {
         
         loggit("%% Reloading: %s",$key) if @state{state} ne "init";
#         echo("%% Reloading: %s",$key) if @state{state} ne "init";
         eval($$new{$key}->{src});
         $count++;
         if($@) {
            echo("%% Error reloading $key: %s",$@);
            $$new{$key}->{chk} = -1;
         } else {
            echo("%% Reloading: %s [done]",$key) if @state{state} ne "init";
         }
      }
   }
   @state{chksum} = $new;
   command_init();
   key_init();
   http_data_init();
   telnet_ch_init();
   var_init();
   load_modules() if(!$nomodules);


   if($count == 0) {
      echo("%% No changes found to reload.");
   }
}

#
# ignoreit
#    Ignore certain hash key entries at all depths or just the specified
#    depth.
#
sub ignoreit
{
   my ($skip,$key,$depth) = @_;


   if(!defined $$skip{$key}) {
      return 0;
   } elsif($$skip{$key} < 0 || ($$skip{$key} >= 0 && $$skip{$key} == $depth)) {
     return 1;
   } else {
     return 0;
   }
}

#
# print_var
#    Return a "text" printable version of a HASH / Array
#
sub print_var
{
   my ($var,$depth,$name,$skip,$recursive) = @_;
   my ($PL,$PR) = ('{','}');
   my $out;

   if($depth > 4) {
       return (" " x ($depth * 2)) .  " -> TO_BIG\n";
   }
   $depth = 0 if $depth eq "";
   $out .= (" " x ($depth * 2)) . (($name eq undef) ? "UNDEFINED" : $name) .
           " $PL\n" if(!$recursive);
   $depth++;

   for my $key (sort ((ref($var) eq "HASH") ? keys %$var : 0 .. $#$var)) {

      my $data = (ref($var) eq "HASH") ? $$var{$key} : $$var[$key];

#      if((ref($data) eq "HASH" || ref($data) eq "ARRAY") &&
#         !ignoreit($skip,$key,$depth)) {
#         $out .= sprintf("%s%s $PL\n"," " x ($depth*2),$key);
#         $out .= print_var($data,$depth+1,$key,$skip,1);
#         $out .= sprintf("%s$PR\n"," " x ($depth*2));
#      } elsif(!ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s = %s\n"," " x ($depth*2),$key,$data);
#      }
   }

   $out .= (" " x (($depth-1)*2)) . "$PR\n" if(!$recursive);
   return $out;
}


#
# remove any space at the begining or end of a string
#
sub trim
{
   my $txt = shift;

   $txt =~ s/^\s+|\s+$//g;
   return $txt;
}

sub tick
{
   # keep alive. Send something to a world to keep it alive if nothing has
   # been sent / recieved.
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock} && 
         time()-@socket{$w}->{last_send} > 100) {
         if(defined @address{$w} && defined @address{$w}->{keepalive}) {
            out($w,@address{$w}->{keepalive} . "\n",ts());
         } else {
            out($w,"\@\@ idle\n");
         }
      }

      # handle results from /quote command as they may need to be handled
      # in the future and not specifically when cmd_quote() is running.
      if(defined @socket{$w}->{quote}) {
         my $quote = @socket{$w}->{quote};

         while($#$quote > -1 && $$quote[0]->{when} <= time()) {
             my $item = shift(@$quote);
             if($$item{how} eq "echo" || $$item{how} eq 0) {
                # impliment me, yes you.
             } elsif($$item{how} eq "send" || $$item{how} eq 1) {
                out($w,"%s\n",$$item{what});
             } elsif($$item{how} eq "exec" || $$item{how} eq 2) {
                # impliment me, yes you.
             }
         }
         delete @socket{$w}->{quote} if($#$quote == -1);
      }
   }

   # a window change happened but we buffer it after the first change.
   if(defined @state{winch_pending} && time() - @state{winch} >= 3) {
      delete @state{winch_pending};
      delete @state{winch};
      change_window_size();
   }

   if(time() - @state{wrap_garbage_collect_last} > 300) {
      @state{wrap_garbage_collect_last}  = time();
      wrap_garbage_collect();
   }

   if(web()) {
      for my $key (keys %ws) {
         if(@ws{$key}->{auth} eq 0 && time() - @ws{$key}->{start} > 60) {
            ws_echo(@ws{$key}->{conn},"t","%% Password entry timed out",1);
            ws_disconnect(@ws{$key}->{conn});
         }
      }
   }
 
   for my $id (keys %pid) {
      if(@pid{$id}->{last} + @pid{$id}->{tick} <= time()) {
         run_pid($id);
      }
   }
}

sub read_file
{
   my $fn =shift;
   my $file;

   open($file,$fn) || 
      die("Could not open '$fn' for reading");
   my $result = join("",<$file>);
   close($file);
   return $result;
}

#
# muddler_init: run once type stuff
#
sub muddler_init
{
   if(module_enabled("Net::WebSocket::Server") && !remote()) {
      $ws_server = Net::WebSocket::Server->new(
         tick_period => 1,
         on_connect => 
            sub { my( $serv, $conn ) = @_;
                  $conn->on( ready =>      sub{ ws_login_screen(@_); },
                             utf8  =>      sub{ ws_process( @_, 0 ); },
                             disconnect => sub{ ws_disconnect(@_);   },
                           );
             },
         );
   }
   listener_init();

   # for temporay viewport for output before a connected world
   push(@input,[]);
   @state{telnet_mode} = "normal";
   @history{muddler} = [];
   @socket{muddler} = { name        => "muddler",
                        more        => -1,
                        more_count  => 0,
                        last_read   => -1,
                        history_pos => -1,
                        history_pos_partial => -1,
                      };

   @state{state} = "init";

   if(module_enabled("Term::ReadKey")) {
      (@state{size_y},@state{size_x}) = GetTerminalSize();
   } else {
      (@state{size_x},@state{size_y}) = 
          `stty size`=~/(\d+)\s+(\d+)/?($1,$2):(80,25);
   }

   @state{chksum} = get_checksums();
   load(1);
   loggit("### START ###");

   # initialize websocket client
   wc_init() if remote();

   if(console()) {
      $| = 1;                                                  # unbuffer stdout
      cbreak();
   }

   key_init();
   command_init();

   redraw_screen(@state{world},1);
   show_banner() if !remote();

   read_tfworlds("@ENV{HOME}/.tfworlds",1) if(!-e "@ENV{HOME}/.muddler");
   read_tfrc("@ENV{HOME}/.tfrc",1);
   reload_code(1);
#   Monitor::monitor(@pending{alpha}, "array");
   @state{state} = "post-init";

   # these should go into another variable, but this allows reloading
   @state{IAC} = chr(255);
   @state{SB} = chr(250);
   @state{SE} = chr(240);
   @state{255} = 'IAC';
   @state{250} = 'SB';
   @state{240} = 'SE';
   @state{241} = 'NOP';

   @state{WILL} = chr(251);
   @state{WONT} = chr(252);
   @state{DO}   = chr(253);
   @state{DONT} = chr(254);
   @state{251} = 'WILL';
   @state{252} = 'WONT';
   @state{253} = 'DO';
   @state{254} = 'DONT';
   telnet_ch_init();
}

#
# muddler
#    Contents of the main loop, seperated so it can be reloaded since
#    the main loop should not be.
#
sub muddler
{
   local $SIG{ALRM} = sub {
      delete @pid{keys %pid};
      loggit("### Fatal ### Alarm timeout");
      loggit(code("long"));
      die("alarm\n");
   };
   alarm(15);

   io();
   loggit("Crash? $@") if($@);
   draw_bar();

   if(time() - @state{tick_last} >= 1) {
      tick();
      @state{tick_last} = time();
   }
   alarm(0);
}

#
# sig_usr1
#    Handle the SIGUSR1 signal and reload the perl code in case the code can
#    not be reloaded any other way.
#
$SIG{USR1} = sub { sig_usr1(); };
sub sig_usr1
{
   delete @pid{keys %pid};
   reload_code();
}

#
# sig_int
#   Catch control-c without exiting?
#
$SIG{'INT'} = sub { sig_int() };

sub sig_int
{
    if(defined @state{ctl_c} && time() - @state{ctl_c} < 30) {
       exit(1);
    } else {
       echo("Warning: A Control-C was recieved. Two are needed to exit.");
       @state{ctl_c} = time();
    }
}


#
# sig_winch
#    Handle the WINCH signal and get the new size of the window and
#    adjust accordingly.
#
$SIG{'WINCH'} = sub { sig_winch(); };

sub change_window_size
{
   if(module_enabled("Term::ReadKey")) {
      (@state{size_y},@state{size_x}) = GetTerminalSize();
   } else {
      (@state{size_x},@state{size_y}) =
          `stty size`=~/(\d+)\s+(\d+)/?($1,$2):(80,25);
   }

   if(remote()) {
      wc_out("/web_size %s,%s\n",@state{size_x},@state{size_y}+3);
      redraw_input();
   } else {
      for my $key (keys %socket) {
         pending_fix($key);
      }
      redraw_screen(@state{world},1);
   }
}

#
# sig_winch
#    The window size has changed. This may happen to frequently, so
#    do the change only every 3 seconds. tick() will handle the
#    followup window size change.
#
sub sig_winch
{
   if(defined @state{winch} && time() - @state{winch} < 3) {
      @state{winch} = time();
      @state{winch_pending} = 1;
   } else {
      @state{winch} = time();
      change_window_size();
   } 
}

sub install_modules
{
   my (%pkg, %cpan);
   load_modules();

   for my $key (keys %mod) {
      if(!module_enabled($key) && defined @mod{$key}->{pkg}) {
         @pkg{@mod{$key}->{pkg}} = 1;
      }
      if(!module_enabled($key) && defined @mod{$key}->{cpan} && @mod{$key}->{cpan} eq "yes") {
         @cpan{$key} = 1;
      }
   }

   if(scalar keys %pkg > 0) {
      printf("running: sudo apt install %s\n",join(" ",keys %pkg));
      system(sprintf("sudo apt install %s\n",join(" ",keys %pkg)));
   }


   if(scalar keys %cpan > 0) {
      for my $key (keys %cpan) {
         printf("running: perl -MCPAN -e \"install $key\"\n");
         system("perl -MCPAN -e \"install $key\"");
      }
   }

   exit();
}

load_modules();

for my $i (0 .. $#ARGV) {
   if(@ARGV[$i] eq "--noconsole") {
      @state{console} = 0;
   } elsif(@ARGV[$i] eq "--install") {
     install_modules(); 
   } elsif(@ARGV[$i] =~ /^--port=(\d+)$/) {
      @state{port} = $1;
   } elsif(@ARGV[$i] =~ /^--(pass|password)=(.*)$/) {
      save("p_password",$2);
   } elsif(@ARGV[$i] =~ /^--xy=(\d+),(\d+)$/) {
      (@state{size_x},@state{size_y}) = ($1,$2);
   } elsif(@ARGV[$i] =~ /^--window=/) {
      @state{console} = 0;
      @state{window_value} = $';
   } elsif(@ARGV[$i] =~ /^--remote=/) {
      my $value = $';
      if($value =~ /^([^:]+):(\d+)$/) {
         @state{remote} = 1;
         @state{remote_address} = $value;
      } else {
         die("Remote usage: --remote or --remote=host:port [$value]");
      }
   } elsif(@ARGV[$i] =~ /^--remote$/) {
      @state{remote} = 1;
   } else {
     die("Invalid Option: '@ARGV[$i]'");
   }
}

ws_init() if !console();

if(!module_enabled("Net::WebSocket::Server") || remote()) {
   $ws_server = {};
   $ws_server->{select_readable} = IO::Select->new();
}

muddler_init();

if(defined @state{modules}) {
   for my $i (0 .. $#{@state{modules}}) {
      echo("%s %s",(($i == 0) ? "Optional:" : (" " x 9)),@state{modules}->[$i]);
   }
}
# keep the main loop small.
while(1) {
   eval { muddler(); };
#   muddler();
   loggit("Fatal: $@ -> %s\n",code()) if($@);
}

__DATA__
START: muddler_ansi.css
   /* underlined text */
   .ansi-4 { text-decoration: underline; }
   
   /* blinking text */
   .ansi-5 {
       -webkit-animation: blink .75s linear infinite;
       -moz-animation: blink .75s linear infinite;
       -ms-animation: blink .75s linear infinite;
       -o-animation: blink .75s linear infinite;
       animation: blink .75s linear infinite;
   }

   /* standard 16 foreground colors */
   .ansi-30 { color: black; }
   .ansi-1-30 { color: gray; }
   .ansi-31 { color: maroon; }
   .ansi-1-31 { color: red; }
   .ansi-32 { color: green; }
   .ansi-1-32 { color: lime; }
   .ansi-33 { color: olive; }
   .ansi-1-33 { color: yellow; }
   .ansi-34 { color: navy; }
   .ansi-1-34 { color: blue; }
   .ansi-35 { color: purple; }
   .ansi-1-35 { color: fuchsia; }
   .ansi-36 { color: teal; }
   .ansi-1-36 { color: aqua; }
   .ansi-37 { color: black; }
   .ansi-1-37 { color: black; } 


   /* standard 16 background colors */
   .ansi-40 { background-color: black; }
   .ansi-1-40 { background-color: gray; }
   .ansi-41 { background-color: maroon; }
   .ansi-1-41 { background-color: red; }
   .ansi-42 { background-color: green; }
   .ansi-1-42 { background-color: lime; }
   .ansi-43 { background-color: olive; }
   .ansi-1-43 { background-color: yellow; }
   .ansi-44 { background-color: navy; }
   .ansi-1-44 { background-color: blue; }
   .ansi-45 { background-color: purple; }
   .ansi-1-45 { background-color: fuchsia; }
   .ansi-46 { background-color: teal; }
   .ansi-1-46 { background-color: aqua; }
   .ansi-47 { background-color: silver; }
   .ansi-1-47 { background-color: white; }
   
   .ansi-38-5-0     { color:            #000000; }
   .ansi-38-5-1     { color:            #cd0000; }
   .ansi-38-5-2     { color:            #00cd00; }
   .ansi-38-5-3     { color:            #cdcd00; }
   .ansi-38-5-4     { color:            #0000ee; }
   .ansi-38-5-5     { color:            #cd00cd; }
   .ansi-38-5-6     { color:            #00cdcd; }
   .ansi-38-5-7     { color:            #e5e5e5; }
   .ansi-38-5-8     { color:            #7f7f7f; }
   .ansi-38-5-9     { color:            #ff0000; }
   .ansi-38-5-10    { color:            #00ff00; }
   .ansi-38-5-11    { color:            #e8e800; }
   .ansi-38-5-12    { color:            #5c5cff; }
   .ansi-38-5-13    { color:            #ff00ff; }
   .ansi-38-5-14    { color:            #00ffff; }
   .ansi-38-5-15    { color:            #ffffff; }
   
   /* XTERM colors - 256 color mode */
   .ansi-38-5-16    { color:            #000000; }
   .ansi-38-5-17    { color:            #00005f; }
   .ansi-38-5-18    { color:            #000087; }
   .ansi-38-5-19    { color:            #0000af; }
   .ansi-38-5-20    { color:            #0000d7; }
   .ansi-38-5-21    { color:            #0000ff; }
   .ansi-38-5-22    { color:            #005f00; }
   .ansi-38-5-23    { color:            #005f5f; }
   .ansi-38-5-24    { color:            #005f87; }
   .ansi-38-5-25    { color:            #005faf; }
   .ansi-38-5-26    { color:            #005fd7; }
   .ansi-38-5-27    { color:            #005fff; }
   .ansi-38-5-28    { color:            #008700; }
   .ansi-38-5-29    { color:            #00875f; }
   .ansi-38-5-30    { color:            #008787; }
   .ansi-38-5-31    { color:            #0087af; }
   .ansi-38-5-32    { color:            #0087d7; }
   .ansi-38-5-33    { color:            #0087ff; }
   .ansi-38-5-34    { color:            #00af00; }
   .ansi-38-5-35    { color:            #00af5f; }
   .ansi-38-5-36    { color:            #00af87; }
   .ansi-38-5-37    { color:            #00afaf; }
   .ansi-38-5-38    { color:            #00afd7; }
   .ansi-38-5-39    { color:            #00afff; }
   .ansi-38-5-40    { color:            #00d700; }
   .ansi-38-5-41    { color:            #00d75f; }
   .ansi-38-5-42    { color:            #00d787; }
   .ansi-38-5-43    { color:            #00d7af; }
   .ansi-38-5-44    { color:            #00d7d7; }
   .ansi-38-5-45    { color:            #00d7ff; }
   .ansi-38-5-46    { color:            #00ff00; }
   .ansi-38-5-47    { color:            #00ff5f; }
   .ansi-38-5-48    { color:            #00ff87; }
   .ansi-38-5-49    { color:            #00ffaf; }
   .ansi-38-5-50    { color:            #00ffd7; }
   .ansi-38-5-51    { color:            #00ffff; }
   .ansi-38-5-52    { color:            #5f0000; }
   .ansi-38-5-53    { color:            #5f005f; }
   .ansi-38-5-54    { color:            #5f0087; }
   .ansi-38-5-55    { color:            #5f00af; }
   .ansi-38-5-56    { color:            #5f00d7; }
   .ansi-38-5-57    { color:            #5f00ff; }
   .ansi-38-5-58    { color:            #5f5f00; }
   .ansi-38-5-59    { color:            #5f5f5f; }
   .ansi-38-5-60    { color:            #5f5f87; }
   .ansi-38-5-61    { color:            #5f5faf; }
   .ansi-38-5-62    { color:            #5f5fd7; }
   .ansi-38-5-63    { color:            #5f5fff; }
   .ansi-38-5-64    { color:            #5f8700; }
   .ansi-38-5-65    { color:            #5f875f; }
   .ansi-38-5-66    { color:            #5f8787; }
   .ansi-38-5-67    { color:            #5f87af; }
   .ansi-38-5-68    { color:            #5f87d7; }
   .ansi-38-5-69    { color:            #5f87ff; }
   .ansi-38-5-70    { color:            #5faf00; }
   .ansi-38-5-71    { color:            #5faf5f; }
   .ansi-38-5-72    { color:            #5faf87; }
   .ansi-38-5-73    { color:            #5fafaf; }
   .ansi-38-5-74    { color:            #5fafd7; }
   .ansi-38-5-75    { color:            #5fafff; }
   .ansi-38-5-76    { color:            #5fd700; }
   .ansi-38-5-77    { color:            #5fd75f; }
   .ansi-38-5-78    { color:            #5fd787; }
   .ansi-38-5-79    { color:            #5fd7af; }
   .ansi-38-5-80    { color:            #5fd7d7; }
   .ansi-38-5-81    { color:            #5fd7ff; }
   .ansi-38-5-82    { color:            #5fff00; }
   .ansi-38-5-83    { color:            #5fff5f; }
   .ansi-38-5-84    { color:            #5fff87; }
   .ansi-38-5-85    { color:            #5fffaf; }
   .ansi-38-5-86    { color:            #5fffd7; }
   .ansi-38-5-87    { color:            #5fffff; }
   .ansi-38-5-88    { color:            #870000; }
   .ansi-38-5-89    { color:            #87005f; }
   .ansi-38-5-90    { color:            #870087; }
   .ansi-38-5-91    { color:            #8700af; }
   .ansi-38-5-92    { color:            #8700d7; }
   .ansi-38-5-93    { color:            #8700ff; }
   .ansi-38-5-94    { color:            #875f00; }
   .ansi-38-5-95    { color:            #875f5f; }
   .ansi-38-5-96    { color:            #875f87; }
   .ansi-38-5-97    { color:            #875faf; }
   .ansi-38-5-98    { color:            #875fd7; }
   .ansi-38-5-99    { color:            #875fff; }
   .ansi-38-5-100   { color:            #878700; }
   .ansi-38-5-101   { color:            #87875f; }
   .ansi-38-5-102   { color:            #878787; }
   .ansi-38-5-103   { color:            #8787af; }
   .ansi-38-5-104   { color:            #8787d7; }
   .ansi-38-5-105   { color:            #8787ff; }
   .ansi-38-5-106   { color:            #87af00; }
   .ansi-38-5-107   { color:            #87af5f; }
   .ansi-38-5-108   { color:            #87af87; }
   .ansi-38-5-109   { color:            #87afaf; }
   .ansi-38-5-110   { color:            #87afd7; }
   .ansi-38-5-111   { color:            #87afff; }
   .ansi-38-5-112   { color:            #87d700; }
   .ansi-38-5-113   { color:            #87d75f; }
   .ansi-38-5-114   { color:            #87d787; }
   .ansi-38-5-115   { color:            #87d7af; }
   .ansi-38-5-116   { color:            #87d7d7; }
   .ansi-38-5-117   { color:            #87d7ff; }
   .ansi-38-5-118   { color:            #87ff00; }
   .ansi-38-5-119   { color:            #87ff5f; }
   .ansi-38-5-120   { color:            #87ff87; }
   .ansi-38-5-121   { color:            #87ffaf; }
   .ansi-38-5-122   { color:            #87ffd7; }
   .ansi-38-5-123   { color:            #87ffff; }
   .ansi-38-5-124   { color:            #af0000; }
   .ansi-38-5-125   { color:            #af005f; }
   .ansi-38-5-126   { color:            #af0087; }
   .ansi-38-5-127   { color:            #af00af; }
   .ansi-38-5-128   { color:            #af00d7; }
   .ansi-38-5-129   { color:            #af00ff; }
   .ansi-38-5-130   { color:            #af5f00; }
   .ansi-38-5-131   { color:            #af5f5f; }
   .ansi-38-5-132   { color:            #af5f87; }
   .ansi-38-5-133   { color:            #af5faf; }
   .ansi-38-5-134   { color:            #af5fd7; }
   .ansi-38-5-135   { color:            #af5fff; }
   .ansi-38-5-136   { color:            #af8700; }
   .ansi-38-5-137   { color:            #af875f; }
   .ansi-38-5-138   { color:            #af8787; }
   .ansi-38-5-139   { color:            #af87af; }
   .ansi-38-5-140   { color:            #af87d7; }
   .ansi-38-5-141   { color:            #af87ff; }
   .ansi-38-5-142   { color:            #afaf00; }
   .ansi-38-5-143   { color:            #afaf5f; }
   .ansi-38-5-144   { color:            #afaf87; }
   .ansi-38-5-145   { color:            #afafaf; }
   .ansi-38-5-146   { color:            #afafd7; }
   .ansi-38-5-147   { color:            #afafff; }
   .ansi-38-5-148   { color:            #afd700; }
   .ansi-38-5-149   { color:            #afd75f; }
   .ansi-38-5-150   { color:            #afd787; }
   .ansi-38-5-151   { color:            #afd7af; }
   .ansi-38-5-152   { color:            #afd7d7; }
   .ansi-38-5-153   { color:            #afd7ff; }
   .ansi-38-5-154   { color:            #afff00; }
   .ansi-38-5-155   { color:            #afff5f; }
   .ansi-38-5-156   { color:            #afff87; }
   .ansi-38-5-157   { color:            #afffaf; }
   .ansi-38-5-158   { color:            #afffd7; }
   .ansi-38-5-159   { color:            #afffff; }
   .ansi-38-5-160   { color:            #d70000; }
   .ansi-38-5-161   { color:            #d7005f; }
   .ansi-38-5-162   { color:            #d70087; }
   .ansi-38-5-163   { color:            #d700af; }
   .ansi-38-5-164   { color:            #d700d7; }
   .ansi-38-5-165   { color:            #d700ff; }
   .ansi-38-5-166   { color:            #d75f00; }
   .ansi-38-5-167   { color:            #d75f5f; }
   .ansi-38-5-168   { color:            #d75f87; }
   .ansi-38-5-169   { color:            #d75faf; }
   .ansi-38-5-170   { color:            #d75fd7; }
   .ansi-38-5-171   { color:            #d75fff; }
   .ansi-38-5-172   { color:            #d78700; }
   .ansi-38-5-173   { color:            #d7875f; }
   .ansi-38-5-174   { color:            #d78787; }
   .ansi-38-5-175   { color:            #d787af; }
   .ansi-38-5-176   { color:            #d787d7; }
   .ansi-38-5-177   { color:            #d787ff; }
   .ansi-38-5-178   { color:            #d7af00; }
   .ansi-38-5-179   { color:            #d7af5f; }
   .ansi-38-5-180   { color:            #d7af87; }
   .ansi-38-5-181   { color:            #d7afaf; }
   .ansi-38-5-182   { color:            #d7afd7; }
   .ansi-38-5-183   { color:            #d7afff; }
   .ansi-38-5-184   { color:            #d7d700; }
   .ansi-38-5-185   { color:            #d7d75f; }
   .ansi-38-5-186   { color:            #d7d787; }
   .ansi-38-5-187   { color:            #d7d7af; }
   .ansi-38-5-188   { color:            #d7d7d7; }
   .ansi-38-5-189   { color:            #d7d7ff; }
   .ansi-38-5-190   { color:            #d7ff00; }
   .ansi-38-5-191   { color:            #d7ff5f; }
   .ansi-38-5-192   { color:            #d7ff87; }
   .ansi-38-5-193   { color:            #d7ffaf; }
   .ansi-38-5-194   { color:            #d7ffd7; }
   .ansi-38-5-195   { color:            #d7ffff; }
   .ansi-38-5-196   { color:            #ff0000; }
   .ansi-38-5-197   { color:            #ff005f; }
   .ansi-38-5-198   { color:            #ff0087; }
   .ansi-38-5-199   { color:            #ff00af; }
   .ansi-38-5-200   { color:            #ff00d7; }
   .ansi-38-5-201   { color:            #ff00ff; }
   .ansi-38-5-202   { color:            #ff5f00; }
   .ansi-38-5-203   { color:            #ff5f5f; }
   .ansi-38-5-204   { color:            #ff5f87; }
   .ansi-38-5-205   { color:            #ff5faf; }
   .ansi-38-5-206   { color:            #ff5fd7; }
   .ansi-38-5-207   { color:            #ff5fff; }
   .ansi-38-5-208   { color:            #ff8700; }
   .ansi-38-5-209   { color:            #ff875f; }
   .ansi-38-5-210   { color:            #ff8787; }
   .ansi-38-5-211   { color:            #ff87af; }
   .ansi-38-5-212   { color:            #ff87d7; }
   .ansi-38-5-213   { color:            #ff87ff; }
   .ansi-38-5-214   { color:            #ffaf00; }
   .ansi-38-5-215   { color:            #ffaf5f; }
   .ansi-38-5-216   { color:            #ffaf87; }
   .ansi-38-5-217   { color:            #ffafaf; }
   .ansi-38-5-218   { color:            #ffafd7; }
   .ansi-38-5-219   { color:            #ffafff; }
   .ansi-38-5-220   { color:            #ffd700; }
   .ansi-38-5-221   { color:            #ffd75f; }
   .ansi-38-5-222   { color:            #ffd787; }
   .ansi-38-5-223   { color:            #ffd7af; }
   .ansi-38-5-224   { color:            #ffd7d7; }
   .ansi-38-5-225   { color:            #ffd7ff; }
   .ansi-38-5-226   { color:            #ffff00; }
   .ansi-38-5-227   { color:            #ffff5f; }
   .ansi-38-5-228   { color:            #ffff87; }
   .ansi-38-5-229   { color:            #ffffaf; }
   .ansi-38-5-230   { color:            #ffffd7; }
   .ansi-38-5-231   { color:            #ffffff; }
   .ansi-38-5-232   { color:            #080808; }
   .ansi-38-5-233   { color:            #121212; }
   .ansi-38-5-234   { color:            #1c1c1c; }
   .ansi-38-5-235   { color:            #262626; }
   .ansi-38-5-236   { color:            #303030; }
   .ansi-38-5-237   { color:            #3a3a3a; }
   .ansi-38-5-238   { color:            #444444; }
   .ansi-38-5-239   { color:            #4e4e4e; }
   .ansi-38-5-240   { color:            #585858; }
   .ansi-38-5-241   { color:            #626262; }
   .ansi-38-5-242   { color:            #6c6c6c; }
   .ansi-38-5-243   { color:            #767676; }
   .ansi-38-5-244   { color:            #808080; }
   .ansi-38-5-245   { color:            #8a8a8a; }
   .ansi-38-5-246   { color:            #949494; }
   .ansi-38-5-247   { color:            #9e9e9e; }
   .ansi-38-5-248   { color:            #a8a8a8; }
   .ansi-38-5-249   { color:            #b2b2b2; }
   .ansi-38-5-250   { color:            #bcbcbc; }
   .ansi-38-5-251   { color:            #c6c6c6; }
   .ansi-38-5-252   { color:            #d0d0d0; }
   .ansi-38-5-253   { color:            #dadada; }
   .ansi-38-5-254   { color:            #e4e4e4; }
   .ansi-38-5-255   { color:            #eeeeee; }
   
   /* SYSTEM colors */
   
   .ansi-48-5-0   { background-color: #000000; }
   .ansi-48-5-1   { background-color: #cd0000; }
   .ansi-48-5-2   { background-color: #00cd00; }
   .ansi-48-5-3   { background-color: #cdcd00; }
   .ansi-48-5-4   { background-color: #0000ee; }
   .ansi-48-5-5   { background-color: #cd00cd; }
   .ansi-48-5-6   { background-color: #00cdcd; }
   .ansi-48-5-7   { background-color: #e5e5e5; }
   .ansi-48-5-8   { background-color: #7f7f7f; }
   .ansi-48-5-9   { background-color: #ff0000; }
   .ansi-48-5-10  { background-color: #00ff00; }
   .ansi-48-5-11  { background-color: #e8e800; }
   .ansi-48-5-12  { background-color: #5c5cff; }
   .ansi-48-5-13  { background-color: #ff00ff; }
   .ansi-48-5-14  { background-color: #00ffff; }
   .ansi-48-5-15  { background-color: #ffffff; }
   
   /* XTERM colors - 256 color mode */
   .ansi-48-5-16  { background-color: #000000; }
   .ansi-48-5-17  { background-color: #00005f; }
   .ansi-48-5-18  { background-color: #000087; }
   .ansi-48-5-19  { background-color: #0000af; }
   .ansi-48-5-20  { background-color: #0000d7; }
   .ansi-48-5-21  { background-color: #0000ff; }
   .ansi-48-5-22  { background-color: #005f00; }
   .ansi-48-5-23  { background-color: #005f5f; }
   .ansi-48-5-24  { background-color: #005f87; }
   .ansi-48-5-25  { background-color: #005faf; }
   .ansi-48-5-26  { background-color: #005fd7; }
   .ansi-48-5-27  { background-color: #005fff; }
   .ansi-48-5-28  { background-color: #008700; }
   .ansi-48-5-29  { background-color: #00875f; }
   .ansi-48-5-30  { background-color: #008787; }
   .ansi-48-5-31  { background-color: #0087af; }
   .ansi-48-5-32  { background-color: #0087d7; }
   .ansi-48-5-33  { background-color: #0087ff; }
   .ansi-48-5-34  { background-color: #00af00; }
   .ansi-48-5-35  { background-color: #00af5f; }
   .ansi-48-5-36  { background-color: #00af87; }
   .ansi-48-5-37  { background-color: #00afaf; }
   .ansi-48-5-38  { background-color: #00afd7; }
   .ansi-48-5-39  { background-color: #00afff; }
   .ansi-48-5-40  { background-color: #00d700; }
   .ansi-48-5-41  { background-color: #00d75f; }
   .ansi-48-5-42  { background-color: #00d787; }
   .ansi-48-5-43  { background-color: #00d7af; }
   .ansi-48-5-44  { background-color: #00d7d7; }
   .ansi-48-5-45  { background-color: #00d7ff; }
   .ansi-48-5-46  { background-color: #00ff00; }
   .ansi-48-5-47  { background-color: #00ff5f; }
   .ansi-48-5-48  { background-color: #00ff87; }
   .ansi-48-5-49  { background-color: #00ffaf; }
   .ansi-48-5-50  { background-color: #00ffd7; }
   .ansi-48-5-51  { background-color: #00ffff; }
   .ansi-48-5-52  { background-color: #5f0000; }
   .ansi-48-5-53  { background-color: #5f005f; }
   .ansi-48-5-54  { background-color: #5f0087; }
   .ansi-48-5-55  { background-color: #5f00af; }
   .ansi-48-5-56  { background-color: #5f00d7; }
   .ansi-48-5-57  { background-color: #5f00ff; }
   .ansi-48-5-58  { background-color: #5f5f00; }
   .ansi-48-5-59  { background-color: #5f5f5f; }
   .ansi-48-5-60  { background-color: #5f5f87; }
   .ansi-48-5-61  { background-color: #5f5faf; }
   .ansi-48-5-62  { background-color: #5f5fd7; }
   .ansi-48-5-63  { background-color: #5f5fff; }
   .ansi-48-5-64  { background-color: #5f8700; }
   .ansi-48-5-65  { background-color: #5f875f; }
   .ansi-48-5-66  { background-color: #5f8787; }
   .ansi-48-5-67  { background-color: #5f87af; }
   .ansi-48-5-68  { background-color: #5f87d7; }
   .ansi-48-5-69  { background-color: #5f87ff; }
   .ansi-48-5-70  { background-color: #5faf00; }
   .ansi-48-5-71  { background-color: #5faf5f; }
   .ansi-48-5-72  { background-color: #5faf87; }
   .ansi-48-5-73  { background-color: #5fafaf; }
   .ansi-48-5-74  { background-color: #5fafd7; }
   .ansi-48-5-75  { background-color: #5fafff; }
   .ansi-48-5-76  { background-color: #5fd700; }
   .ansi-48-5-77  { background-color: #5fd75f; }
   .ansi-48-5-78  { background-color: #5fd787; }
   .ansi-48-5-79  { background-color: #5fd7af; }
   .ansi-48-5-80  { background-color: #5fd7d7; }
   .ansi-48-5-81  { background-color: #5fd7ff; }
   .ansi-48-5-82  { background-color: #5fff00; }
   .ansi-48-5-83  { background-color: #5fff5f; }
   .ansi-48-5-84  { background-color: #5fff87; }
   .ansi-48-5-85  { background-color: #5fffaf; }
   .ansi-48-5-86  { background-color: #5fffd7; }
   .ansi-48-5-87  { background-color: #5fffff; }
   .ansi-48-5-88  { background-color: #870000; }
   .ansi-48-5-89  { background-color: #87005f; }
   .ansi-48-5-90  { background-color: #870087; }
   .ansi-48-5-91  { background-color: #8700af; }
   .ansi-48-5-92  { background-color: #8700d7; }
   .ansi-48-5-93  { background-color: #8700ff; }
   .ansi-48-5-94  { background-color: #875f00; }
   .ansi-48-5-95  { background-color: #875f5f; }
   .ansi-48-5-96  { background-color: #875f87; }
   .ansi-48-5-97  { background-color: #875faf; }
   .ansi-48-5-98  { background-color: #875fd7; }
   .ansi-48-5-99  { background-color: #875fff; }
   .ansi-48-5-100 { background-color: #878700; }
   .ansi-48-5-101 { background-color: #87875f; }
   .ansi-48-5-102 { background-color: #878787; }
   .ansi-48-5-103 { background-color: #8787af; }
   .ansi-48-5-104 { background-color: #8787d7; }
   .ansi-48-5-105 { background-color: #8787ff; }
   .ansi-48-5-106 { background-color: #87af00; }
   .ansi-48-5-107 { background-color: #87af5f; }
   .ansi-48-5-108 { background-color: #87af87; }
   .ansi-48-5-109 { background-color: #87afaf; }
   .ansi-48-5-110 { background-color: #87afd7; }
   .ansi-48-5-111 { background-color: #87afff; }
   .ansi-48-5-112 { background-color: #87d700; }
   .ansi-48-5-113 { background-color: #87d75f; }
   .ansi-48-5-114 { background-color: #87d787; }
   .ansi-48-5-115 { background-color: #87d7af; }
   .ansi-48-5-116 { background-color: #87d7d7; }
   .ansi-48-5-117 { background-color: #87d7ff; }
   .ansi-48-5-118 { background-color: #87ff00; }
   .ansi-48-5-119 { background-color: #87ff5f; }
   .ansi-48-5-120 { background-color: #87ff87; }
   .ansi-48-5-121 { background-color: #87ffaf; }
   .ansi-48-5-122 { background-color: #87ffd7; }
   .ansi-48-5-123 { background-color: #87ffff; }
   .ansi-48-5-124 { background-color: #af0000; }
   .ansi-48-5-125 { background-color: #af005f; }
   .ansi-48-5-126 { background-color: #af0087; }
   .ansi-48-5-127 { background-color: #af00af; }
   .ansi-48-5-128 { background-color: #af00d7; }
   .ansi-48-5-129 { background-color: #af00ff; }
   .ansi-48-5-130 { background-color: #af5f00; }
   .ansi-48-5-131 { background-color: #af5f5f; }
   .ansi-48-5-132 { background-color: #af5f87; }
   .ansi-48-5-133 { background-color: #af5faf; }
   .ansi-48-5-134 { background-color: #af5fd7; }
   .ansi-48-5-135 { background-color: #af5fff; }
   .ansi-48-5-136 { background-color: #af8700; }
   .ansi-48-5-137 { background-color: #af875f; }
   .ansi-48-5-138 { background-color: #af8787; }
   .ansi-48-5-139 { background-color: #af87af; }
   .ansi-48-5-140 { background-color: #af87d7; }
   .ansi-48-5-141 { background-color: #af87ff; }
   .ansi-48-5-142 { background-color: #afaf00; }
   .ansi-48-5-143 { background-color: #afaf5f; }
   .ansi-48-5-144 { background-color: #afaf87; }
   .ansi-48-5-145 { background-color: #afafaf; }
   .ansi-48-5-146 { background-color: #afafd7; }
   .ansi-48-5-147 { background-color: #afafff; }
   .ansi-48-5-148 { background-color: #afd700; }
   .ansi-48-5-149 { background-color: #afd75f; }
   .ansi-48-5-150 { background-color: #afd787; }
   .ansi-48-5-151 { background-color: #afd7af; }
   .ansi-48-5-152 { background-color: #afd7d7; }
   .ansi-48-5-153 { background-color: #afd7ff; }
   .ansi-48-5-154 { background-color: #afff00; }
   .ansi-48-5-155 { background-color: #afff5f; }
   .ansi-48-5-156 { background-color: #afff87; }
   .ansi-48-5-157 { background-color: #afffaf; }
   .ansi-48-5-158 { background-color: #afffd7; }
   .ansi-48-5-159 { background-color: #afffff; }
   .ansi-48-5-160 { background-color: #d70000; }
   .ansi-48-5-161 { background-color: #d7005f; }
   .ansi-48-5-162 { background-color: #d70087; }
   .ansi-48-5-163 { background-color: #d700af; }
   .ansi-48-5-164 { background-color: #d700d7; }
   .ansi-48-5-165 { background-color: #d700ff; }
   .ansi-48-5-166 { background-color: #d75f00; }
   .ansi-48-5-167 { background-color: #d75f5f; }
   .ansi-48-5-168 { background-color: #d75f87; }
   .ansi-48-5-169 { background-color: #d75faf; }
   .ansi-48-5-170 { background-color: #d75fd7; }
   .ansi-48-5-171 { background-color: #d75fff; }
   .ansi-48-5-172 { background-color: #d78700; }
   .ansi-48-5-173 { background-color: #d7875f; }
   .ansi-48-5-174 { background-color: #d78787; }
   .ansi-48-5-175 { background-color: #d787af; }
   .ansi-48-5-176 { background-color: #d787d7; }
   .ansi-48-5-177 { background-color: #d787ff; }
   .ansi-48-5-178 { background-color: #d7af00; }
   .ansi-48-5-179 { background-color: #d7af5f; }
   .ansi-48-5-180 { background-color: #d7af87; }
   .ansi-48-5-181 { background-color: #d7afaf; }
   .ansi-48-5-182 { background-color: #d7afd7; }
   .ansi-48-5-183 { background-color: #d7afff; }
   .ansi-48-5-184 { background-color: #d7d700; }
   .ansi-48-5-185 { background-color: #d7d75f; }
   .ansi-48-5-186 { background-color: #d7d787; }
   .ansi-48-5-187 { background-color: #d7d7af; }
   .ansi-48-5-188 { background-color: #d7d7d7; }
   .ansi-48-5-189 { background-color: #d7d7ff; }
   .ansi-48-5-190 { background-color: #d7ff00; }
   .ansi-48-5-191 { background-color: #d7ff5f; }
   .ansi-48-5-192 { background-color: #d7ff87; }
   .ansi-48-5-193 { background-color: #d7ffaf; }
   .ansi-48-5-194 { background-color: #d7ffd7; }
   .ansi-48-5-195 { background-color: #d7ffff; }
   .ansi-48-5-196 { background-color: #ff0000; }
   .ansi-48-5-197 { background-color: #ff005f; }
   .ansi-48-5-198 { background-color: #ff0087; }
   .ansi-48-5-199 { background-color: #ff00af; }
   .ansi-48-5-200 { background-color: #ff00d7; }
   .ansi-48-5-201 { background-color: #ff00ff; }
   .ansi-48-5-202 { background-color: #ff5f00; }
   .ansi-48-5-203 { background-color: #ff5f5f; }
   .ansi-48-5-204 { background-color: #ff5f87; }
   .ansi-48-5-205 { background-color: #ff5faf; }
   .ansi-48-5-206 { background-color: #ff5fd7; }
   .ansi-48-5-207 { background-color: #ff5fff; }
   .ansi-48-5-208 { background-color: #ff8700; }
   .ansi-48-5-209 { background-color: #ff875f; }
   .ansi-48-5-210 { background-color: #ff8787; }
   .ansi-48-5-211 { background-color: #ff87af; }
   .ansi-48-5-212 { background-color: #ff87d7; }
   .ansi-48-5-213 { background-color: #ff87ff; }
   .ansi-48-5-214 { background-color: #ffaf00; }
   .ansi-48-5-215 { background-color: #ffaf5f; }
   .ansi-48-5-216 { background-color: #ffaf87; }
   .ansi-48-5-217 { background-color: #ffafaf; }
   .ansi-48-5-218 { background-color: #ffafd7; }
   .ansi-48-5-219 { background-color: #ffafff; }
   .ansi-48-5-220 { background-color: #ffd700; }
   .ansi-48-5-221 { background-color: #ffd75f; }
   .ansi-48-5-222 { background-color: #ffd787; }
   .ansi-48-5-223 { background-color: #ffd7af; }
   .ansi-48-5-224 { background-color: #ffd7d7; }
   .ansi-48-5-225 { background-color: #ffd7ff; }
   .ansi-48-5-226 { background-color: #ffff00; }
   .ansi-48-5-227 { background-color: #ffff5f; }
   .ansi-48-5-228 { background-color: #ffff87; }
   .ansi-48-5-229 { background-color: #ffffaf; }
   .ansi-48-5-230 { background-color: #ffffd7; }
   .ansi-48-5-231 { background-color: #ffffff; }
   .ansi-48-5-232 { background-color: #080808; }
   .ansi-48-5-233 { background-color: #121212; }
   .ansi-48-5-234 { background-color: #1c1c1c; }
   .ansi-48-5-235 { background-color: #262626; }
   .ansi-48-5-236 { background-color: #303030; }
   .ansi-48-5-237 { background-color: #3a3a3a; }
   .ansi-48-5-238 { background-color: #444444; }
   .ansi-48-5-239 { background-color: #4e4e4e; }
   .ansi-48-5-240 { background-color: #585858; }
   .ansi-48-5-241 { background-color: #626262; }
   .ansi-48-5-242 { background-color: #6c6c6c; }
   .ansi-48-5-243 { background-color: #767676; }
   .ansi-48-5-244 { background-color: #808080; }
   .ansi-48-5-245 { background-color: #8a8a8a; }
   .ansi-48-5-246 { background-color: #949494; }
   .ansi-48-5-247 { background-color: #9e9e9e; }
   .ansi-48-5-248 { background-color: #a8a8a8; }
   .ansi-48-5-249 { background-color: #b2b2b2; }
   .ansi-48-5-250 { background-color: #bcbcbc; }
   .ansi-48-5-251 { background-color: #c6c6c6; }
   .ansi-48-5-252 { background-color: #d0d0d0; }
   .ansi-48-5-253 { background-color: #dadada; }
   .ansi-48-5-254 { background-color: #e4e4e4; }
   .ansi-48-5-255 { background-color: #eeeeee; }

START: muddler_dark_ansi.css
   .ansi-4 { text-decoration: underline; }
   
   /* blinking text */
   .ansi-5 {
       -webkit-animation: blink .75s linear infinite;
       -moz-animation: blink .75s linear infinite;
       -ms-animation: blink .75s linear infinite;
       -o-animation: blink .75s linear infinite;
       animation: blink .75s linear infinite;
   }
   
   /* standard 16 foreground colors */
   .ansi-30 { color: black; }
   .ansi-1-30 { color: gray; }
   .ansi-31 { color: maroon; }
   .ansi-1-31 { color: red; }
   .ansi-32 { color: green; }
   .ansi-1-32 { color: lime; }
   .ansi-33 { color: olive; }
   .ansi-1-33 { color: yellow; }
   .ansi-34 { color: navy; }
   .ansi-1-34 { color: blue; }
   .ansi-35 { color: purple; }
   .ansi-1-35 { color: fuchsia; }
   .ansi-36 { color: teal; }
   .ansi-1-36 { color: aqua; }
   .ansi-37 { color: black; }
   .ansi-1-37 { color: white; }
   
   /* standard 16 background colors */
   .ansi-40 { background-color: black; }
   .ansi-1-40 { background-color: gray; }
   .ansi-41 { background-color: maroon; }
   .ansi-1-41 { background-color: red; }
   .ansi-42 { background-color: green; }
   .ansi-1-42 { background-color: lime; }
   .ansi-43 { background-color: olive; }
   .ansi-1-43 { background-color: yellow; }
   .ansi-44 { background-color: navy; }
   .ansi-1-44 { background-color: blue; }
   .ansi-45 { background-color: purple; }
   .ansi-1-45 { background-color: fuchsia; }
   .ansi-46 { background-color: teal; }
   .ansi-1-46 { background-color: aqua; }
   .ansi-47 { background-color: silver; }
   .ansi-1-47 { background-color: white; }
   
   /* xterm256 foreground colors */
   .ansi-38-5-0 { color: #000000; }
   .ansi-38-5-1 { color: #800000; }
   .ansi-38-5-2 { color: #008000; }
   .ansi-38-5-3 { color: #808000; }
   .ansi-38-5-4 { color: #000080; }
   .ansi-38-5-5 { color: #800080; }
   .ansi-38-5-6 { color: #008080; }
   .ansi-38-5-7 { color: #c0c0c0; }
   .ansi-38-5-8 { color: #808080; }
   .ansi-38-5-9 { color: #ff0000; }
   .ansi-38-5-10 { color: #00ff00; }
   .ansi-38-5-11 { color: #ffff00; }
   .ansi-38-5-12 { color: #0000ff; }
   .ansi-38-5-13 { color: #ff00ff; }
   .ansi-38-5-14 { color: #00ffff; }
   .ansi-38-5-15 { color: #ffffff; }
   .ansi-38-5-16 { color: #000000; }
   .ansi-38-5-17 { color: #00005f; }
   .ansi-38-5-18 { color: #000087; }
   .ansi-38-5-19 { color: #0000af; }
   .ansi-38-5-20 { color: #0000d7; }
   .ansi-38-5-21 { color: #0000ff; }
   .ansi-38-5-22 { color: #005f00; }
   .ansi-38-5-23 { color: #005f5f; }
   .ansi-38-5-24 { color: #005f87; }
   .ansi-38-5-25 { color: #005faf; }
   .ansi-38-5-26 { color: #005fd7; }
   .ansi-38-5-27 { color: #005fff; }
   .ansi-38-5-28 { color: #008700; }
   .ansi-38-5-29 { color: #00875f; }
   .ansi-38-5-30 { color: #008787; }
   .ansi-38-5-31 { color: #0087af; }
   .ansi-38-5-32 { color: #0087d7; }
   .ansi-38-5-33 { color: #0087ff; }
   .ansi-38-5-34 { color: #00af00; }
   .ansi-38-5-35 { color: #00af5f; }
   .ansi-38-5-36 { color: #00af87; }
   .ansi-38-5-37 { color: #00afaf; }
   .ansi-38-5-38 { color: #00afd7; }
   .ansi-38-5-39 { color: #00afff; }
   .ansi-38-5-40 { color: #00d700; }
   .ansi-38-5-41 { color: #00d75f; }
   .ansi-38-5-42 { color: #00d787; }
   .ansi-38-5-43 { color: #00d7af; }
   .ansi-38-5-44 { color: #00d7d7; }
   .ansi-38-5-45 { color: #00d7ff; }
   .ansi-38-5-46 { color: #00ff00; }
   .ansi-38-5-47 { color: #00ff5f; }
   .ansi-38-5-48 { color: #00ff87; }
   .ansi-38-5-49 { color: #00ffaf; }
   .ansi-38-5-50 { color: #00ffd7; }
   .ansi-38-5-51 { color: #00ffff; }
   .ansi-38-5-52 { color: #5f0000; }
   .ansi-38-5-53 { color: #5f005f; }
   .ansi-38-5-54 { color: #5f0087; }
   .ansi-38-5-55 { color: #5f00af; }
   .ansi-38-5-56 { color: #5f00d7; }
   .ansi-38-5-57 { color: #5f00ff; }
   .ansi-38-5-58 { color: #5f5f00; }
   .ansi-38-5-59 { color: #5f5f5f; }
   .ansi-38-5-60 { color: #5f5f87; }
   .ansi-38-5-61 { color: #5f5faf; }
   .ansi-38-5-62 { color: #5f5fd7; }
   .ansi-38-5-63 { color: #5f5fff; }
   .ansi-38-5-64 { color: #5f8700; }
   .ansi-38-5-65 { color: #5f875f; }
   .ansi-38-5-66 { color: #5f8787; }
   .ansi-38-5-67 { color: #5f87af; }
   .ansi-38-5-68 { color: #5f87d7; }
   .ansi-38-5-69 { color: #5f87ff; }
   .ansi-38-5-70 { color: #5faf00; }
   .ansi-38-5-71 { color: #5faf5f; }
   .ansi-38-5-72 { color: #5faf87; }
   .ansi-38-5-73 { color: #5fafaf; }
   .ansi-38-5-74 { color: #5fafd7; }
   .ansi-38-5-75 { color: #5fafff; }
   .ansi-38-5-76 { color: #5fd700; }
   .ansi-38-5-77 { color: #5fd75f; }
   .ansi-38-5-78 { color: #5fd787; }
   .ansi-38-5-79 { color: #5fd7af; }
   .ansi-38-5-80 { color: #5fd7d7; }
   .ansi-38-5-81 { color: #5fd7ff; }
   .ansi-38-5-82 { color: #5fff00; }
   .ansi-38-5-83 { color: #5fff5f; }
   .ansi-38-5-84 { color: #5fff87; }
   .ansi-38-5-85 { color: #5fffaf; }
   .ansi-38-5-86 { color: #5fffd7; }
   .ansi-38-5-87 { color: #5fffff; }
   .ansi-38-5-88 { color: #870000; }
   .ansi-38-5-89 { color: #87005f; }
   .ansi-38-5-90 { color: #870087; }
   .ansi-38-5-91 { color: #8700af; }
   .ansi-38-5-92 { color: #8700d7; }
   .ansi-38-5-93 { color: #8700ff; }
   .ansi-38-5-94 { color: #875f00; }
   .ansi-38-5-95 { color: #875f5f; }
   .ansi-38-5-96 { color: #875f87; }
   .ansi-38-5-97 { color: #875faf; }
   .ansi-38-5-98 { color: #875fd7; }
   .ansi-38-5-99 { color: #875fff; }
   .ansi-38-5-100 { color: #878700; }
   .ansi-38-5-101 { color: #87875f; }
   .ansi-38-5-102 { color: #878787; }
   .ansi-38-5-103 { color: #8787af; }
   .ansi-38-5-104 { color: #8787d7; }
   .ansi-38-5-105 { color: #8787ff; }
   .ansi-38-5-106 { color: #87af00; }
   .ansi-38-5-107 { color: #87af5f; }
   .ansi-38-5-108 { color: #87af87; }
   .ansi-38-5-109 { color: #87afaf; }
   .ansi-38-5-110 { color: #87afd7; }
   .ansi-38-5-111 { color: #87afff; }
   .ansi-38-5-112 { color: #87d700; }
   .ansi-38-5-113 { color: #87d75f; }
   .ansi-38-5-114 { color: #87d787; }
   .ansi-38-5-115 { color: #87d7af; }
   .ansi-38-5-116 { color: #87d7d7; }
   .ansi-38-5-117 { color: #87d7ff; }
   .ansi-38-5-118 { color: #87ff00; }
   .ansi-38-5-119 { color: #87ff5f; }
   .ansi-38-5-120 { color: #87ff87; }
   .ansi-38-5-121 { color: #87ffaf; }
   .ansi-38-5-122 { color: #87ffd7; }
   .ansi-38-5-123 { color: #87ffff; }
   .ansi-38-5-124 { color: #af0000; }
   .ansi-38-5-125 { color: #af005f; }
   .ansi-38-5-126 { color: #af0087; }
   .ansi-38-5-127 { color: #af00af; }
   .ansi-38-5-128 { color: #af00d7; }
   .ansi-38-5-129 { color: #af00ff; }
   .ansi-38-5-130 { color: #af5f00; }
   .ansi-38-5-131 { color: #af5f5f; }
   .ansi-38-5-132 { color: #af5f87; }
   .ansi-38-5-133 { color: #af5faf; }
   .ansi-38-5-134 { color: #af5fd7; }
   .ansi-38-5-135 { color: #af5fff; }
   .ansi-38-5-136 { color: #af8700; }
   .ansi-38-5-137 { color: #af875f; }
   .ansi-38-5-138 { color: #af8787; }
   .ansi-38-5-139 { color: #af87af; }
   .ansi-38-5-140 { color: #af87d7; }
   .ansi-38-5-141 { color: #af87ff; }
   .ansi-38-5-142 { color: #afaf00; }
   .ansi-38-5-143 { color: #afaf5f; }
   .ansi-38-5-144 { color: #afaf87; }
   .ansi-38-5-145 { color: #afafaf; }
   .ansi-38-5-146 { color: #afafd7; }
   .ansi-38-5-147 { color: #afafff; }
   .ansi-38-5-148 { color: #afd700; }
   .ansi-38-5-149 { color: #afd75f; }
   .ansi-38-5-150 { color: #afd787; }
   .ansi-38-5-151 { color: #afd7af; }
   .ansi-38-5-152 { color: #afd7d7; }
   .ansi-38-5-153 { color: #afd7ff; }
   .ansi-38-5-154 { color: #afff00; }
   .ansi-38-5-155 { color: #afff5f; }
   .ansi-38-5-156 { color: #afff87; }
   .ansi-38-5-157 { color: #afffaf; }
   .ansi-38-5-158 { color: #afffd7; }
   .ansi-38-5-159 { color: #afffff; }
   .ansi-38-5-160 { color: #d70000; }
   .ansi-38-5-161 { color: #d7005f; }
   .ansi-38-5-162 { color: #d70087; }
   .ansi-38-5-163 { color: #d700af; }
   .ansi-38-5-164 { color: #d700d7; }
   .ansi-38-5-165 { color: #d700ff; }
   .ansi-38-5-166 { color: #d75f00; }
   .ansi-38-5-167 { color: #d75f5f; }
   .ansi-38-5-168 { color: #d75f87; }
   .ansi-38-5-169 { color: #d75faf; }
   .ansi-38-5-170 { color: #d75fd7; }
   .ansi-38-5-171 { color: #d75fff; }
   .ansi-38-5-172 { color: #d78700; }
   .ansi-38-5-173 { color: #d7875f; }
   .ansi-38-5-174 { color: #d78787; }
   .ansi-38-5-175 { color: #d787af; }
   .ansi-38-5-176 { color: #d787d7; }
   .ansi-38-5-177 { color: #d787ff; }
   .ansi-38-5-178 { color: #d7af00; }
   .ansi-38-5-179 { color: #d7af5f; }
   .ansi-38-5-180 { color: #d7af87; }
   .ansi-38-5-181 { color: #d7afaf; }
   .ansi-38-5-182 { color: #d7afd7; }
   .ansi-38-5-183 { color: #d7afff; }
   .ansi-38-5-184 { color: #d7d700; }
   .ansi-38-5-185 { color: #d7d75f; }
   .ansi-38-5-186 { color: #d7d787; }
   .ansi-38-5-187 { color: #d7d7af; }
   .ansi-38-5-188 { color: #d7d7d7; }
   .ansi-38-5-189 { color: #d7d7ff; }
   .ansi-38-5-190 { color: #d7ff00; }
   .ansi-38-5-191 { color: #d7ff5f; }
   .ansi-38-5-192 { color: #d7ff87; }
   .ansi-38-5-193 { color: #d7ffaf; }
   .ansi-38-5-194 { color: #d7ffd7; }
   .ansi-38-5-195 { color: #d7ffff; }
   .ansi-38-5-196 { color: #ff0000; }
   .ansi-38-5-197 { color: #ff005f; }
   .ansi-38-5-198 { color: #ff0087; }
   .ansi-38-5-199 { color: #ff00af; }
   .ansi-38-5-200 { color: #ff00d7; }
   .ansi-38-5-201 { color: #ff00ff; }
   .ansi-38-5-202 { color: #ff5f00; }
   .ansi-38-5-203 { color: #ff5f5f; }
   .ansi-38-5-204 { color: #ff5f87; }
   .ansi-38-5-205 { color: #ff5faf; }
   .ansi-38-5-206 { color: #ff5fd7; }
   .ansi-38-5-207 { color: #ff5fff; }
   .ansi-38-5-208 { color: #ff8700; }
   .ansi-38-5-209 { color: #ff875f; }
   .ansi-38-5-210 { color: #ff8787; }
   .ansi-38-5-211 { color: #ff87af; }
   .ansi-38-5-212 { color: #ff87d7; }
   .ansi-38-5-213 { color: #ff87ff; }
   .ansi-38-5-214 { color: #ffaf00; }
   .ansi-38-5-215 { color: #ffaf5f; }
   .ansi-38-5-216 { color: #ffaf87; }
   .ansi-38-5-217 { color: #ffafaf; }
   .ansi-38-5-218 { color: #ffafd7; }
   .ansi-38-5-219 { color: #ffafff; }
   .ansi-38-5-220 { color: #ffd700; }
   .ansi-38-5-221 { color: #ffd75f; }
   .ansi-38-5-222 { color: #ffd787; }
   .ansi-38-5-223 { color: #ffd7af; }
   .ansi-38-5-224 { color: #ffd7d7; }
   .ansi-38-5-225 { color: #ffd7ff; }
   .ansi-38-5-226 { color: #ffff00; }
   .ansi-38-5-227 { color: #ffff5f; }
   .ansi-38-5-228 { color: #ffff87; }
   .ansi-38-5-229 { color: #ffffaf; }
   .ansi-38-5-230 { color: #ffffd7; }
   .ansi-38-5-231 { color: #ffffff; }
   .ansi-38-5-232 { color: #080808; }
   .ansi-38-5-233 { color: #121212; }
   .ansi-38-5-234 { color: #1c1c1c; }
   .ansi-38-5-235 { color: #262626; }
   .ansi-38-5-236 { color: #303030; }
   .ansi-38-5-237 { color: #3a3a3a; }
   .ansi-38-5-238 { color: #444444; }
   .ansi-38-5-239 { color: #4e4e4e; }
   .ansi-38-5-240 { color: #585858; }
   .ansi-38-5-241 { color: #626262; }
   .ansi-38-5-242 { color: #6c6c6c; }
   .ansi-38-5-243 { color: #767676; }
   .ansi-38-5-244 { color: #808080; }
   .ansi-38-5-245 { color: #8a8a8a; }
   .ansi-38-5-246 { color: #949494; }
   .ansi-38-5-247 { color: #9e9e9e; }
   .ansi-38-5-248 { color: #a8a8a8; }
   .ansi-38-5-249 { color: #b2b2b2; }
   .ansi-38-5-250 { color: #bcbcbc; }
   .ansi-38-5-251 { color: #c6c6c6; }
   .ansi-38-5-252 { color: #d0d0d0; }
   .ansi-38-5-253 { color: #dadada; }
   .ansi-38-5-254 { color: #e4e4e4; }
   .ansi-38-5-255 { color: #eeeeee; }
   
   /* xterm256 background colors */
   .ansi-48-5-0 { background-color: #000000; }
   .ansi-48-5-1 { background-color: #800000; }
   .ansi-48-5-2 { background-color: #008000; }
   .ansi-48-5-3 { background-color: #808000; }
   .ansi-48-5-4 { background-color: #000080; }
   .ansi-48-5-5 { background-color: #800080; }
   .ansi-48-5-6 { background-color: #008080; }
   .ansi-48-5-7 { background-color: #c0c0c0; }
   .ansi-48-5-8 { background-color: #808080; }
   .ansi-48-5-9 { background-color: #ff0000; }
   .ansi-48-5-10 { background-color: #00ff00; }
   .ansi-48-5-11 { background-color: #ffff00; }
   .ansi-48-5-12 { background-color: #0000ff; }
   .ansi-48-5-13 { background-color: #ff00ff; }
   .ansi-48-5-14 { background-color: #00ffff; }
   .ansi-48-5-15 { background-color: #ffffff; }
   .ansi-48-5-16 { background-color: #000000; }
   .ansi-48-5-17 { background-color: #00005f; }
   .ansi-48-5-18 { background-color: #000087; }
   .ansi-48-5-19 { background-color: #0000af; }
   .ansi-48-5-20 { background-color: #0000d7; }
   .ansi-48-5-21 { background-color: #0000ff; }
   .ansi-48-5-22 { background-color: #005f00; }
   .ansi-48-5-23 { background-color: #005f5f; }
   .ansi-48-5-24 { background-color: #005f87; }
   .ansi-48-5-25 { background-color: #005faf; }
   .ansi-48-5-26 { background-color: #005fd7; }
   .ansi-48-5-27 { background-color: #005fff; }
   .ansi-48-5-28 { background-color: #008700; }
   .ansi-48-5-29 { background-color: #00875f; }
   .ansi-48-5-30 { background-color: #008787; }
   .ansi-48-5-31 { background-color: #0087af; }
   .ansi-48-5-32 { background-color: #0087d7; }
   .ansi-48-5-33 { background-color: #0087ff; }
   .ansi-48-5-34 { background-color: #00af00; }
   .ansi-48-5-35 { background-color: #00af5f; }
   .ansi-48-5-36 { background-color: #00af87; }
   .ansi-48-5-37 { background-color: #00afaf; }
   .ansi-48-5-38 { background-color: #00afd7; }
   .ansi-48-5-39 { background-color: #00afff; }
   .ansi-48-5-40 { background-color: #00d700; }
   .ansi-48-5-41 { background-color: #00d75f; }
   .ansi-48-5-42 { background-color: #00d787; }
   .ansi-48-5-43 { background-color: #00d7af; }
   .ansi-48-5-44 { background-color: #00d7d7; }
   .ansi-48-5-45 { background-color: #00d7ff; }
   .ansi-48-5-46 { background-color: #00ff00; }
   .ansi-48-5-47 { background-color: #00ff5f; }
   .ansi-48-5-48 { background-color: #00ff87; }
   .ansi-48-5-49 { background-color: #00ffaf; }
   .ansi-48-5-50 { background-color: #00ffd7; }
   .ansi-48-5-51 { background-color: #00ffff; }
   .ansi-48-5-52 { background-color: #5f0000; }
   .ansi-48-5-53 { background-color: #5f005f; }
   .ansi-48-5-54 { background-color: #5f0087; }
   .ansi-48-5-55 { background-color: #5f00af; }
   .ansi-48-5-56 { background-color: #5f00d7; }
   .ansi-48-5-57 { background-color: #5f00ff; }
   .ansi-48-5-58 { background-color: #5f5f00; }
   .ansi-48-5-59 { background-color: #5f5f5f; }
   .ansi-48-5-60 { background-color: #5f5f87; }
   .ansi-48-5-61 { background-color: #5f5faf; }
   .ansi-48-5-62 { background-color: #5f5fd7; }
   .ansi-48-5-63 { background-color: #5f5fff; }
   .ansi-48-5-64 { background-color: #5f8700; }
   .ansi-48-5-65 { background-color: #5f875f; }
   .ansi-48-5-66 { background-color: #5f8787; }
   .ansi-48-5-67 { background-color: #5f87af; }
   .ansi-48-5-68 { background-color: #5f87d7; }
   .ansi-48-5-69 { background-color: #5f87ff; }
   .ansi-48-5-70 { background-color: #5faf00; }
   .ansi-48-5-71 { background-color: #5faf5f; }
   .ansi-48-5-72 { background-color: #5faf87; }
   .ansi-48-5-73 { background-color: #5fafaf; }
   .ansi-48-5-74 { background-color: #5fafd7; }
   .ansi-48-5-75 { background-color: #5fafff; }
   .ansi-48-5-76 { background-color: #5fd700; }
   .ansi-48-5-77 { background-color: #5fd75f; }
   .ansi-48-5-78 { background-color: #5fd787; }
   .ansi-48-5-79 { background-color: #5fd7af; }
   .ansi-48-5-80 { background-color: #5fd7d7; }
   .ansi-48-5-81 { background-color: #5fd7ff; }
   .ansi-48-5-82 { background-color: #5fff00; }
   .ansi-48-5-83 { background-color: #5fff5f; }
   .ansi-48-5-84 { background-color: #5fff87; }
   .ansi-48-5-85 { background-color: #5fffaf; }
   .ansi-48-5-86 { background-color: #5fffd7; }
   .ansi-48-5-87 { background-color: #5fffff; }
   .ansi-48-5-88 { background-color: #870000; }
   .ansi-48-5-89 { background-color: #87005f; }
   .ansi-48-5-90 { background-color: #870087; }
   .ansi-48-5-91 { background-color: #8700af; }
   .ansi-48-5-92 { background-color: #8700d7; }
   .ansi-48-5-93 { background-color: #8700ff; }
   .ansi-48-5-94 { background-color: #875f00; }
   .ansi-48-5-95 { background-color: #875f5f; }
   .ansi-48-5-96 { background-color: #875f87; }
   .ansi-48-5-97 { background-color: #875faf; }
   .ansi-48-5-98 { background-color: #875fd7; }
   .ansi-48-5-99 { background-color: #875fff; }
   .ansi-48-5-100 { background-color: #878700; }
   .ansi-48-5-101 { background-color: #87875f; }
   .ansi-48-5-102 { background-color: #878787; }
   .ansi-48-5-103 { background-color: #8787af; }
   .ansi-48-5-104 { background-color: #8787d7; }
   .ansi-48-5-105 { background-color: #8787ff; }
   .ansi-48-5-106 { background-color: #87af00; }
   .ansi-48-5-107 { background-color: #87af5f; }
   .ansi-48-5-108 { background-color: #87af87; }
   .ansi-48-5-109 { background-color: #87afaf; }
   .ansi-48-5-110 { background-color: #87afd7; }
   .ansi-48-5-111 { background-color: #87afff; }
   .ansi-48-5-112 { background-color: #87d700; }
   .ansi-48-5-113 { background-color: #87d75f; }
   .ansi-48-5-114 { background-color: #87d787; }
   .ansi-48-5-115 { background-color: #87d7af; }
   .ansi-48-5-116 { background-color: #87d7d7; }
   .ansi-48-5-117 { background-color: #87d7ff; }
   .ansi-48-5-118 { background-color: #87ff00; }
   .ansi-48-5-119 { background-color: #87ff5f; }
   .ansi-48-5-120 { background-color: #87ff87; }
   .ansi-48-5-121 { background-color: #87ffaf; }
   .ansi-48-5-122 { background-color: #87ffd7; }
   .ansi-48-5-123 { background-color: #87ffff; }
   .ansi-48-5-124 { background-color: #af0000; }
   .ansi-48-5-125 { background-color: #af005f; }
   .ansi-48-5-126 { background-color: #af0087; }
   .ansi-48-5-127 { background-color: #af00af; }
   .ansi-48-5-128 { background-color: #af00d7; }
   .ansi-48-5-129 { background-color: #af00ff; }
   .ansi-48-5-130 { background-color: #af5f00; }
   .ansi-48-5-131 { background-color: #af5f5f; }
   .ansi-48-5-132 { background-color: #af5f87; }
   .ansi-48-5-133 { background-color: #af5faf; }
   .ansi-48-5-134 { background-color: #af5fd7; }
   .ansi-48-5-135 { background-color: #af5fff; }
   .ansi-48-5-136 { background-color: #af8700; }
   .ansi-48-5-137 { background-color: #af875f; }
   .ansi-48-5-138 { background-color: #af8787; }
   .ansi-48-5-139 { background-color: #af87af; }
   .ansi-48-5-140 { background-color: #af87d7; }
   .ansi-48-5-141 { background-color: #af87ff; }
   .ansi-48-5-142 { background-color: #afaf00; }
   .ansi-48-5-143 { background-color: #afaf5f; }
   .ansi-48-5-144 { background-color: #afaf87; }
   .ansi-48-5-145 { background-color: #afafaf; }
   .ansi-48-5-146 { background-color: #afafd7; }
   .ansi-48-5-147 { background-color: #afafff; }
   .ansi-48-5-148 { background-color: #afd700; }
   .ansi-48-5-149 { background-color: #afd75f; }
   .ansi-48-5-150 { background-color: #afd787; }
   .ansi-48-5-151 { background-color: #afd7af; }
   .ansi-48-5-152 { background-color: #afd7d7; }
   .ansi-48-5-153 { background-color: #afd7ff; }
   .ansi-48-5-154 { background-color: #afff00; }
   .ansi-48-5-155 { background-color: #afff5f; }
   .ansi-48-5-156 { background-color: #afff87; }
   .ansi-48-5-157 { background-color: #afffaf; }
   .ansi-48-5-158 { background-color: #afffd7; }
   .ansi-48-5-159 { background-color: #afffff; }
   .ansi-48-5-160 { background-color: #d70000; }
   .ansi-48-5-161 { background-color: #d7005f; }
   .ansi-48-5-162 { background-color: #d70087; }
   .ansi-48-5-163 { background-color: #d700af; }
   .ansi-48-5-164 { background-color: #d700d7; }
   .ansi-48-5-165 { background-color: #d700ff; }
   .ansi-48-5-166 { background-color: #d75f00; }
   .ansi-48-5-167 { background-color: #d75f5f; }
   .ansi-48-5-168 { background-color: #d75f87; }
   .ansi-48-5-169 { background-color: #d75faf; }
   .ansi-48-5-170 { background-color: #d75fd7; }
   .ansi-48-5-171 { background-color: #d75fff; }
   .ansi-48-5-172 { background-color: #d78700; }
   .ansi-48-5-173 { background-color: #d7875f; }
   .ansi-48-5-174 { background-color: #d78787; }
   .ansi-48-5-175 { background-color: #d787af; }
   .ansi-48-5-176 { background-color: #d787d7; }
   .ansi-48-5-177 { background-color: #d787ff; }
   .ansi-48-5-178 { background-color: #d7af00; }
   .ansi-48-5-179 { background-color: #d7af5f; }
   .ansi-48-5-180 { background-color: #d7af87; }
   .ansi-48-5-181 { background-color: #d7afaf; }
   .ansi-48-5-182 { background-color: #d7afd7; }
   .ansi-48-5-183 { background-color: #d7afff; }
   .ansi-48-5-184 { background-color: #d7d700; }
   .ansi-48-5-185 { background-color: #d7d75f; }
   .ansi-48-5-186 { background-color: #d7d787; }
   .ansi-48-5-187 { background-color: #d7d7af; }
   .ansi-48-5-188 { background-color: #d7d7d7; }
   .ansi-48-5-189 { background-color: #d7d7ff; }
   .ansi-48-5-190 { background-color: #d7ff00; }
   .ansi-48-5-191 { background-color: #d7ff5f; }
   .ansi-48-5-192 { background-color: #d7ff87; }
   .ansi-48-5-193 { background-color: #d7ffaf; }
   .ansi-48-5-194 { background-color: #d7ffd7; }
   .ansi-48-5-195 { background-color: #d7ffff; }
   .ansi-48-5-196 { background-color: #ff0000; }
   .ansi-48-5-197 { background-color: #ff005f; }
   .ansi-48-5-198 { background-color: #ff0087; }
   .ansi-48-5-199 { background-color: #ff00af; }
   .ansi-48-5-200 { background-color: #ff00d7; }
   .ansi-48-5-201 { background-color: #ff00ff; }
   .ansi-48-5-202 { background-color: #ff5f00; }
   .ansi-48-5-203 { background-color: #ff5f5f; }
   .ansi-48-5-204 { background-color: #ff5f87; }
   .ansi-48-5-205 { background-color: #ff5faf; }
   .ansi-48-5-206 { background-color: #ff5fd7; }
   .ansi-48-5-207 { background-color: #ff5fff; }
   .ansi-48-5-208 { background-color: #ff8700; }
   .ansi-48-5-209 { background-color: #ff875f; }
   .ansi-48-5-210 { background-color: #ff8787; }
   .ansi-48-5-211 { background-color: #ff87af; }
   .ansi-48-5-212 { background-color: #ff87d7; }
   .ansi-48-5-213 { background-color: #ff87ff; }
   .ansi-48-5-214 { background-color: #ffaf00; }
   .ansi-48-5-215 { background-color: #ffaf5f; }
   .ansi-48-5-216 { background-color: #ffaf87; }
   .ansi-48-5-217 { background-color: #ffafaf; }
   .ansi-48-5-218 { background-color: #ffafd7; }
   .ansi-48-5-219 { background-color: #ffafff; }
   .ansi-48-5-220 { background-color: #ffd700; }
   .ansi-48-5-221 { background-color: #ffd75f; }
   .ansi-48-5-222 { background-color: #ffd787; }
   .ansi-48-5-223 { background-color: #ffd7af; }
   .ansi-48-5-224 { background-color: #ffd7d7; }
   .ansi-48-5-225 { background-color: #ffd7ff; }
   .ansi-48-5-226 { background-color: #ffff00; }
   .ansi-48-5-227 { background-color: #ffff5f; }
   .ansi-48-5-228 { background-color: #ffff87; }
   .ansi-48-5-229 { background-color: #ffffaf; }
   .ansi-48-5-230 { background-color: #ffffd7; }
   .ansi-48-5-231 { background-color: #ffffff; }
   .ansi-48-5-232 { background-color: #080808; }
   .ansi-48-5-233 { background-color: #121212; }
   .ansi-48-5-234 { background-color: #1c1c1c; }
   .ansi-48-5-235 { background-color: #262626; }
   .ansi-48-5-236 { background-color: #303030; }
   .ansi-48-5-237 { background-color: #3a3a3a; }
   .ansi-48-5-248 { background-color: #444444; }
   .ansi-48-5-239 { background-color: #4e4e4e; }
   .ansi-48-5-240 { background-color: #585858; }
   .ansi-48-5-241 { background-color: #626262; }
   .ansi-48-5-242 { background-color: #6c6c6c; }
   .ansi-48-5-243 { background-color: #767676; }
   .ansi-48-5-244 { background-color: #808080; }
   .ansi-48-5-245 { background-color: #8a8a8a; }
   .ansi-48-5-246 { background-color: #949494; }
   .ansi-48-5-247 { background-color: #9e9e9e; }
   .ansi-48-5-248 { background-color: #a8a8a8; }
   .ansi-48-5-249 { background-color: #b2b2b2; }
   .ansi-48-5-250 { background-color: #bcbcbc; }
   .ansi-48-5-251 { background-color: #c6c6c6; }
   .ansi-48-5-252 { background-color: #d0d0d0; }
   .ansi-48-5-253 { background-color: #dadada; }
   .ansi-48-5-254 { background-color: #e4e4e4; }
   .ansi-48-5-255 { background-color: #eeeeee; }
__ANSI__

START: muddler_style.css
   html, body {
     left: 0px;
     right: 0px;
     bottom: 0px;
     top: 0px;
     position: absolute;
/*     width: 100%;
     height: 100%; */
     margin: 0;
     overflow: hidden;
     background: #2667bd;
   /*     font-family: 'Courier New', monospace; */
   /*     font-family: 'termnine',Monospace; */
     font-family: Monospace;
     font-size: 11pt;
     font-weight: normal;
   }
   
   a {
     display: inline;
     text-decoration: none;
     border-bottom: 1px solid blue;
   }
   
   a:hover {
     cursor: pointer;
   }
   
   textarea {
     font-family: inherit;
     font-size: inherit;
   }
   
   ul {
     display: flex;
     flex-direction: column;
     list-style-type: none;
     margin: 0;
     padding: 0;
   }
   
   .localEcho {
     color: blue;
     font-weight: bold;
   }
   
   .logMessage {
     color: red;
     font-weight: bold;
   }
   
   #terminal {
     position: fixed;
     margin: 0;
     padding: 0;
     border: none;
     background: white;
     left: 0px;
     right: 0px;
     top: 0px;
     bottom: 0px;
     box-shadow: 0 0 0.2em 0.1em gray;
     overflow: hidden;
     /* display: none; */
   }
   
   #output {
     overflow: hidden;
     white-space: pre-wrap;
     word-wrap: break-word;
     position: absolute;
     margin: 0;
     border: 0;
     padding: 0.0em 0.0% 0.0em 0.0%;
     left: 0;
     width: 99%;
     top: 0;
     bottom: 71px; /* 6em */
     line-height: 110%;
#     word-spacing: 20;
     background: white; 
     font-size: 10pt;
   }
   
   #bar {
     padding: 0.0em 0.0% 0.0em 0.0%;
     white-space: pre-wrap;
     color: red;
     font-weight: bold;
     display: table-cell;
     overflow: hidden;
     position: absolute;
     left: 0;
     width: 100%;
     bottom: 50px;
     height: 1.4em;
     vertical-align: middle;
     text-align: left;
     border-bottom: 1px solid black;
   }
   
   #bartime {
     padding: 0.0em 0.0% 0.0em 0.0%;
     white-space: pre-wrap;
     color: red;
     font-weight: bold;
     display: table-cell;
     overflow: hidden;
     position: absolute;
     left: 0;
     width: 100%;
     bottom: 50px; /* 4em */
     height: 1.4em;
     vertical-align: middle;
     text-align: right;
   }

   #prompt {
     overflow: hidden;
     white-space: pre-wrap;
     text-align: left;
     position: absolute;
     margin: 0;
     left: 0;
     width: 100%;
     bottom: 4em;
     height: 1em;
   }
   
   #input {
     position: absolute;
     margin: 0;
     background: white;
     color: black;
     border: none;
     outline: none;
     vertical-align: middle;
     padding: 0.1em 0.1% 0.1em 0.1%;
     resize: none;
     left: 0;
     width: 99%;
     bottom: 0;
     height: 3em;
   }
   #buttonbar {
     position: absolute; 
     bottom: 5px;
     left: 0;
     right: 0;
     height: 30px;
     display: none;
/*     position: absolute;
     margin: 0;
     background: white;
     color: black;
     border: none;
     outline: none;
     vertical-align: middle;
     padding: 0px 0px 0px 0px;
     resize: none;
     left: 0;
     width: 100%;
     bottom: 0;
     height: 30px;
     float: left;
     position: absolute; */
#     display: none;
   }

   .triangle {
       border: 2px solid gray;
       position: absolute;
       height: 100px;
       width: 100px;
       z-index: 2; 
   }
   
   .inner-triangle {
      width: 0;
      height: 0;
      border-top: 70px solid #ffcc00;
      border-bottom: 70px solid transparent;
      border-left: 70px solid transparent;
      position:absolute;
      right:0;
      z-index: 2; 
   }

   .inner-triangle span {
      position:absolute;
      top: -50px;
      width: 70px;
      left: -60px;
      text-align: center;
      transform: rotate(45deg);
      display: block;
      z-index: 10;
   }

START: muddler_client.js
   //////////////////////////////////////////////////////////////////
   // WebSockClient for PennMUSH
   // There is no license. Just make a neato game with it.
   //////////////////////////////////////////////////////////////////
   

   // tell the actual client that the window is no longer focused
   function window_blurred() {
       input.onEnter('/blurred')
   }

   // tell the actual client that the window is focused
   function window_focused() {
       input.onEnter('/focused')
   }

   window.addEventListener('blur', window_blurred);
   window.addEventListener('focus', window_focused);
   var WSClient = (function (window, document, undefined) {
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // MU* protocol carried over the WebSocket API.


     function displaywheel(e){
         var evt=window.event || e //equalize event object
         var delta=evt.detail? evt.detail*(-500) : evt.wheelDelta 
         //check for detail first so Opera uses that instead of wheelDelta
         window.console.log(delta);
         if(delta < 0) {
             input.onEnter('/key_pgdn 5')
         } else {
             input.onEnter('/key_pgup 5');
         }
     }
 
     var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x
 
     if (document.attachEvent) //if IE (and Opera depending on user setting)
         document.attachEvent("on"+mousewheelevt, displaywheel)
     else if (document.addEventListener) //WC3 browsers
         document.addEventListener(mousewheelevt, displaywheel, false)

      var t

      window.onresize = () => {
          clearTimeout(t); 
          t = setTimeout(() => { t = undefined; resEnded() }, 500);
      }
      
      function resEnded() { 
          input.onEnter('/web_size ' + get_xy_size() + '\r\n' );
      }

      function get_xy_size() {
         var out = document.getElementById('output')
         var css = getComputedStyle(out,null);
         var ff  = css.getPropertyValue("font-family");
         var fs  = css.getPropertyValue("font-size");
         var temp = document.createElement('span');

         temp.style = "margin:0px;padding:0px;font-family:"+ff+
                      ";font-size:" + fs;

         temp.innerText = "0123456789";
         var element = document.body.appendChild(temp);
         var x = Math.round(out.offsetHeight / (temp.offsetHeight-2));
         var y = Math.round(out.offsetWidth / (temp.offsetWidth / 10));
         temp.parentNode.removeChild(temp);
         return x + "," + y + "," + fs + "-" + ff + "=2";
     }
   
     function Connection(url) {
       var that = this;
       
       this.url = url;
       this.socket = null;
       this.isOpen = false;
       
       Connection.reconnect(that);
     }
     
     Connection.CHANNEL_TEXT   = 't';
     Connection.CHANNEL_BAR    = 'b';
     Connection.CHANNEL_BARTIME= '*';
     Connection.CHANNEL_JSON   = 'j';
     Connection.CHANNEL_HTML   = 'h';
     Connection.CHANNEL_PUEBLO = 'p';
     Connection.CHANNEL_PROMPT = '>';
     Connection.CHANNEL_DO     = 'd';
   
     Connection.reconnect = function (that) {
       that.reconnect();
     };
     
     Connection.onopen = function (that, evt) {
       that.isOpen = true;
       that.onOpen && that.onOpen(evt);
     };
   
     Connection.onerror = function (that, evt) {
       that.isOpen = false;
       that.onError && that.onError(evt);
     };
   
     Connection.onclose = function (that, evt) {
       that.isOpen = false;
       that.onClose && that.onClose(evt);
     };
   
     Connection.onmessage = function (that, evt) {
       that.onMessage && that.onMessage(evt.data[0], evt.data.substring(1));
     };
   
     Connection.prototype.reconnect = function () {
       var that = this;
       
       // quit the old connection, if we have one
       if (this.isConnected()) {
         var old = this.socket;
         this.isOpen && setTimeout(old.close, 1000);
       }
   
       console.log('URL: ' + this.url);
       this.socket = new window.WebSocket(this.url);
       this.isOpen = false;
   
       this.socket.onopen = function (evt) {
         Connection.onopen(that, evt);
       };
   
       this.socket.onerror = function (evt) {
         Connection.onerror(that, evt);
       };
   
       this.socket.onclose = function (evt) {
         Connection.onclose(that, evt);
       };
   
       this.socket.onmessage = function (evt) {
         Connection.onmessage(that, evt);
       };
     };
     
     Connection.prototype.isConnected = function() {
       return (this.socket && this.isOpen && (this.socket.readyState === 1));
     };
   
     Connection.prototype.close = function () {
       this.socket && this.socket.close();
     };
   
     Connection.prototype.sendText = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_TEXT + data + '\r\n');
     };
   
     Connection.prototype.sendBar = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_BAR + data + '\r\n');
     };
   
     Connection.prototype.sendObject = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_JSON + window.JSON.stringify(data));
     };
   
     Connection.prototype.onOpen = null;
     Connection.prototype.onError = null;
     Connection.prototype.onClose = null;
   
     Connection.prototype.onMessage = function (channel, data) {
       switch (channel) {
       case Connection.CHANNEL_TEXT:
         this.onText && this.onText(data);
         break;
   
       case Connection.CHANNEL_BAR:
         this.onBar && this.onBar(data);
         break;

       case Connection.CHANNEL_BARTIME:
         this.onBarTime && this.onBarTime(data);
         break;
   
       case Connection.CHANNEL_JSON:
         this.onObject && this.onObject(window.JSON.parse(data));
         break;
   
       case Connection.CHANNEL_HTML:
         this.onHTML && this.onHTML(data);
         break;
   
       case Connection.CHANNEL_PUEBLO:
         this.onPueblo && this.onPueblo(data);
         break;
       
       case Connection.CHANNEL_PROMPT:
         this.onPrompt && this.onPrompt(data);
         break;
  
       case Connection.CHANNEL_DO:
           data = data.replace(/[\r\n]+/g, '').trim();

           // console.log("request: " + data);

           if(data === "mobile on") {
              document.querySelector('#bar').style.bottom = "52px";
              document.querySelector('#bartime').style.bottom = "52px";
              var obj = document.getElementById("output");
              document.querySelector('#terminal').style.bottom = "30px";
              document.querySelector('#buttonbar').style.display = 
                  "inline-block";
              document.querySelector('#output').style.fontSize = "8pt";
              document.querySelector('#output').style.bottom = "74px";
              obj.style.fontSize = "8pt";
              obj.scrollTop = obj.scrollHeight;
              document.querySelector('#input').style.bottom = '4px';
              sendCommand('/web_size ' + get_xy_size("8pt") + '\r\n');
           } else if(data === "mobile off") {
              var obj = document.getElementById("output");
              document.querySelector('#terminal').style.bottom = 0;
              document.querySelector('#buttonbar').style.display = "none";
              document.querySelector('#output').style.fontSize = "10pt";
//              obj.style.fontSize = "10pt";
              obj.scrollTop = obj.scrollHeight;

              document.querySelector('#bar').style.bottom = "50px";
              document.querySelector('#bartime').style.bottom = "50px";
              document.querySelector('#terminal').style.bottom = "0px";
              document.querySelector('#output').style.bottom = "71px";
              document.querySelector('#input').style.bottom = '0px';

              sendCommand('/web_size ' + get_xy_size("10pt") + '\r\n');
           } else if(data === "theme light") {
              document.querySelector('.ansi-37').style.color='black';
              document.getElementById('output').style.backgroundColor='white';
              document.getElementById('bar').style.backgroundColor='white';
              document.getElementById('input').style.backgroundColor = 'white';
              document.querySelector('#bar').style.borderBottom =
                  '1px solid black';
              document.querySelector('#terminal').style.background = 'white';
              document.querySelector('#input').style.color= 'black';
           } else if(data === "theme dark") {
              document.getElementById('output').style.backgroundColor=
                 '#131712';
              document.getElementById('bar').style.backgroundColor = '#131712';
              document.getElementById('input').style.backgroundColor='#131712';
              document.querySelector('#terminal').style.background = '#131712';
              document.querySelector('#bar').style.borderBottom=
                 '1px solid white';
              document.querySelector('.ansi-37').style.color  = 'white';
              document.querySelector('#input').style.color= 'white';
           } else if(data === "clear") {
              document.getElementById('output').innerHTML = ""
           } else if(data === "password") {
              sendCommand(window.prompt("Enter password","password"));
           } else {
              console.log("unknown do request: " + data);
           }
           break;
   
       default:
         window.console && window.console.log('unhandled message', data);
         return false;
       }
   
       return true;
     };
   
     Connection.prototype.onText = null;
     Connection.prototype.onClear = null;
     Connection.prototype.onBar = null;
     Connection.prototype.onBarTime = null;
     Connection.prototype.onObject = null;
     Connection.prototype.onHTML = null;
     Connection.prototype.onPueblo = null;
     Connection.prototype.onPrompt = null;
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // MU* terminal emulator.
     function Terminal(root) {
       this.root = root;
       
       if (root === null) {
         return null;
       }
       
       this.clear();
     }
   
     Terminal.PARSE_PLAIN = 0;
     Terminal.PARSE_CR = 1;
     Terminal.PARSE_ESC1 = 2;
     Terminal.PARSE_ESC2 = 3;
   
     Terminal.ANSI_NORMAL = 0;
     Terminal.ANSI_BRIGHT = 1;
     Terminal.ANSI_UNDERLINE = 4;
     Terminal.ANSI_BLINK = 5;
     Terminal.ANSI_INVERSE = 7;
     Terminal.ANSI_XTERM_FG = 38;
     Terminal.ANSI_XTERM_BG = 48;
   
     Terminal.DEFAULT_FG = 37;
     Terminal.DEFAULT_BG = 30;
     
     Terminal.UNCLOSED_TAGS = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',
             'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];
   
   
     /////////////////////////////////////////////////////
     // ansi parsing routines
     
     Terminal.encodeState = function (state) {
       if (!state) {
         return '';
       }
   
       var classes = [];
   
       if (state[Terminal.ANSI_INVERSE]) {
         var value = state.fg;
         state.fg = state.bg;
         state.bg = value;
         
         value = state.fg256;
         state.fg256 = state.bg256;
         state.bg256 = value;
       }
       
       var fg = state.fg;
       var bg = state.bg;
       
       if (state[Terminal.ANSI_UNDERLINE]) {
         classes[classes.length] = 'ansi-' + Terminal.ANSI_UNDERLINE;
       }
   
       // make sure to avoid conflict with XTERM256 color's usage of blink (code 5)
       if (state.fg256) {
         classes[classes.length] = 'ansi-38-5-' + state.fg;
       } else {  
         if (state[Terminal.ANSI_BRIGHT]) {
           if (state[Terminal.ANSI_INVERSE]) {
             if (fg !== Terminal.DEFAULT_FG) {
               classes[classes.length] = 'ansi-' + fg;
             }
           } else {
             classes[classes.length] = 'ansi-1-' + fg;
           }
         } else if (fg !== Terminal.DEFAULT_FG) {
           classes[classes.length] = 'ansi-' + fg;
         }
       }
       
       if (state.bg256) {
         classes[classes.length] = 'ansi-48-5-' + state.bg;
       } else {
         if (state[Terminal.ANSI_BRIGHT]) {
           if (state[Terminal.ANSI_INVERSE]) {
             classes[classes.length] = 'ansi-1-' + (bg + 10);
           } else {
             if (bg !== Terminal.DEFAULT_BG) {
               classes[classes.length] = 'ansi-' + (bg + 10);
             }
           }
         } else if (bg !== Terminal.DEFAULT_BG) {
           classes[classes.length] = 'ansi-' + (bg + 10);
         }
       }
   
       if (state[Terminal.ANSI_BLINK] && !(state.fg256 || state.bg256)) {
         classes[classes.length] = 'ansi-' + Terminal.ANSI_BLINK;
       }
       
       return classes.join(' ');
     };
   
     Terminal.prototype.getANSI = function () {
       if (!this.ansiState) {
         this.ansiState = {
           fg: Terminal.DEFAULT_FG,
           bg: Terminal.DEFAULT_BG,
           fg256: false,
           bg256: false
         };
       }
   
       return this.ansiState;
     };
   
     Terminal.prototype.applyANSI = function (ansi) {
       switch (ansi.charCodeAt(ansi.length - 1)) {
       case 109: // m (SGR)
         var codes = ansi.substring(0, ansi.length - 1).split(';');
   
         var value, state;
         for (var ii = 0; (value = codes[ii]) !== undefined; ++ii) {
           if (value.length === 0) {
             // Empty is treated as the equivalent of 0.
             value = Terminal.ANSI_NORMAL;
           } else {
             value = parseInt(value);
           }
           
           state = this.getANSI();
           
           // check for xterm256 fg/bg first, fallback to standard codes otherwise
           if (state[Terminal.ANSI_XTERM_FG] && state[Terminal.ANSI_BLINK]) {
             if (value >= 0 && value <= 255) {
               state.fg = value;
               state.fg256 = true;
               state[Terminal.ANSI_XTERM_FG] = false;
               state[Terminal.ANSI_BLINK] = false;
             } else {
               // invalid xterm256, let's reset the ansi state due to bad codes
               this.ansiState = null;
             }
           } else if (state[Terminal.ANSI_XTERM_BG] && state[Terminal.ANSI_BLINK]) {
             if (value >= 0 && value <= 255) {
               state.bg = value;
               state.bg256 = true;
               state[Terminal.ANSI_XTERM_BG] = false;
               state[Terminal.ANSI_BLINK] = false;
             } else {
               // invalid xterm256, let's reset the ansi state due to bad codes
               this.ansiState = null;
             }
           } else {
             // detect regular ansi codes
             switch (value) {
             case Terminal.ANSI_NORMAL: // reset
               this.ansiState = null;
               break;
   
             case Terminal.ANSI_BRIGHT:
             case Terminal.ANSI_UNDERLINE:
             case Terminal.ANSI_BLINK:
             case Terminal.ANSI_INVERSE:
             case Terminal.ANSI_XTERM_FG:
             case Terminal.ANSI_XTERM_BG:
               state[value] = true;
               break;
   
             default:
               if (30 <= value && value <= 37) {
                 state.fg = value;
               } else if (40 <= value && value <= 47) {
                 state.bg = value - 10;
               }
              break;
             }
           }
   
           this.ansiDirty = true;
         }
         break;
       }
     };
   
     Terminal.prototype.write = function (value, start, end) {
       if (start === end) {
         return;
       }
   
       if (this.ansiDirty) {
         var next = Terminal.encodeState(this.ansiState);
   
         if (this.ansiClass !== next) {
           this.ansiClass = next;
           this.span = null;
         }
   
         this.ansiDirty = false;
       }
   
       if (this.ansiClass && !this.span) {
         this.span = document.createElement('span');
         this.span.className = this.ansiClass;
         this.stack[this.stack.length - 1].appendChild(this.span);
       }
   
       var text = document.createTextNode(value.substring(start, end));
       this.lineBuf[this.lineBuf.length] = text;
   
       this.appendChild(text);
     };
   
     Terminal.prototype.endLine = function () {
       var that = this;
       this.onLine && this.onLine(that, this.lineBuf);
   
       this.write('\n', 0, 1);
       this.lineBuf.length = 0;
     };
   
     Terminal.prototype.abortParse = function (value, start, end) {
       switch (this.state) {
       case Terminal.PARSE_PLAIN:
         this.write(value, start, end);
         break;
   
       case Terminal.PARSE_ESC1:
         this.write('\u001B', 0, 1);
         break;
   
       case Terminal.PARSE_ESC2:
         this.write('\u001B[', 0, 2);
         this.write(this.parseBuf, 0, this.parseBuf.length);
         this.parseBuf = '';
         break;
       }
     };
   
     /////////////////////////////////////////////////////
     // message appending routines
     
     // appends a text string to the terminal, parsing ansi escape codes into html/css
     Terminal.prototype.appendText = function (data) {
       var start = 0;
   
       // Scan for sequence start characters.
       // TODO: Could scan with RegExp; not convinced sufficiently simpler/faster.
       for (var ii = 0, ilen = data.length; ii < ilen; ++ii) {
         var ch = data.charCodeAt(ii);
   
         // Resynchronize at special characters.
         switch (ch) {
         case 10: // newline
           if (this.state !== Terminal.PARSE_CR) {
             this.abortParse(data, start, ii);
             this.endLine();
           }
   
           start = ii + 1;
           this.state = Terminal.PARSE_PLAIN;
           continue;
   
         case 13: // carriage return
           this.abortParse(data, start, ii);
           this.endLine();
           start = ii + 1;
           this.state = Terminal.PARSE_CR;
           continue;
   
         case 27: // escape
           this.abortParse(data, start, ii);
           start = ii + 1;
           this.state = Terminal.PARSE_ESC1;
           continue;
         }
   
         // Parse other characters.
         switch (this.state) {
         case Terminal.PARSE_CR:
           this.state = Terminal.PARSE_PLAIN;
           break;
   
         case Terminal.PARSE_ESC1:
           if (ch === 91) {
             // Start of escape sequence (\e[).
             start = ii + 1;
             this.state = Terminal.PARSE_ESC2;
           } else {
             // Not an escape sequence.
             this.abortParse(data, start, ii);
             start = ii;
             this.state = Terminal.PARSE_PLAIN;
           }
           break;
   
         case Terminal.PARSE_ESC2:
           if (64 <= ch && ch <= 126) {
             // End of escape sequence.
             this.parseBuf += data.substring(start, (start = ii + 1));
             this.applyANSI(this.parseBuf);
             this.parseBuf = '';
             this.state = Terminal.PARSE_PLAIN;
           }
           break;
         }
       }
   
       // Handle tail.
       switch (this.state) {
       case Terminal.PARSE_PLAIN:
         this.write(data, start, data.length);
         break;
   
       case Terminal.PARSE_ESC2:
         this.parseBuf += data.substring(start);
         break;
       }
     };
   
     Terminal.prototype.appendHTML = function (html) {
       var div = document.createElement('div');
       var fragment = document.createDocumentFragment();
   
       div.innerHTML = html;
   
       for (var child = div.firstChild; child; child = child.nextSibling) {
         var cmd = child.getAttribute('xch_cmd');
         if (cmd !== null && cmd !== '') {
           child.setAttribute('onClick', 'this.onCommand("' + cmd + '");');
           child.onCommand = this.onCommand;
           child.removeAttribute('xch_cmd');
         }
         fragment.appendChild(child);
       }
   
       this.appendChild(fragment);
     };
   
     // append an HTML fragment to the terminal
     Terminal.prototype.appendChild = function (fragment) {
       var last = (this.span || this.stack[this.stack.length - 1]);
       last.appendChild(fragment);
       
       this.scrollDown();
     };
     
     // append a log message to the terminal
     Terminal.prototype.appendMessage = function (classid, message) {
       var div = document.createElement('div');
       div.className = classid;
       
       // create a text node to safely append the string without rendering code
       var text = document.createTextNode(message);
       div.appendChild(text);
       
       this.appendChild(div);
     };
     
     // push a new html element onto the stack
     Terminal.prototype.pushElement = function (element) {
       this.span = null;
       this.stack[this.stack.length - 1].appendChild(element);
       this.stack[this.stack.length] = element;
     };
   
     // remove 1 level from the stack, check consistency 
     Terminal.prototype.popElement = function () {
       this.span = null;
   
       if (this.stack.length > 1) {
         --this.stack.length;
       } else {
         window.console && window.console.warn('element stack underflow');
       }
     };
   
     // append a pueblo tag to the terminal stack (or pop if an end tag)
     Terminal.prototype.appendPueblo = function (data) {
       var tag, attrs;
   
       var idx = data.indexOf(' ');
       if (idx !== -1) {
         tag = data.substring(0, idx);
         attrs = data.substring(idx + 1);
       } else {
         tag = data;
         attrs = '';
       }
       
       var html = '<' + tag + (attrs ? ' ' : '') + attrs + '>';
   
       var start;
       if (tag[0] !== '/') {
         start = true;
       } else {
         start = false;
         tag = tag.substring(1);
       }
       
       // detect a self closed tag
       var selfClosing = false;
       if ((tag.substring(-1) === '/') || (attrs.substring(-1) === '/')) {
         selfClosing = true;
       }
       
       if (Terminal.UNCLOSED_TAGS.indexOf(tag.toLowerCase()) > -1) {
         selfClosing = true;
       }
   
       if ((tag === 'XCH_PAGE') || 
           ((tag === 'IMG') && (attrs.search(/xch_graph=(("[^"]*")|('[^']*')|([^\s]*))/i) !== -1))) {
         //console.log("unhandled pueblo", html);
         return;
       }
   
       // we have a starting <tag> (not </tag>)
       if (start) {
         var div = document.createElement('div');
   
         html = html.replace(
           /xch_graph=(("[^"]*")|('[^']*')|([^\s]*))/i,
           ''
         );
   
         html = html.replace(
           /xch_mode=(("[^"]*")|('[^']*')|([^\s]*))/i,
           ''
         );
   
         html = html.replace(
           /xch_hint="([^"]*)"/i,
           'title="$1"'
         );
   
         div.innerHTML = html.replace(
           /xch_cmd="([^"]*)"/i,
           "onClick='this.onCommand(&quot;$1&quot;)'"
         );
         
         div.firstChild.onCommand = this.onCommand;
   
         div.setAttribute('target', '_blank');
         
         // add this tag to the stack to keep track of nested elements
         this.pushElement(div.firstChild);
   
         // automatically pop the tag if it is self closing
         if (selfClosing) {
           this.popElement();
         }
   
       } else {
         // we have an ending </tag> so remove the closed tag from the stack
         // don't bother for self closing tags with an explicit end tag, we already popped them
         if (!selfClosing) {
           this.popElement();
         }
       }
     };
     
     Terminal.prototype.clear = function() {
       this.root.innerHTML = '';
   
       this.stack = [this.root];
   
       this.state = Terminal.PARSE_PLAIN;
       this.line = null;
       this.lineBuf = [];
       this.span = null;
       this.parseBuf = '';
   
       this.ansiClass = '';
       this.ansiState = null;
       this.ansiDirty = false;
     };
     
     // animate scrolling the terminal window to the bottom
     Terminal.prototype.scrollDown = function() {
       // TODO: May want to animate this, to make it less abrupt.
       //this.root.scrollTop = this.root.scrollHeight;
       //return;
       
       var root = this.root;
       var scrollCount = 0;
       var scrollDuration = 500.0;
       var oldTimestamp = performance.now();
   
       function step (newTimestamp) {
         var bottom = root.scrollHeight - root.clientHeight;
         var delta = (bottom - root.scrollTop) / 2.0;
   
         scrollCount += Math.PI / (scrollDuration / (newTimestamp - oldTimestamp));
         if (scrollCount >= Math.PI) root.scrollTo(0, bottom);
         if (root.scrollTop === bottom) { return; }
         root.scrollTo(0, Math.round(root.scrollTop + delta));
         oldTimestamp = newTimestamp;
         window.requestAnimationFrame(step);
       }
       window.requestAnimationFrame(step);
     };
   
     // setup the pueblo xch_cmd callback
     Terminal.prototype.onCommand = null;
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // User input handler (command history, callback events)
     function UserInput(root) {
       var that = this;
       
       if (root === null) {
         return null;
       }
       
       this.root = root;
       
       this.clearHistory();
     
       this.root.onkeydown = function(evt) {
         UserInput.onkeydown(that, evt);
       };
       
       this.root.onkeyup = function(evt) {
         UserInput.onkeyup(that, evt);
       };
     }
     
     // clear the history for a given UserInput object
     UserInput.clearhistory = function(that) {
   
     };
     
     // passthrough to the local onKeyDown callback
     UserInput.onkeydown = function(that, evt) {
       that.onKeyDown && that.onKeyDown(evt);
     };
   
     // passthrough to the local onKeyUp callback
     UserInput.onkeyup = function(that, evt) {
       that.onKeyUp && that.onKeyUp(evt);
     };
     
     // set the default onKeyDown handler
     UserInput.prototype.onKeyDown = function(e) {
       PressKey(this, e);
     };
     
     // set the default onKeyUp handler
     UserInput.prototype.onKeyUp = function(e) {
       ReleaseKey(this, e);
     };
     
     UserInput.prototype.onEnter = null;
     UserInput.prototype.onEscape = null;
     
     // clear the command history
     UserInput.prototype.clearHistory = function() {
       this.history = [];
       this.ncommand = 0;
       this.save_current = '';
       this.current = -1;
     };
     
     // push a command onto the history list and clear the input box
     UserInput.prototype.saveCommand = function() {
       if (this.root.value !== '') {
         this.history[this.ncommand] = this.root.value;
         this.ncommand++;
         this.save_current = '';
         this.current = -1;
         this.root.value = '';
       }
     };
     
     // cycle the history backward
     UserInput.prototype.cycleBackward = function() {
       // save the current entry in case we come back
       console.log("cycle backwards");
       if (this.current < 0) {
         this.save_current = this.root.value;
       }
       
       // cycle command history backward
       if (this.current < this.ncommand - 1) {
         this.current++;
         this.root.value = this.history[this.ncommand - this.current - 1];
       }
     };
     
     // cycle the history forward
     UserInput.prototype.cycleForward = function () {
       // cycle command history forward
       console.log("cycle forwards");
       if (this.current > 0) {
         this.current--;
         this.root.value = this.history[this.ncommand - this.current - 1];
       } else if (this.current === 0) {
         // recall the current entry if they had typed something already
         this.current = -1;
         this.root.value = this.save_current;
       }
     };
     
     
     
     // move the input cursor to the end of the input elements current text
     UserInput.prototype.moveCursor = function() {
       if (typeof this.root.selectionStart === "number") {
           this.root.selectionStart = this.root.selectionEnd = this.root.value.length;
       } else if (typeof this.root.createTextRange !== "undefined") {
           this.focus();
           var range = this.root.createTextRange();
           range.collapse(false);
           range.select();
       }
     };
     
     
     
     // clear the current input text
     UserInput.prototype.clear = function() {
       this.root.value = '';
     };
     
     // get the current text in the input box
     UserInput.prototype.value = function() {
       return this.root.value;
     };
     
     // refocus the input box
     UserInput.prototype.focus = function() {
       var text = "";
       if (window.getSelection) {
         text = window.getSelection().toString();
       } else if (document.selection && document.selection.type != "Control") {
         text = document.selection.createRange().text;
       }
       
       if (text === "") {
         this.root.focus();
       }
     };
     
     // user-defined keys for command history
     UserInput.prototype.keyCycleForward = null;
     UserInput.prototype.keyCycleBackward = null;
    
     UserInput.ctl_u = function( that, key) {
        if(key.code === 85 && key.ctrl) {
           return 1;
        } else {
           return 0;
        }
     };

     UserInput.ctl_l = function( that, key) {
        if(key.code === 76 && key.ctrl) {
           return 1;
        } else {
           return 0;
        }
     };
 
     UserInput.isKeyCycleForward = function(that, key) {
       if (that && that.keyCycleForward) {
         return that.keyCycleForward(key);
       } else {
         // default key is ctrl+n
         return (key.code === 78 && key.ctrl);
       }
     };
     
     UserInput.isKeyCycleBackward = function (that, key) {
       if (that && that.keyCycleBackward) {
         return that.keyCycleBackward(key);
       } else {
         // default key is ctrl+p
         return (key.code === 80 && key.ctrl);
       }
     };
     
     
     
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     // some string helper functions for replacing links and user input tokens
   
     // Example onLine() handler that linkifies URLs in text.
     function LinkHandler(that, lineBuf) {
       // Merge text so we can scan it.
       if (!lineBuf.length) {
         return;
       }
   
       var line = '';
       for (var ii = 0, ilen = lineBuf.length; ii < ilen; ++ii) {
         line += lineBuf[ii].nodeValue;
       }
   
       // Scan the merged text for links.
       var links = LinkHandler.scan(line);
       if (!links.length) {
         return;
       }
   
       // Find the start and end text nodes.
       var nodeIdx = 0, nodeStart = 0, nodeEnd = lineBuf[0].nodeValue.length;
       for (var ii = 0, ilen = links.length; ii < ilen; ++ii) {
         var info = links[ii], startOff, startNode, endOff, endNode;
   
         while (nodeEnd <= info.start) {
           nodeStart = nodeEnd;
           nodeEnd += lineBuf[++nodeIdx].nodeValue.length;
         }
   
         startOff = info.start - nodeStart;
         startNode = lineBuf[nodeIdx];
   
         while (nodeEnd < info.end) {
           nodeStart = nodeEnd;
           nodeEnd += lineBuf[++nodeIdx].nodeValue.length;
         }
   
         endOff = info.end - nodeStart;
         endNode = lineBuf[nodeIdx];
   
         // Wrap the link text.
         // TODO: In this version, we won't try to cross text nodes.
         // TODO: Discard any text nodes that are already part of links?
         if (startNode !== endNode) {
           window.console && window.console.warn('link', info);
           continue;
         }
   
         lineBuf[nodeIdx] = endNode.splitText(endOff);
         nodeStart += endOff;
   
         var middleNode = startNode.splitText(startOff);
         var anchor = document.createElement('a');
         middleNode.parentNode.replaceChild(anchor, middleNode);
   
         anchor.target = '_blank';
         if (info.url === '' && info.xch_cmd !== '') {
           anchor.setAttribute('onClick', 'this.onCommand("'+info.xch_cmd+'");');
           anchor.onCommand = that.onCommand;
         } else {
           anchor.href = info.url;
         }
         anchor.appendChild(middleNode);
       }
     }
   
     // Link scanner function.
     // TODO: Customizers may want to replace this, since regular expressions
     // ultimately limit how clever our heuristics can be.
     LinkHandler.scan = function (line) {
       var links = [], result;
   
       LinkHandler.regex.lastIndex = 0;
       while ((result = LinkHandler.regex.exec(line))) {
         var info = {};
   
         info.start = result.index + result[1].length;
         info.xch_cmd = '';
         if (result[2]) {
           result = result[2];
           info.url = result;
         } else if (result[3]) {
           result = result[3];
           info.url = 'mailto:' + result;
         } else if (result[4]) {
           result = result[4];
           info.url = '';
           info.xch_cmd = 'help ' + result;
           info.className = "ansi-1-37";
         }
   
         info.end = info.start + result.length;
   
         links[links.length] = info;
       }
   
       return links;
     };
   
     // LinkHandler regex:
     //
     // 1. Links must be preceded by a non-alphanumeric delimiter.
     // 2. Links are matched greedily.
     // 3. URLs must start with a supported scheme.
     // 4. E-mail addresses are also linkified.
     // 5. Twitter users and hash tags are also linkified.
     //
     // TODO: This can be improved (but also customized). One enhancement might be
     // to support internationalized syntax.
     LinkHandler.regex = /(^|[^a-zA-Z0-9]+)(?:((?:http|https):\/\/[-a-zA-Z0-9_.~:\/?#[\]@!$&'()*+,;=%]+[-a-zA-Z0-9_~:\/?#@!$&*+;=%])|([-.+a-zA-Z0-9_]+@[-a-zA-Z0-9]+(?:\.[-a-zA-Z0-9]+)+)|(@[a-zA-Z]\w*))/g;
   
     // set the default line handler for the terminal to use the LinkHandler
     Terminal.prototype.onLine = LinkHandler;
   
     // detect if more user input is required for a pueblo command
     function ReplaceToken(command) {
       var cmd = command;
       var regex = /\?\?/;
       
       // check for the search token '??'
       if (cmd.search(regex) !== -1) {
         var val = prompt(command);
         
         if (val === null) {
           // user cancelled the prompt, don't send any command
           cmd = '';
         } else {
           // replace the ?? token with the prompt value
           cmd = cmd.replace(regex, val);
         }
       }
       
       return cmd;
     };
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // default handler for key press events
     function PressKey(that, e) {
       var key = { code: (e.keyCode ? e.keyCode : e.which),
                   ctrl: e.ctrlKey,
                   shift: e.shiftKey,
                   alt: e.altKey };
   
       var prevent = true;
//       console.log('key: ' + key.code);
      
       if(UserInput.ctl_u(that,key)) {
          that.root.value = '';
       } else if(UserInput.ctl_l(that,key)) {
          that.onEnter('/key_ctl_l\r\n');
       } else if (UserInput.isKeyCycleBackward(that, key)) {
         console.log('cycle backwards');
         // cycle history backward
         that.cycleBackward();
       } else if (UserInput.isKeyCycleForward(that, key)) {
         // cycle history forward
         console.log('cycle forward');
         that.cycleForward();
   
       } else if (key.code === 13) {
         // enter key
         
         // save the command string and clear the input box
         var cmd = that.root.value;
         that.saveCommand();
   
         // pass through to the local callback for sending data
         that.onEnter && that.onEnter(cmd);
           
       } else if (key.code === 27) {
   
         // pass through to the local callback for the escape key
   //      that.onEscape && that.onEscape();
   
   //    } else if  (that.last_key === 27 && key.code === 119) {
       } else if (that.last_key == 27 && key.code === 87) {
         that.onEnter('/key_esc_w\r\n');
       } else if  (that.last_key == 27 && key.code === 76) {
         that.onEnter('/key_ctl_l\r\n');
       } else if (key.code === 9) {
         that.onEnter('/key_tab\r\n');
       } else if (key.code === 38) {
         that.onEnter('/key_up\r\n' );
       } else if (key.code === 40) {
         that.onEnter('/key_down\r\n');
       } else if (key.code === 34) {
         that.onEnter('/key_pgdn\r\n');
       } else if (key.code === 33) {
         that.onEnter('/key_pgup\r\n');
       } else { 
         // didn't capture anything, pass it through
         prevent = false;
   
       }
       
       that.last_key = key.code; 
   
       if (prevent) {
         e.preventDefault();
       }
   
       // make sure input retains focus
       that.focus();
     };
   
   
   
     // default handler for key release events
     function ReleaseKey(that, e) {
       var key = { code: (e.keyCode ? e.keyCode : e.which),
                   ctrl: e.ctrlKey,
                   shift: e.shiftKey,
                   alt: e.altKey };
   
       if (UserInput.isKeyCycleBackward(that, key) ||
           UserInput.isKeyCycleForward(that, key)) {
   
         // move the cursor to end of the input text after a history change
         that.moveCursor();
       }
     };
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // Module exports.
     var exports = {};
   
     // open a websocket connection to url
     exports.connect = function (url) {
       return new Connection(url);
     };
   
     // create a terminal emulator that appends output to root
     exports.output = function (root) {
       return new Terminal(root);
     };
     
     // create an input handler that saves and recalls command history
     exports.input = function (root) {
       return new UserInput(root);
     };
     
     // default key event callback handlers
     exports.pressKey = PressKey;
     exports.releaseKey = ReleaseKey;
     
     // helper for replacing ?? in string with user input
     exports.parseCommand = ReplaceToken;
     
     // export the LinkHandler just in case it's useful elsewhere
     exports.parseLinks = LinkHandler;
   
    return exports;
   })(window, document);
START: muddler_client.html
   <!DOCTYPE html>
   <html><head><meta name="viewport" content="width=device-width, maximum-scale=1" charset="UTF-8">


   
   <link rel="stylesheet" href="muddler_ansi.css">
   <link rel="stylesheet" href="muddler_style.css">
   <base target="_blank">
   <title>Muddler</title></head>
   
   <body onLoad="input.focus()"
          setTimeout(conn.close, 1000);"
         onClick="input.focus()">
   
   <div id="terminal">
     <div id="output" class="ansi-37 ansi-40"></div>
     <div id="bar" class="ansi-37 ansi-1-37"></div>
     <div id="prompt" class="ansi-37 ansi-1-37"></div>
     <div id="bartime" class="ansi-37 ansi-1-37"></div>
     <textarea id="input" autocomplete="off" autofocus></textarea>
   </div>
     <div id="buttonbar" "class=buttonbar" style=width:100%>
         <button style="display:inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 0px 1px 1px;padding:0;float:left" onclick="input.onEnter('/key_pgup 5')">Up</button>
         <button style="display:inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 0px 1px 1px;padding:0;float:left" onclick="input.onEnter('/key_pgdn 5')">Down</button>
         <button style="display: inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 0px 1px 1px;padding 0;float:left" onclick="input.onEnter('/key_up')">Next</button>
         <button style="display: inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 1px 1px 1px;padding 0;float:left" onclick="input.onEnter('/key_down')">Prev</button>
     </div>
     </div class=triangle>
        <div class="inner-triangle" onclick="input.onEnter('/mobile')"><span>muddler</span></div>
        <div class="outer-triangle"></div>
     </div>
   
   <script type="text/javascript" src="muddler_client.js"></script>
   <script type="text/javascript">
     var serverAddress = window.location.hostname;
     var serverSSL = window.location.protocol == "https:";
     var serverProto = serverSSL ? "wss://" : "ws://";
     var serverPort = serverSSL ? '9001' : '9001';
     
     var customUrl = window.location.search.substring(1) ? window.location.search.substring(1) : serverAddress + ":" + serverPort;
     // The connection URL is ws://host:port/wsclient (or wss:// for SSL connections)
   //  var serverUrl = serverProto + customUrl + '/wsclient'
     var serverUrl = serverProto + customUrl + '/connect'
     // define the input box, output terminal, and network connection
     var output = WSClient.output(document.getElementById('output'));
     var cmdprompt = WSClient.output(document.getElementById('prompt'));
     var bar = WSClient.output(document.getElementById('bar'));
     var bartime = WSClient.output(document.getElementById('bartime'));
     var input = WSClient.input(document.getElementById('input'));
     var conn = WSClient.connect(serverUrl);
     // function to send a command string to the server
     function sendCommand(cmd) {
       if (conn.isConnected()) {
         if (cmd !== '') {
           conn.sendText(cmd);
   //        output.appendMessage('localEcho', cmd);
         }
       } else {
         // connection was broken, let's reconnect
         conn.reconnect();
         output.appendMessage('logMessage', '%% Reconnecting to server...');
       }
     }
  
     function get_xy_size() {
         var out = document.getElementById('output')
         var css = getComputedStyle(out,null);
         var ff  = css.getPropertyValue("font-family");
         var fs  = css.getPropertyValue("font-size");
         var temp = document.createElement('span');

         temp.style = "margin:0px;padding:0px;font-family:"+ff+
                      ";font-size:" + fs;
        
         temp.innerText = "0123456789";
         var element = document.body.appendChild(temp);
         var x = Math.round(out.offsetHeight / (temp.offsetHeight-2));
         var y = Math.round(out.offsetWidth / (temp.offsetWidth / 10));
         temp.parentNode.removeChild(temp);
         return x + "," + y + "," + fs + "-" + ff + "=1";
     }

     // just log a standard message on these socket status events
     conn.onOpen = function (evt) { 
         output.appendMessage('logMessage', '%% Connected.');
         sendCommand('/web_size ' + get_xy_size() + '\r\n');
         // sendCommand(window.prompt("Enter password","xyzzy"));
     };
     conn.onError = function (evt) { output.appendMessage('logMessage', '%% Connection error!'); console.log(evt); };
     conn.onClose = function (evt) { output.appendMessage('logMessage', '%% Connection closed.'); };
     // handle incoming text, html, pueblo, or command prompts
   
   //        conn.onMessage = function (code,text) {
    //              output.appendText('### ' + code + ' : ' + text);
     //      };
   
     conn.onText = function (text) { output.appendText(text); };
     conn.onHTML = function (html) { output.appendHTML(html); };
     conn.onPueblo = function (html) { output.appendPueblo(html); };
     conn.onBar = function (html) { bar.clear();bar.appendText(html); };
     conn.onBarTime = function (html) { bartime.clear();bartime.appendText(html); };
     conn.onPrompt = function (text) { cmdprompt.clear(); cmdprompt.appendText(text + '\r\n'); };
     
     // handle incoming JSON objects. requires server specific implementation
     conn.onObject = function (obj) { console.log('unhandled JSON object' + obj); };
     // pueblo command links, prompt for user input and replace ?? token if present
     output.onCommand = function(cmd) { sendCommand(WSClient.parseCommand(cmd)); };
     // enter key passthrough from WSClient.pressKey
     input.onEnter = function(cmd) { sendCommand(cmd); };
     
     // escape key passthrough from WSClient.pressKey
     input.onEscape = function () { this.clear(); };
     
     // input key event callbacks. here we show the defaults
     // provided by WSClient.pressKey and WSClient.releaseKey
     // input.onKeyDown = function(e) { WSClient.pressKey(this, e); };
     // input.onKeyUp = function(e) { WSClient.releaseKey(this, e); };
     
     // which keys are used for cycling through command history?
     // here we show the default keys, ctrl+p and ctrl+n
     // input.keyCycleForward = function(key) { return (key.code === 78 && key.ctrl); }; // ctrl+n
     // input.keyCycleBackward = function(key) { return (key.code === 80 && key.ctrl); }; // ctrl+p
     
   </script>
   
   </body>
   </html>
