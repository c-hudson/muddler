#!/usr/bin/env perl
#-#         ( A 90dies mud client written today ) 
#-#       o               v1.1                   
#-#      o _____                __  __ _          
#-#    _||_| u |    _ _  _ _ __| /_| /| |  __ ____
#-#   (        |== / v \| | |  _ | _ || |/ -_) __/
#-#   /-()---()   |_|_|_|___/\___\___/|_|\__/_/   
#
# Note: A large section of the javascript, html, css came from Grapenut's
#       websocket client and has been embeded into this perl script.
#       I'm betting this is okay considering the license is described as:
#       There is no license. Just make a neato game with it.
#
#       Project's location: https://github.com/grapenut/websockclient

use 5.014;                                                   # enable utf8
use IO::Socket;
use utf8;
use POSIX;
use strict;
binmode(STDOUT, ":encoding(UTF-8)");
my ($term, $oterm, $echo, $noecho, $fd_stdin, $ctx,$SSL_ERROR); # required for cbreak/etc

# use Monitor qw(monitor);

use Carp;
my %key;                            # key presses hash table for fast lookups
my %history;                                                  # world history
my %pending;                                                  # world history
my %socket;                                              # socket information
my %socket_lookup;
my %command;                            # command hash table for fast lookups
my %address;                                                # world addresses 
my @std_input;                                                # input history
my %ws;                                             # websocket specific data
my $ws_listen;                                           # websocket listener
my $ws_server;                                             # websocket server
my $http_listen;                                              # http listener
my %http;                               # data structure for http connections
my %http_data;                                 # store websocket client pages
my %def;                                        # tf style define information
my %pid;                                              # internal process list
my %telnet_ch;
my $client;                                                # websocket client
my $wc;                                                    # websocket client
my %var;                                                 # settable variables
my %call;                               # call back commands for dialog usage
my @options = qw(
    BINARY ECHO RCP SGA NAMS STATUS TM RCTE NAOL NAOP NAOCRD NAOHTS NAOHTD
    NAOFFD NAOVTS NAOVTD NAOLFD XASCII LOGOUT BM DET SUPDUP SUPDUPOUTPUT SNDLOC
    TTYPE EOR TUID OUTMRK TTYLOC VT3270REGIME X3PAD NAWS TSPEED LFLOW LINEMODE
    XDISPLOC OLD_ENVIRON AUTHENTICATION ENCRYPT NEW_ENVIRON
);

my %state = (
   line_pos        => 0,           # character position on the current line
   size_x          => 24,                     # size of screen horizontally
   size_y          => 80,                  # size of the screen veritically
   input_offset    => 0,                   # lines scrolled off input buffer
   input_pos       => -1,                        # location in input history
   line            => [],                                # curent input line
   pending         => {},
   web             => 0,                        # websocket enabled/disabled
   console         => 1,                            # disable console output
   p_password      => "xyzzy",
   p_theme         => "light",                     # default websocket theme
   p_port          => 9000,                 # web/websock port starting port
   p_debug         => 0,                   # store debuging info to log file
   p_more          => 1,                                      # enable /more
   p_nospoof       => 1,
   overlap         => 3,                        # keep X lines from previous
                                                     # output when scrolling
   world           => "muddler",    # starting "world" to make coding easier
   activity        => {},                       # store worlds with activity
);

#                                    cpan => "perl -MCPAN -e \"install " .
#                                           "Net::WebSocket::Server\"",
my %mod = (
   'Term::ReadKey'               => { fatal => 0,
                                      pkg => "libterm-readkey-perl",
                                      for => 'screen size detection'
                                    },
   'Net::WebSocket::Server'      => { fatal => 0,
                                      cpan => "yes",
                                      for => 'web gui'
                                    },
   'Encode'                      => { fatal => 0,
                                      for => "utf8/fansi",
                                      quote => "qw(decode encode)"
                                    },
   'Fcntl'                       => { fatal => 0,
                                      for => "writing rc file",
                                      quote => "qw(SEEK_END)"
                                    },
   'Digest::MD5'                 => { fatal => 0,
                                      pkg => "Digest::MD5",
                                      for => "caching/code reloading"
                                    },
   'Text::Aspell'                => { fatal => 0,
                                      pkg => "libtext-aspell-perl", 
                                      for => 'spell check' },
   'IO::Socket::SSL'             => { fatal => 0,
                                      pkg => "libio-socket-ssl-perl",
                                      for => 'encrypted connections'
                                    },
   'IO::Select'                  => { fatal => 1,
                                      for => 'networking'
                                    },
   'IO::Socket'                  => { fatal => 1,
                                      for => 'networking'
                                    },
   'Text::ParseWords'            => { fatal => 0,
                                      for => 'tf compat'
                                    },
   'IO::Socket::Timeout'         => { fatal => 0,
                                      for => 'ssl websockets',
                                      pkg => "libio-socket-timeout-perl"
                                    },
   'Protocol::WebSocket::Client' => { fatal => 0,
                                        for => 'remote console',
                                    },
   'MIME::Base64'                => { fatal => 0,
                                      for => 'file transfer',
                                    },
   'Data::Dumper'                => { fatal => 0,
                                      for => 'remote console'
                                    },
);
#
# define all keys/commands in a manor so that they can be reloaded
# while the program is still running.
#
sub key_init
{
   delete @key{keys %key};
   for my $key (keys %key) {
      undef(@key{$key});
   }
   @key{def}                  = sub { return key_default(@_);          };
   @key{1}                    = sub { return key_ctl_a(@_);            };
   @key{2}                    = sub { return key_left(@_);             };
   @key{4}                    = sub { return key_dump(@_);             };
   @key{5}                    = sub { return key_ctl_e(@_);            };
   @key{6}                    = sub { return key_right(@_);            };
   @key{8}                    = sub { return key_delete(@_);           };
   @key{9}                    = sub { return key_tab(@_);              };
   @key{10}                   = sub { return key_return(@_);           };
   @key{12}                   = sub { return key_ctl_l(@_);            };
   @key{14}                   = sub { return key_ctl_n(@_);            };
   @key{16}                   = sub { return key_ctl_p(@_);            };
   @key{18}                   = sub { return key_ctl_r(@_);            };
   @key{21}                   = sub { return key_ctl_u(@_);            };
   @key{23}                   = sub { return key_ctl_w(@_);            };
   @key{27}                   = sub { return key_escape(@_);           };
   @key{127}                  = sub { return key_delete(@_);           };
   @key{multi}                = sub { return key_multi(@_);            };
   @key{multi_119}            = sub { return key_esc_w(@_);            };
   @key{multi_113}            = sub { return key_esc_q(@_);            };
   @key{multi_106}            = sub { return key_esc_j(@_);            };
   @key{multi_91_53_126}      = sub { return key_pgup(@_);             };
   @key{multi_91_54_126}      = sub { return key_pgdn(@_);             };
   @key{multi_91_65}          = sub { return key_up(@_);               };
   @key{multi_91_66}          = sub { return key_down(@_);             };
   @key{multi_91_67}          = sub { return key_right(@_);            };
   @key{multi_91_68}          = sub { return key_left(@_);             };
   @key{multi_91_49_59_50_65} = sub { return key_shift_up(@_);         };
   @key{multi_91_49_59_50_66} = sub { return key_shift_down(@_);       };
   @key{multi_91_90}          = sub { return key_shift_tab(@_);        };
   @key{multi_91_49_126}      = sub { return key_home(@_);             };
   @key{multi_91_52_126}      = sub { return key_end(@_);              };

   # populate the gaps so the code knows to traverse through all the
   # characters in the definition instead of just the last one.
   for my $key (grep {/^multi_/} keys %key) {
      my @list = split('_',$key);
      while($#list >= 1) {
         pop(@list);
         @key{join('_',@list)} = 1 if(!defined @key{join('_',@list)});
      }
   }
}

sub command_init
{
   delete @command{keys %command};
   @command{key_ctl_r}     = sub { return key_ctl_r(@_);                   };
   @command{send}          = sub { return cmd_send(@_);                    };
   @command{blurred}       = sub { return cmd_blurred(@_);                 };
   @command{focused}       = sub { return cmd_focused(@_);                 };
   @command{stat}          = sub { return cmd_stat(@_);                    };
   @command{world}         = sub { return cmd_world(@_);                   };
   @command{quit}          = sub { return cmd_quit(@_);                    };
   @command{dc}            = sub { return cmd_dc(@_);                      };
   @command{list}          = sub { return cmd_list(@_);                    };
   @command{listsockets}   = sub { return cmd_listsockets(@_);             };
   @command{l}             = sub { return cmd_listsockets(@_);             };
   @command{recall}        = sub { return cmd_recall(@_);                  };
   @command{version}       = sub { return cmd_version(@_);                 };
   @command{help}          = sub { return cmd_help(@_);                    };
   @command{web}           = sub { return cmd_web(@_);                     };
   @command{key_tab}       = sub { return key_tab(@_);                     };
   @command{key_esc_w}     = sub { return key_esc_w(@_);                   };
   @command{key_ctl_l}     = sub { return key_ctl_l(@_);                   };
   @command{key_up}        = sub { return key_up(@_);                      };
   @command{key_down}      = sub { return key_down(@_);                    };
   @command{key_pgdn}      = sub { return key_pgdn(@_);                    };
   @command{key_pgup}      = sub { return key_pgup(@_);                    };
   @command{web_size}      = sub { return cmd_web_size(@_);                };
   @command{repeat}        = sub { return cmd_repeat(@_);                  };
   @command{echo}          = sub { return cmd_echo(@_);                    };
   @command{ps}            = sub { return cmd_ps(@_);                      };
   @command{kill}          = sub { return cmd_kill(@_);                    };
   @command{def}           = sub { return cmd_def(@_);                     };
   @command{undef}         = sub { return cmd_undef(@_);                   };
   @command{listdef}       = sub { return cmd_listdef(@_);                 };
   @command{listworlds}    = sub { return cmd_listworlds(@_);              };
   @command{addworld}      = sub { return cmd_editor(@_);                  };
   @command{rc}            = sub { return read_tfrc("@ENV{HOME}/.tfrc");   };
   @command{update}        = sub { return cmd_update(@_);                  };
   @command{mobile}        = sub { return cmd_mobile(@_);                  };
   @command{setup}         = sub { return cmd_set(@_);                     };
   @command{log}           = sub { return cmd_log(@_);                     };
   @command{more}          = sub { return cmd_more(@_);                    };
   @command{common}        = sub { return cmd_common(@_);                  };
   @command{console}       = sub { return cmd_console(@_);                 };
   @command{perl}          = sub { return cmd_perl(@_);                    };
   @command{quote}         = sub { return cmd_quote(@_);                   };
   @command{window}        = sub { return cmd_window(@_);                  };
   @command{gc}            = sub { wrap_garbage_collect();                 };
   @command{file}          = sub { return cmd_file(@_);                    };
   @command{accept}        = sub { return cmd_accept(@_);                  };
   @command{request_info}  = sub { return cmd_request_info(@_);            };
   @command{handle_login}  = sub { return handle_login(@_);                };
   @command{sync}          = sub { return cmd_sync(@_);                    };
   #-----------------------------------------------------------------------#
   @command{clock}         = sub { return cmd_null(@_);                    };
   @command{lcd}           = sub { return cmd_null(@_);                    };
   @command{hilite_page}   = sub { return cmd_null(@_);                    };
   @command{hilite_whisper}= sub { return cmd_null(@_);                    };
   @command{status_rm}     = sub { return cmd_null(@_);                    },
   # @command{set}           = sub { return cmd_null(@_);                    };
   @command{load}          = sub { return cmd_null(@_);                    };
   @command{loadworld}     = sub { return load(@_);                        };
   @command{visual}        = sub { return cmd_null(@_);                    };
   @command{input_size}    = sub { return cmd_set($_[0],"input_size=$_[1]");};
   @command{isize}         = sub { return cmd_set($_[0],"input_size=$_[1]");};
   @command{idleit}        = sub { return cmd_null(@_);                    };
   @command{saveworld}     = sub { return cmd_null(@_);                    };

   for my $key (sort {length($a) <=> length($b)} keys %command) {
      for my $i (0 .. length($key)) {
         if(!defined @command{substr($key,0,$i)}) {
            @command{substr($key,0,$i)} = $key;
         }
      }
   }
}

sub callback_init
{
   delete @call{keys %call};
   @call{dialog_cancel}         = sub { return dialog_cancel(@_) };
   @call{editor_save}           = sub { return editor_save(@_) };
   @call{editor_connect}        = sub { return editor_connect(@_) };
   @call{editor_delete}         = sub { return editor_delete(@_) };
   @call{set_save}              = sub { return set_save(@_) };
}

sub cbreak {
    $term->setlflag($noecho);
    $term->setcc(VTIME, 1);
    $term->setattr($fd_stdin, TCSANOW);
}

sub normal {
    $term->setlflag($oterm);
    $term->setcc(VTIME, 0);
    $term->setattr($fd_stdin, TCSANOW);
}

#----------------------------------------------------------------------------#
#                                                                            #
#  modules                                                                   #
#     Determine which modules exist and die on required modules.             # 
#     Install required modules in a very specific case scenario.             #
#                                                                            #
#----------------------------------------------------------------------------#

#
# module_enabled
#    Determine if a module is enabled or not.
#
sub module_enabled
{
   my $txt = shift;

   if(!defined @state{"mod_$txt"} || @state{"mod_$txt"} == -1) {
      return 0;
   } else {
      return 1;
   }
 
}

#
# load_modules
#    There are probably a lot of better ways to do this, but the idea
#    is to provide a minor amount of help on those modules which are
#    required and allow the code to work around those which are not
#    required.
#
sub load_modules
{
   my $flag = shift;
   @state{modules} = [];
   my $type;

   for my $key (keys %mod) {
      if(!defined @state{"mod_@mod{$key}"} || @state{"mod_@mod{$key}"} == -1) {
         @state{"mod_$key"} = 1;

         if(defined @mod{$key}->{extra}) {
            eval "use $key ".@mod{$key}->{extra}.";1;" or @state{"mod_$key"}=-1;
         } else {
            eval "use $key; 1;" or @state{"mod_$key"} = -1;
         }

         if(@state{"mod_$key"} == -1) {
            if(@mod{$key}->{fatal} != -1) {
               if(@mod{$key}->{fatal}) {
                  $type = "FATAL";
                  @state{fatal} = 1;
               } else {
                  $type = "WARNING";
               }
               
               push(@{@state{modules}},sprintf("module %s is missing for %s.\n",
                    $key,@mod{$key}->{for}));
            }
         }
      }
   }
   
#   if($#{@state{modules}} >= 0) {
      for my $i (0 .. $#{@state{modules}}) {
         update_scroll_region("output") if $flag;
         printf("%s",@state{modules}->[$i]);
      }
#   }
   exit() if @state{fatal};
}

#
# install_modules
#    There's really no way to get this right as package names will probably
#    vary from distribution to distribution. This installer will probably
#    only get it right if its Linux and ubuntu? This doesn't prevent
#    from you installing the modules manually yourself.
#
sub install_modules
{
   my (%pkg, %cpan);
   load_modules(1);

   for my $key (keys %mod) {                             # look at all modules
      if(!module_enabled($key) && defined @mod{$key}->{pkg}) {
         @pkg{@mod{$key}->{pkg}} = 1;              # package defined, use that
      }
      if(!module_enabled($key) &&            # cpan modules defined, used that
         defined @mod{$key}->{cpan} && 
         @mod{$key}->{cpan} eq "yes") {
         @cpan{$key} = 1;
      }
   }

   if(scalar keys %pkg > 0) {                  # install the packages as root
      if(@ENV{PATH} =~ /termux/i) {
         printf("running: apt install %s\n",join(" ",keys %pkg));
         system(sprintf("apt install %s\n",join(" ",keys %pkg)));
      } else {
         printf("running: sudo apt install %s\n",join(" ",keys %pkg));
         system(sprintf("sudo apt install %s\n",join(" ",keys %pkg)));
      }
   }


   if(scalar keys %cpan > 0) {                # install cpan modules as user?
      for my $key (keys %cpan) {
         printf("running: perl -MCPAN -e \"install $key\"\n");
         system("perl -MCPAN -e \"install $key\"");
      }
   }

   exit();
}

#----------------------------------------------------------------------------#
#                                                                            #
#  ansi support                                                              #
#    Routines taken from teenymush. This should probably be turned into a    #
#    module if i liked using multiple files.                                 #
#                                                                            #
#----------------------------------------------------------------------------#
#
# ansi_debug
#    Convert an ansi string into something more readable.
#
sub ansi_debug
{
    my $txt = shift;

    $txt =~ s/\e/<ESC>/g;
    return $txt;
}


#
# ansi_char
#    Returns one character of the current string. Due to the nature of the
#    ansi functions, this will only return characters not in ansi character
#    strings. While this is silly to use a function to do this, this helps
#    abstract the data set for situations in which the ansi functions are
#    replaced by standard string functions.
#
sub ansi_char
{
   my ($data,$pos) = @_;

   return @{$$data{ch}}[$pos];
}


sub is_ansi_string
{
   my $txt = shift;

   if(ref($txt) ne "HASH" ||
      !defined $$txt{ch} ||
      !defined $$txt{snap} ||
      !defined $$txt{code}) {
      return 0;
   } else {
      return 1;
   }
}

#
# ansi_add
#   Add a character or escape code to the data array. Every add of a
#   character results in a new element, escape codes are added to existing
#   elements as long as a character has not been added yet. The ansi state
#   is also kept track of here.
#
sub ansi_add
{
   my ($data,$type,$txt) = @_;

   my $ch   = $$data{ch};                      # make things more readable
   my $code = $$data{code};
   my $snap = $$data{snap};

   if($#$ch == -1 || $$ch[$#$ch] ne undef) {
      $$ch[$#$ch+1] = undef;
      $$code[$#$ch] = [];
      $$snap[$#$ch] = [];
   }
   $txt =~ s/\a//g;

   if($type) {
     for my $c (split(//,$txt)) {                 # add multiple characters
        $$ch[ $#$ch + ((@$ch[$#$ch] ne undef) ? 1 : 0) ] = $c;
        @$code[$#$ch] = [] if(!defined @$code[$#$ch]);
        @$snap[$#$ch] = [ @{@$data{state}} ];
     }
   } else {                                           # add escape sequence
      push(@{$$code[$#$ch]},$txt);
      if($txt eq "\e[0m") {
         $$data{state} = [];
      } else {
         push(@{$$data{state}},$txt);
      }
   }
}


#
# ansi_init
#    Read in a string and convert it into a data structure that can be
#    easily parsed / modified, i hope.
#
#     {
#       code => [ [ array of arrays containing escape codes ] ]
#       ch   => [ Array containing each character one by one ]
#       snap => [ [ array of arrays containing all active escape codes
#                   at the time the character was encountered ] ]
#       state=> [ internal, current state of active escape does ]
#     }
#
sub ansi_init
{
   my $str = shift;
   my $digest;

   my $data = { ch => [], code => [], state  => [], snap   => [] };
#   $$data{trace} = code();

   if($str !~ /\e/) {                             # no ansi characters
      $$data{ch} = [ split(//,$str) ];
      return $data;
   } else {
      $$data{ch} = [];
   }
   while($str =~ /\e\[([\d;]*)([a-zA-Z])/) {
      $str = $';
      ansi_add($data,1,$`) if $` ne undef;
      ansi_add($data,0,"\e[$1$2");
   }
   ansi_add($data,1,$str) if($str ne undef);

   # reset state at end of line
   if($#{$$data{snap}->[$#{$$data{snap}}]} >= 0) {
      ansi_add($data,0,"\e[0m");
   }

   return $data;
}

#
# dearray
#    Take an array of ansi strings and convert them into txt with
#    the embeded escape sequences.
#
sub dearray
{
   my $data = shift;
   my $buf;

   for my $i (0 .. $#{$$data{ch}}) {
      $buf .= join('', @{@{$$data{code}}[$i]});
      $buf .= @{$$data{ch}}[$i];
   }
   return $buf;
}

#
# txt
#    Take a single ansi string or mutliple and conver them into
#    standard text.
sub txt
{
   my @data = @_;
   my @out;

   for my $i (0 .. $#data) {
      push(@out,dearray(@data[$i]));
   }
   return join('',@out);
}


#
# ansi_substr
#    Do a substr on a string while preserving the escape codes.
#
#    no-ansi flag : do not copy over escape sequences
#
sub ansi_substr
{
   my ($data,$start,$count,$noansi) = @_;
   my ($result,$i);

   $data = ansi_init($data) if(ref($data) ne "HASH");
   $start = 0 if($start !~ /^\s*\d+\s*$/);                 # sanity checks
   if($count !~ /^\s*\d+\s*$/) {
      $count = ansi_length($data);
   } else {
      $count += $start;
   }
   return undef if($start < 0);                         # no starting point

   my $new = { ch => [], code => [], state  => [], snap   => [] };
#   $$new{trace} = code();

   my $pos = 0;
   # copy each "character" w/attached ansi codes
   for($i = $start;$i < $count && $i <= $#{$$data{ch}};$i++) {
      # add each escape code one at a time
      $$new{code}->[$pos] = [];

      if(!$noansi) {
         if($i == $start) {
            # start of new str, snap codes need to be copied to "activated"
            for my $x (0 .. $#{$$data{snap}->[$i]}) {
               $$new{code}->[$pos]->[$x] = $$data{snap}->[$i]->[$x];
            }
         }
         for my $x (0 .. $#{$$data{code}->[$i]}) {            # active codes
            $$new{code}->[$pos]->[$#{$$new{code}->[$pos]}+1]
               = $$data{code}->[$i]->[$x];
         }

         for my $x (0 .. $#{$$data{snap}->[$i]}) {               # all codes
            $$new{snap}->[$pos]->[$x] = $$data{snap}->[$i]->[$x];
         }
      }
      # add the character that follows the escape code (if any)
      $$new{ch}->[$pos] = $$data{ch}->[$i];               # copy character
      $pos++;
   }

   # add ending clear of all attributes to prevent bleeding
   
   if($i >= 1 && $#{$$data{snap}->[$i-1]} != -1) {
      $$new{ch}->[$pos] = "";
      $$new{code}->[$pos] = [ chr(27) . "[0m" ];
      $$new{snap}->[$pos] = [];
   }

#   ansi_add($new,0,chr(27) . "[0m") if($#{$$data{snap}->[$i-1]} != -1);

   return $new;
}


#
# ansi_length
#    Return the length of a string without counting all those pesky escape
#    codes.

sub ansi_length
{
   my $txt = shift;
   my $data = shift;

   if(ref($txt) eq "HASH") {                           # already inited txt?
      $data = $txt;
   } else {
      return length(ansi_remove($txt));   # faster if  not in out ansi format?
   }

   if($#{$$data{ch}} == -1) {                                       # empty
      return 0;
   } elsif(@{$$data{ch}}[-1] eq undef) {               # last char pos empty?
      return $#{$$data{ch}};
   } else {
      return $#{$$data{ch}} + 1;                        # last char populated
   }
}
#
# ansi_remove
#    remove any escape codes from the string
#
sub ansi_remove
{
#   my $txt = ansi_init(shift);
#   return ansi_print($txt,0);

   my $txt = shift;
   $txt =~ s/\e\[[\d;]*[a-zA-Z]//g;
   return $txt;
}


#----------------------------------------------------------------------------#
#                                                                            #
#  tcp code                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

#
# BEGIN statement with including code, and most of socket_connect were
# copied from from: http://aspn.activestate.com/ASPN/Mail/Message/
# perl-win32-porters/1449297.
#
# BEGIN {
#    # This nonsense is needed in 5.6.1 and earlier -- I'm too lazy to
#    # test if it's been fixed in 5.8.0.
#    if( $^O eq 'MSWin32' ) {
#       *EWOULDBLOCK = sub () { 10035 };
#       *EINPROGRESS = sub () { 10036 };
#       *IO::Socket::blocking = sub {
#           my ($self, $blocking) = @_;
#           my $nonblocking = $blocking ? "0" : "1";
#           ioctl($self, 0x8004667e, $nonblocking);
#       };
#    } else {
#       require Errno;
#       import  Errno qw(EWOULDBLOCK EINPROGRESS);
#    }
# }

#
# handle_login
#    Socket has finally? connected, determine if the user should be
#    connected or not
#
sub handle_login
{
   my $conn = shift;
   my $world = world($conn);

   # do_login - was /world -l used when connecting
   if(defined @socket{$world} &&
      defined @socket{$world}->{do_login} &&
      @socket{$world}->{do_login} &&
      defined @address{$world}->{user} &&
      defined @address{$world}->{pass}) {
      out($world,"connect %s %s",
          @address{$world}->{user},
          @address{$world}->{pass}
         );
   }
}

#
# world_encode
#    Return the encoding type for a specifed world. This is only needed
#    because encode() expects different encoding types then what the
#    standard user is expecting. Maybe this should just be a hash table.
#
sub world_encode
{
   my $w = world(shift);
 
   if(!defined @address{$w} || !defined @address{$w}->{decode}) {
      return "UTF-8";
   } elsif(@address{$w}->{decode} =~ /^\s*utf8\s*$/) {
      return "UTF-8";
   } elsif(@address{$w}->{decode} =~ /^\s*fansi\s*$/) {
      return "cp437";
   } elsif(@address{$w}->{decode} =~ /^\s*latin\s*$/) {
      return "iso-8859-1";
   } else {
     @address{$w}->{decode};
  }
}

#
# socket_connect
#    handle a connection to a world.
#
sub socket_connect
{
   my ($conn,$world,$host,$port,$ssl,$opt) =
      (shift,lc(shift),shift,shift,shift,shift);
   my $s;


   $opt = {} if $opt eq undef;
   if(defined @socket{$world} && @socket{$world}->{sock}) {
      echo($conn,"%% Already connected to %s",$world);
      return 0;
   }

   # initialize history buffer
   @history{$world} = [] if(!defined @history{$world});
 
   if(defined @socket{$world}) { # previous connection
      @socket{$world}->{host} = $host;        # update possible changed items
      @socket{$world}->{port} = $port;
      @socket{$world}->{do_login} = (defined $$opt{l}) ? 0 : 1,
   } else {
      # define connection with everything that is needed.
      @socket{$world} = { name                => $world,
                          host                => $host,
                          port                => $port,
                          more_count          => 0,
                          last_read           => -1,
                          history_pos         => -1,
                          history_pos_partial => -1,
                          created             => time(),
                          do_login            => (defined $$opt{l}) ? 0 : 1,
                        };
   }

   if(!defined @address{$world}->{decode}) {      # default to utf8 decoding.
       @address{$world}->{decode} = "UTF-8";
   }

   @socket{$world}->{pos} = ++@state{pos_sequence};
#   Monitor::monitor(@socket{$world}, "hash");

   
   if($ssl && !module_enabled("IO::Socket::SSL")) {
      echo($conn,"%% module IO::Socket::SSL is required for SSL ". 
                 "connections.");
      return 0;
   } elsif($ssl) {                                    # open ssl connection
      $s = IO::Socket::SSL->new( PeerAddr => $host,
                                 PeerPort => $port,
                                 Proto => 'tcp',
                                 SSL_use_cert => 0,
                                 SSL_verify_mode => 0,
                                );
   } else {                                             # non-ssl connection
      $s = IO::Socket::INET->new(Proto => 'tcp',
                                 Blocking => 0) ||
         return echo($conn,"%% Connect %s : Socket error : %s",$world,$!);

      my $iaddr = inet_aton(trim($host)) ||
         return echo($conn,"%% Connect %s : Unknown host '%s'",$world,$host);

      my $paddr = sockaddr_in($port,$iaddr);

      my $ret = connect($s,$paddr);

      if(!$ret && ! $!{EINPROGRESS}) {
         echo($conn,"%% Connect %s : Unable to connect",$world);
         return 0;
      }
   }

   if(!$s) {
      draw_bar();
      echo($conn,"%% Connection Failed.");
      return 0;
   }


   @socket{$world}->{sock} = $s;
   switch_world($conn,$world);

   $ws_server->{select_readable}->add( $s );

   @socket_lookup{$s} = $world;
   delete @socket{muddler};

   () = IO::Select->new($s)->can_write(.2)    # see if socket is pending
      or @socket{$world}->{socket_pending} = 1;

   if(defined @socket{$world}->{socket_pending} &&
      defined @socket{$world}->{socket_pending} == 1) {
      echo($conn,"%% Connection to %s started, connection is pending.",$world);
   } else {
      if(world_encode($world) eq "cp437") {
         fansi_detect_client($world);
      } else {
         handle_login($world);
      }
   }

   if(defined @socket{muddler}) {
      delete @socket{muddler};
      delete @history{muddler};
   }

   draw_bar();
   return 1;
}

#
# wc_init
#    Connect to the websocket server at the port defined in the command
#    line or default to localhost:9001.
#
sub wc_init
{
   my $gui = shift;
   my ($host,$port) = @_;

   if(defined @state{remote_address}) {
      if(@state{remote_address} =~ /^\s*([^:]+)\s*:\s*(\d+)\s*$/) {
         ($host,$port) = ($1,$2);
      } else {
         die("Invalid format to remote address, expected  --remote=host:port");
      }
    } else {
         ($host,$port) = ("127.0.0.1",9001);
    }

    $wc = IO::Socket::SSL->new(PeerAddr => $host,
                                  PeerPort => $port,
                                  Proto => 'tcp',
                                  SSL_startHandshake => 0,
                                     #($proto eq 'wss' ? 1 : 0),
                                  Blocking => 1) or
       err("Failed to connect to $host on port $port:  $@");

   $client = Protocol::WebSocket::Client->new(
       url => "ws://$host:$port");

   # setup handlers
   $client->on( write   => sub { wc_write(@_); } );
   $client->on( connect => sub { wc_connect(@_); } );
   $client->on( error   => sub { wc_error(@_); } );
   $client->on( read    => sub { wc_read(@_); } );

   # add connection to the listener
   $ws_server->{select_readable}->add($wc);

   # connect to the server
   $client->connect;
}

sub test_worlds
{
   load("muddler");
 
   for my $w (keys %address) {
      delete @address{$w}->{user};
      delete @address{$w}->{pass};
      socket_connect($w,
                     @address{$w}->{name},
                     @address{$w}->{host},
                     @address{$w}->{port},
                     (!defined @address{$w}->{ssl} ||
                      !@address{$w}->{ssl}) ? 0 : 1,
                    );
   }
}

#
# err
#    Save the error in the state variable. The END declarition will
#    then reset the terminal and show the messaqe afterwards.
#
sub err
{
   my $msg = shift;

   @state{err} = $msg;
   exit();
}

sub wc_write
{
   my ($client,$txt) = @_;

   syswrite($wc,$txt);
}

sub wc_connect
{
   my ($client,$txt) = @_;

   # the y size has 3 characters removed from it for better rendering,
   # but isn't needed when doing the internal client.. so remove the
   # fudge factor here by adding 3.
   wc_out("/web_size %s,%s\n",@state{size_x},@state{size_y}+3);

   if(defined @state{window_value}) {
      wc_out("/window socket=@state{window_value}\n");
   } else {
      wc_out("/key_ctl_l\n",@state{size_x},@state{size_y});
      wc_out("/focused\n");
   }
}

sub wc_error
{
   my ($client,$buf) = @_;

   LOGGIT("WC_ERROR: '%s'\n",$buf);
}

sub wc_out
{
   my ($fmt,@args) = @_;

   return if(!defined $client);
   $client->write(sprintf("t$fmt",@args));
}

sub wc_responce
{
   my ($fmt,@args) = @_;

   return if(!defined $client);
   $client->write(sprintf("r$fmt",@args));
}

sub wc_read
{
   my ($client,$buf) = @_;

   my $tmp=$buf;
   $tmp =~ s/\r|\n//g;
   if($buf =~ /^m\r\n/) {
      printf("%s\n",$');
   } elsif($buf =~ /^d\r\npassword$/) {
      if(defined @state{p_password}) {
         wc_out("%s\n",@state{p_password});
      } else {
         show_banner();
         draw_bar();
         echo("muddler","%s","%% Enter muddler session password:");
      }
   } elsif(defined @state{monitor_value}) {
      return;
   } elsif($buf =~ /^(d|\*)\r\n/) {
      clear_screen();
   } elsif($buf =~ /^t\r\n/) {
      echo_console("%s",$');
   } elsif($buf =~ /^r\r\n/) {
      my ( $id,$hash ) = undump($');
      @address{$id} = $hash;
      cmd_editor(world(),$id,1);
   } elsif($buf =~ /^b\r\n/) {
      @state{remote_bar} = $';
      @state{remote_bar} =~ s/ /_/g;
      draw_bar();
   } else {
      LOGGIT("Ignored: '%s'\n",$buf);
   }
}

sub is_enabled
{
    my $opt = shift;
 
    if(is_in($opt,"DO_SGA","DO_TTYPE","DO_NAWS","DO_ECHO","DONT_MXP",
             "DONT_MSP","WONT_MXP","WONT_MSP","WILL_SGA","WILL_TTYPE",
             "WILL_NAWS","WILL_ECHO")) {
       return 0;
    } else {
       return 0;
    }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  fansi support                                                             # 
#     8bit uses something similar to the code page cp437 to display text     #
#     based graphcis. Below are the functions that support those and         #
#     a special login handling.                                              #
#                                                                            #
#----------------------------------------------------------------------------#



#
# fansi_init
#    Load the cp437 table with a list of cp437 to unicode. This works
#    as an array because all the cp437 characters listed are sequential.
#
sub fansi_init
{
   @state{cp437} = [
       0x0000, 0x263a, 0x263b, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
       0x25d8, 0x0009, 0x25d9, 0x2642, 0x2640, 0x266a, 0x266b, 0x263c,
       0x25bA, 0x25c4, 0x2195, 0x203c, 0x00b6, 0x00a7, 0x25ac, 0x21a8,
       0x2191, 0x2193, 0x2192, 0x2190, 0x221f, 0x2194, 0x25b2, 0x25bc,
       0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
       0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
       0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
       0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
       0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
       0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
       0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
       0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
       0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
       0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
       0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
       0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x2302,
       0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0, 0x00e5, 0x00e7,
       0x00ea, 0x00eb, 0x00e8, 0x00ef, 0x00ee, 0x00ec, 0x00c4, 0x00c5,
       0x00c9, 0x00e6, 0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,
       0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5, 0x20a7, 0x0192,
       0x00e1, 0x00ed, 0x00f3, 0x00fa, 0x00f1, 0x00d1, 0x00aa, 0x00ba,
       0x00bf, 0x2310, 0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,
       0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
       0x2555, 0x2563, 0x2551, 0x2557, 0x255d, 0x255c, 0x255b, 0x2510,
       0x2514, 0x2534, 0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,
       0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256c, 0x2567,
       0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256b,
       0x256a, 0x2518, 0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,
       0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3, 0x00b5, 0x03c4,
       0x03a6, 0x0398, 0x03a9, 0x03b4, 0x221e, 0x03c6, 0x03b5, 0x2229,
       0x2261, 0x00b1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,
       0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2, 0x25a0, 0x00a0
   ];
}

#
# fansi_decode
#    cp437 doesn't seem to follow cp437 as far as perl is concerned.
#    This function uses the table in fansi_init() to convert the
#    text into unicode character by character. I'm not sure if this
#    is actually right but it seems to be how 8bit's web interface
#    works.
#
sub fansi_decode
{
    my ($w,$txt) = @_;
    my $out;

   for my $i (0 .. length($txt)) {
      if(is_in(ord(substr($txt,$i,1)),0,7,10,13,27)) {
         $out .= substr($txt,$i,1);
      } else {
         $out .= chr(@{@state{cp437}}[ord(substr($txt,$i,1))]);
      }
   }
   return $out;
}

#
# fansi_detect_client
#    Listen for the Detecting client string and then send the CLIENT
#    string. Muddler then needs to pause for a little bit to ensure
#    that the login screen is shown before connecting or the login.txt
#    does not get displayed.
sub fansi_detect_client
{
   my $w = shift;
   my $id = (scalar keys %def) + 1;

   @def{sprintf("fansi_06s",$id)} = {
       regexp  => "^Detecting client\.\.\.\$",
       world   => world($w),
       ttl     => 2,
       hits    => 1,
       created => time(),
       LOGIN   => 1,
       cmd     => "/send -w$w CLIENT WEBCLIENT2;" .
                  "/def -1 -w$w -t'*connect*' -s2 fl_$w\_login=/handle_login $w"
   };
}

#----------------------------------------------------------------------------#
#                                                                            #
#  General Stuff                                                             # 
#                                                                            #
#----------------------------------------------------------------------------#

sub telnet_ch_init
{
   delete @telnet_ch{keys %telnet_ch};

   @telnet_ch{normal} = 
      sub {
         my ($world,$ch) = @_;
        
         if($ch eq @state{IAC}) {
            return (undef, @state{IAC});
         } else {
            return $ch;
         }
      };

   @telnet_ch{@state{IAC}} =
      sub {
         my ($world,$ch) = @_;

         if($ch eq @state{IAC}) {
            return (@state{IAC}, 'normal');
         } elsif(is_in($ch,@state{DO},@state{DONT},@state{WILL},@state{WONT},
                 @state{SB})) {
            return (undef,$ch);
         } elsif($ch eq @state{NOP}) {                       # keep-a-live?
            return (undef, 'normal');
         } else {
            return (undef, 'normal');
         }
      };

   @telnet_ch{@state{DO}} =
      sub {
         my ($world,$opt, $mode) = @_;
 
         my $wopt = $options[ord($opt)] || ord($opt);
         if(is_enabled((@state{ord($mode)} || ord($mode)) . "_" .
             ($options[ord($opt)] || ord($opt)))) {
            if ($mode eq @state{DO})   { 
                out_noret($world,@state{IAC}.@state{WILL}.$opt);
            } elsif ($mode eq @state{DONT}) {
                out_noret($world,@state{IAC}.@state{WONT}.$opt);
            } elsif ($mode eq @state{WONT}) {
                out_noret($world,@state{IAC}.@state{DONT}.$opt);
            } elsif ($mode eq @state{WILL}) {
                out_noret($world,@state{IAC}.@state{DO}  .$opt);
            }
         } else {
            if ($mode eq @state{DONT}) {
               out_noret($world,@state{IAC}.@state{WILL}.$opt);
            } elsif ($mode eq @state{DO}) {
               out_noret($world,@state{IAC}.@state{WONT}.$opt);
            } elsif ($mode eq @state{WILL}) {
               out_noret($world,@state{IAC}.@state{DONT}.$opt);
            } elsif ($mode eq @state{WONT}) {
               out_noret($world,@state{IAC}.@state{DO}  .$opt);
            }
         }
         return (undef, 'normal');
      };

   @telnet_ch{@state{SB}} =
      sub {
         my ($world,$c) = @_;
         return (undef, 'sbiac') if $c eq @state{IAC};
         @state{telnet_sb_buffer} .= $c;
         return;
       };

   @telnet_ch{sbiac} =
       sub {
          my ($world,$c) = @_;

          if ($c eq @state{IAC}) {
              @state{telnet_sb_buffer} .= @state{IAC};
              return (undef, @state{SB});
          }

          if ($c eq @state{SE}) {
              _telnet_complex_callback(@state{telnet_sb_buffer});
              @state{telnet_sb_buffer} = '';
              return (undef, 'normal');
          }

          # IAC followed by something other than IAC and SE.. what??
          require Carp;
          Carp::croak "Invalid telnet stream: IAC SE ... IAC $c (chr ".chr($c).") ...";
      };
   $telnet_ch{@state{DONT}} = 
       $telnet_ch{@state{WILL}} = 
       $telnet_ch{@state{WONT}} =
       $telnet_ch{@state{DO}};
}

sub _parse
{
    my ($world,$in) = @_;
    my $out = '';

    # optimization: if we're in normal mode then we can quickly move all the
    # input up to the first IAC into the output buffer.
    if (@state{telnet_mode} eq 'normal') {
        # if there is no IAC then we can skip telnet entirely
        $in =~ s/^([^@state{IAC}]*)//o;
        return $1 if length $in == 0;
        $out = $1;
    }

    
    for my $c (split '', $in) {
        my ($o, $m) = $telnet_ch{@state{telnet_mode}}->
            ($world,$c, @state{telnet_mode});

        $out .= $o;
#        defined $o and $out .= $o;
        defined $m and @state{telnet_mode} = $m;
    }

    return $out;
}

sub socket_disconnect
{
   my $s = shift;

   $ws_server->{select_readable}->remove( $s );

   if(defined @socket_lookup{$s}) {
       delete @socket{@socket_lookup{$s}}->{sock};
       delete @socket_lookup{$s};
   } else {
      for my $key (keys %socket) {
         if(defined @socket{$key}->{sock} &&
            @socket{$key}->{sock} eq $s) {
            delete @socket{$key}->{sock};
            delete @socket_lookup{$key}
         }
      }
   }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  websocket support                                                         #
#    A mudding client with an http/websocket server? why not.                #
#                                                                            #
#----------------------------------------------------------------------------#

sub web
{
    return (@state{p_web} == 1) ? 1 : 0;
}

#
# server_hostname
#    lookup the hostname based upon the ip address
#
sub server_hostname
{
   my $sock = shift;
   my $ip = $sock->peerhost;                           # contains ip address

   my $name = gethostbyaddr(inet_aton($ip),AF_INET);

   if($name =~ /^\s*$/ || $name =~ /in-addr\.arpa$/) {
      return $ip;                            # last resort, return ip address
   } else {
      return $name;                                         # return hostname
   }
}


#
# remote
#    Determine if muddler is remotely 'viewing' a session or displaying
#    just information via another window. This should probably be two
#    different tests?
#
sub is_remote
{
   if((defined @state{remote} && @state{remote}) ||
      defined @state{window_value}) {
      return 1;
   } else {
      return 0;
   }
}

sub listener_init
{
   $ws_server->{select_readable}->add( \*STDIN );

   $fd_stdin = fileno(STDIN);

   $term     = POSIX::Termios->new();
   $term->getattr($fd_stdin);
   $oterm     = $term->getlflag();

   $echo     = ECHO | ECHOK | ICANON;
   $noecho   = $oterm & ~$echo;
}

sub ws_init
{
   my $conn = "muddler";
  
   # no websocket interface when using remote console
   return if is_remote();

   if(use_secure()) {
      $http_listen = IO::Socket::SSL->can_ipv6->new( LocalPort =>@state{p_port},
                                                     Listen    => 5,
                                                     Reuse     => 1,
                                                     timeout   => .1,
                                                   );
      if(!defined $http_listen) {
         echo($conn,"%% http server [Port:@state{p_port}] start failed: $!");
         return 0;
      }
      $ws_listen = IO::Socket::SSL->new(Listen             => 25,
                                        LocalPort          => @state{p_port}+1,
                                        Proto              => 'tcp',
                                        SSL_startHandshake => 0,
                                        SSL_cert_file      => @state{p_cert},
                                        SSL_key_file       => @state{p_key},
                                       );
      if(!defined $ws_listen) {
          $http_listen = undef;
          echo($conn,"%% websocket server [Port:@state{p_port}] start " .
               "failed: $!");
          return 0;
      }
      IO::Socket::Timeout->enable_timeouts_on($ws_listen);
      IO::Socket::Timeout->enable_timeouts_on($http_listen);
      $ws_listen->read_timeout(.5);
      $ws_listen->write_timeout(.5);
      $http_listen->read_timeout(.5);
      $http_listen->write_timeout(.5);

      $ctx = IO::Socket::SSL::SSL_Context->new(
          SSL_server => 1,
          SSL_cert_file => @state{p_cert},
          SSL_key_file  => @state{p_key},
          SSL_verify_mode => 0x00,  # SSL_VERIFY_PEER | 
                                    # SSL_VERIFY_FAIL_IF_NO_PEER_CERT
          ) or die "cannot create context: $SSL_ERROR";
      @state{secure} = 1;
   } else {
      $http_listen = IO::Socket::INET->new( LocalPort => @state{p_port},
                                            Listen    => 1,
                                            Reuse     => 1,
                                          );
      if(!defined $http_listen) {
         echo($conn,"%% http server [Port:@state{p_port}] start failed: $!");
         return 0;
      };
      $ws_listen = IO::Socket::INET->new( LocalPort => @state{p_port} + 1,
                                          Listen    => 1,
                                          Reuse     => 1,
                                        );
      if(!defined $ws_listen) {
          $http_listen = undef;
          echo($conn,"%% websocket server [Port:@state{p_port}] start " .
               "failed: $!");
          return 0;
      };
      @state{secure} = 0;
   }

#   $ws_server = Net::WebSocket::Server->new(
#      listen => $ws_listen,
#      tick_period => 1,
#      on_connect => sub { my( $serv, $conn ) = @_;
#                          $conn->on( ready =>      sub{ ws_login_screen(@_); },
#                                     utf8  =>      sub{ ws_process( @_, 0 ); },
#                                     disconnect => sub{ us_disconnect(@_);   },
#                                   );
#                        },
#      );
   @state{p_web} = 1;
   $ws_server->{select_readable}->add($ws_listen);
   $ws_server->{select_readable}->add($http_listen);
   $ws_server->{conns} = {};
   if(!console()) {
      printf("%% WEb enabled, connect via: http://localhost:@state{p_port}\n");
      printf("%%    Password: @state{p_password}\n");
   }
   return 1;
}

sub ws_disconnect
{
   my $conn = shift;
   my $sock;

   eval {             # don't know how to test if $conn{sock} is valid
      $sock = $conn->{sock};
      $ws_server->{select_readable}->remove( $sock );
      delete $ws_server->{conns}{$sock};
   };
   delete @ws{$conn};
   # $sock->close;
}

sub allowed
{
   my $ws = shift;

   if(defined @state{p_allow}) {
      for my $host (split(/,/,@state{p_allow})) {
         my $pat = glob2re($host);
         return 1 if(@ws{$ws}->{ip} =~ /$pat/i);
      }
   }
   return 0;
}

sub ws_login_screen
{
   my $ws = shift;
#   ws_echo($ws,"t",@state{version},1);

   if(defined @state{p_theme}) {
      ws_echo($ws,"d","theme @state{p_theme}",1);
   }

   if(allowed($ws)) {
      @ws{$ws}->{auth} = 1;
      echo($ws,"%% Allowed web connection from: %s",@ws{$ws}->{ip});
   } else {
      ws_echo($ws,"d","password",1);
   }
   
#   draw_screen();
}

#
# ws_echo
#    The send might crash if the websocket has disconnected the evals should
#    probably be removed once this is more stable. With that in mind,
#    currently crash will be treated as a disconnect.
#
sub ws_echo
{
   my ($ws, $type, $msg,$force) = @_;

   # only show something if authorized or those exceptions when logging in
   return if(!defined @ws{$ws} || (@ws{$ws}->{auth} eq 0 && !$force));

   # this might crash if the websocket dies, the evals should
   # probably be removed once this is more stable. With that in mind,
   # currently crash will be treated as a disconnect.

   if(defined @state{reverse_window} &&
      defined @state{reverse_window}->{$ws} &&
      $type ne "m") {
      return;
   }
   $msg =~ s/[\r\n]+$//;
   eval {
      $ws->send('',$type . "\r\n" . encode_utf8($msg));
   };
   if($@) {
      LOGGIT("FATALs: $@");
      ws_disconnect($ws);
   }
}

#
# server_address
#    lookup the hostname based upon the ip address
#
sub server_address
{
   my $sock = shift;
   my $ip = $sock->peerhost;                           # contains ip address

   my $name = gethostbyaddr(inet_aton($ip),AF_INET);

   if($name =~ /^\s*$/ || $name =~ /in-addr\.arpa$/) {
      return $ip;                            # last resort, return ip address
   } else {
      return $name;                                         # return hostname
   }
}


#
# io
#    Handle any input / output such as http, https, websockets, secure
#    websockets, and keyboard.
#
sub io
{
   my $buf;
   

   my ($sockets) = IO::Select->select($ws_server->{select_readable},
                                      $ws_server->{select_writeable},
                                      undef,
                                      1
                                     );

   for my $sock (@$sockets) {
      if($sock eq \*STDIN) {
         sysread($sock,$buf,1024);
         key_process($buf) if(console());
      } elsif(defined @socket_lookup{$sock}) {
         my $w = @socket_lookup{$sock};

         if(sysread($sock,$buf,10240) <= 0) {
            socket_disconnect($sock);                     # socket closed

            if(defined @socket{$w}->{socket_pending} == 1) {
               history($w,"% Connection timed out to ". name($w) . "-$sock");
            } else {
               history($w,"% Connection closed to ". name($w) . "-$sock");
            }
         } else {
            if(defined @socket{$w}->{socket_pending}) {
               delete @socket{$w}->{socket_pending};
               if(world_encode($w) eq "cp437") {
                  fansi_detect_client($w);
               } else {
                  handle_login($w);
               }
            }
            @socket{$w}->{last_recv} = time();

            if(module_enabled("Encode")) {
               if(world_encode($w) eq "cp437") {
                  @socket{$w}->{buf} .= fansi_decode($w,_parse($w,$buf));
               } else {
                  @socket{$w}->{buf} .= decode(world_encode($w),
                                               _parse($w,$buf)
                                              );
               }
           } else {
               @socket{$w}->{buf}.= _parse($w,$buf);
            }
   
            while(defined @socket{$w}->{sock} &&
                  @socket{$w}->{buf} =~ /\n/) {
                history($w,$`,1);
                @socket{$w}->{buf} = $';
             }
         }
      } elsif( $sock == $ws_listen ) {
         my $s = $ws_listen->accept or die("Couldn't accept connection");
         next unless $s;

         if(@state{secure}) {
             IO::Socket::SSL->start_SSL(
                 $s,
                 SSL_server    => 1,
                 SSL_reuse_ctx => $ctx,
             ) or do {
                LOGGIT("ssl handshake failed: $!,$SSL_ERROR");
                $s->close;
                return;
             };
         }

         my $conn = new Net::WebSocket::Server::Connection(
                    socket => $s, server => $ws_server);
   
         $ws_server->{conns}{$s} = { conn     => $conn,
                                     lastrecv => time,
                                     ip       => server_hostname($s)
                                   };
         $ws_server->{select_readable}->add( $s );
         $ws_server->{on_connect}($ws_server, $conn );
         @ws{$conn} = {};
         @ws{$conn}->{conn} = $conn;
         @ws{$conn}->{start} = time();
         @ws{$conn}->{auth} = 0;
         @ws{$conn}->{ip} = server_hostname($s);
         @ws{$conn}->{port} = @state{p_port} + 1;
         @ws{$conn}->{world} = @state{world};
         @ws{$conn}->{active} = 1;            # assume window/tab is active
      } elsif($sock == $http_listen) {
         my $s;
         eval {
            $s = $sock->accept;
         };
         next unless $s;           # wrong type of connection http to https?

         $s->autoflush(1);

         if(@state{secure}) {
             IO::Socket::SSL->start_SSL(
                 $s,
                 SSL_server    => 1,
                 SSL_reuse_ctx => $ctx,
             ) or do {
                LOGGIT("ssl handshake failed: $!,$SSL_ERROR");
                $s->close;
                return;
             };
         }
         $ws_server->{select_readable}->add($s);
         @http{$s} = { sock    => $s,
                       data    => {},
                       address => server_address($s)
                     };
      } elsif(defined @http{$sock}) {
         http_io($sock);
      } elsif( $ws_server->{watch_readable}{$sock} ) {
         $ws_server->{watch_readable}{$sock}{cb}( $ws_server , $sock );
      } elsif( $ws_server->{conns}{$sock} ) {
         my $connmeta = $ws_server->{conns}{$sock};
         $connmeta->{lastrecv} = time;
         $connmeta->{conn}->recv();
      } elsif(is_remote() && $sock == $wc) {
         if(sysread($sock,$buf,10240) <= 0) {
            err("%% Fatal : connection closed to remote muddler session");
         } else {
            $client->read($buf);
         }
      } else {
         LOGGIT("filehandle $sock became readable, but no handler took " .
              "responsibility for it; removing it");
         LOGGIT("listener: $ws_listen");
         $ws_server->{select_readable}->remove( $sock );
      }
   }
}


sub http_data_init
{
   my ($end,$pos);
   my ($fn,$src);

   delete @http_data{keys %http_data};
   # PAR archive will have the PAR_0 environment variable set
   if(@ENV{PAR_0}) {                              # read data from data segment
      return if defined @state{par_http_data_init};
      $src = do { local $/; <main::DATA> };          # note: will not change
      @state{par_http_data_init} = 1;
   } else {
      open($fn,$0) || return;                                 # read from file
      $src = do { local $/; <$fn> };                # which lets file change
      close($fn);
   }

   for my $line (split(/\n/,$src)) {
      s/\r//g;
      if($line =~ /^START: (.*)\s*$/) {
         ($pos,$end) = ($1,"__$2__");
      } elsif($pos ne undef) {
         s/^   //;
         @http_data{$pos} .= $line . "\n";
      }
   }
}

sub http_io
{
   my $sock = shift;
   my $buf;

   return http_disconnect($sock) if(!defined @http{$sock});
   @http{$sock}->{data} = {} if(!defined @http{$sock}->{data});
   my $data = @http{$sock}->{data};

   if(sysread($sock,$buf,1024) <= 0) {
      http_disconnect($sock);
   } else {
      $buf =~ s/\r//g;
      @http{$sock}->{buf} .= $buf;

      while(defined @http{$sock} && @http{$sock}->{buf} =~ /\n/) {
         @http{$sock}->{buf} = $';
         http_process_line($sock,$`);
      }
   }
}

sub http_timestamp
{
   my $seconds = shift;

   my @day = ("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
   my @month = ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
   my @list = gmtime($seconds);

   return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
                  @day[@list[6]],
                  @list[3],
                  @month[@list[4]], @list[5] + 1900,
                  @list[2],
                  @list[1],
                  @list[0]);
}

sub http_disconnect
{
   my $sock = shift;
   $ws_server->{select_readable}->remove($sock);
   delete @http{$sock};
   $sock->close;
}


#
# http_process_line
#    Handle enough of HTTP's header data to make things work.
#
sub http_process_line
{
   my ($sock,$txt) = @_;

   return http_disconnect($sock) if(!defined @http{$sock});
   @http{$sock}->{data} = {} if(!defined @http{$sock}->{data});
   my $data = @http{$sock}->{data};

   if($txt =~ /^GET (.*) HTTP\/([\d\.]+)$/i) {              # record details
      $$data{get} = $1;
   } elsif($txt =~ /^([\w\-]+): /) {
      http_error($sock,"%s","POST REQUEST TO BIG") if($' > 4096);
      $$data{"VAR_" . lc($1)} = $';
   } elsif($txt =~ /^\s*$/ && defined $$data{get}) {         # end of request
      $$data{get} =~ s/\// /g;
      $$data{get} =~ s/^\s+|\s+$//g;

      # initial request of no path or an m and/or d (mobile or dark)
      if($$data{get} eq undef || $$data{get} =~ /^([m|d]{1,2})$/) {
         my $tmp = @http_data{"muddler_client.html"};
         my $port = @state{p_port} + 1;
         $tmp =~ s/__PORT__/$port/;

         # turn comment into the enabling of the mobile "interface"
         if($$data{get} =~ /m/) {
            $tmp =~ s/\/\/ ENABLE_MOBILE/input.onEnter('\/mobile');/
         }
         if($$data{get} =~ /d/) {
            $tmp =~ s/\/\/ ENABLE_DARK/input.onEnter('\/set theme=dark');/
         }

         $$data{get} = "muddler_client.html"; # used to determine mime type
         http_reply($sock,$data,"%s",$tmp);
      } elsif(!defined @http_data{$$data{get}}) {           # invalid page
         http_error($sock,"%s","Invalid path");
      } else {
         http_reply($sock,$data,"%s",@http_data{$$data{get}});
      }
   } else {
      http_error($sock,"Malformed Request");
   }
}

#
# http_error
#    Something has gone wrong, inform the broswer.
#
sub http_error
{
   my ($s,$fmt,@args) = @_;

   #
   # show the invalid page responce
   #
   http_out($s,"HTTP/1.1 404 Not Found");
   http_out($s,"Date: %s",scalar localtime());
   http_out($s,"Last-Modified: %s",http_timestamp());
   http_out($s,"Connection: close");
   http_out($s,"Content-Type: text/html; charset=ISO-8859-1");
   http_out($s,"");
   http_out($s,"<html><meta name=\"viewport\" content=\"initial-scale=.5, ".
            "maximum-scale=1\">");
   http_out($s,"<style>");
   http_out($s,".big {");
   http_out($s,"   line-height: .7;");
   http_out($s,"   margin-bottom: 0px;");
   http_out($s,"   font-size: 100pt;");
   http_out($s,"   color: hsl(0,100%,30%);");
   http_out($s,"}");
   http_out($s,"div.big2 {");
#   http_out($s,"   border: 2px solid red;");
   http_out($s,"   line-height: .2;");
   http_out($s,"   display:inline-block;");
   http_out($s,"   -webkit-transform:scale(2,1); /* Safari and Chrome */");
   http_out($s,"   -moz-transform:scale(2,1); /* Firefox */");
   http_out($s,"   -ms-transform:scale(2,1); /* IE 9 */");
   http_out($s,"   -o-transform:scale(2,1); /* Opera */");
   http_out($s,"   transform:scale(2,1); /* W3C */");
   http_out($s,"}");
   http_out($s,"</style>");
   http_out($s,"<body>");
   http_out($s,"<br>");
   http_out($s,"<table width=100%>");
   http_out($s,"   <tr>");
   http_out($s,"      <td width=30px>");
   http_out($s,"         <div class=\"big\">404</div><br>");
   http_out($s,"         <center>");
   http_out($s,"            <div class=\"big2\">Page not found</div>");
   http_out($s,"         </center>");
   http_out($s,"      </td>");
   http_out($s,"      <td width=30px>");
   http_out($s,"      </td>");
   http_out($s,"      <td>");
   http_out($s,"         <center><hr size=2>$fmt<hr></center>",@args);
   http_out($s,"         <pre>%s</pre>\n",code("long"));
   http_out($s,"      </td>");
   http_out($s,"      </td>");
   http_out($s,"      <td width=30px>");
   http_out($s,"      </td>");
   http_out($s,"   </tr>");
   http_out($s,"</table>");
   http_out($s,"</body>");
   http_out($s,"</html>");
   http_disconnect($s);
}

#
# http_out
#     Send something out to an http socket if its still connected.
#
sub http_out
{
   my ($sock,$fmt,@args) = @_;

   if(defined @http{$sock}) {
      printf({@{@http{$sock}}{sock}} "$fmt\r\n", @args);
   }
}


#
# http_reply_simple
#     A simple http reply with no evaluation.
#
sub http_reply
{
   my ($s,$data,$fmt,@args) = @_;
   my $type = "text/text";

   my $msg = sprintf($fmt,@args);
   http_out($s,"HTTP/1.1 200 Default Request");
   http_out($s,"Date: %s",http_timestamp(time()));
   http_out($s,"Last-Modified: %s",http_timestamp(time()));
   if(ref($data) eq "HASH") {
      if($$data{get} =~ /.js$/) {
         $type = "text/javascript";
      } elsif($$data{get} =~ /.html$/) {
         $type = "text/html";
      } elsif($$data{get} =~ /.css$/) {
         $type = "text/css";
      } 
   }
   http_out($s,"Content-Type: %s; charset=ISO-8859-1",$type);
   http_out($s,"Content-Length: %s",length($msg));
   http_out($s,"Connection: close");
   http_out($s,"");
   printf({@{@http{$s}}{sock}} "%s",$msg);
   http_disconnect($s);
}

#
# ws_process
#    A message has come in via the websocket, hand it off to the MUSH
#    via the server_proces_line() function. The websocket client sends
#    a flag via the first character (text, html, and publeo, etc).
#    Currently, that flag is just being stripped and ignored. Maybe
#    later?
#
sub ws_process
{
   my( $conn, $msg, $ssl ) = @_;
   $msg =~ s/\r|\n//g;

   $ssl = $ssl ? ',SSL' : '';

   my $input = substr($msg,1);
   return if !defined @ws{$conn};

   # if unathorized check password before allowing any input. Websize
   # is sent on connect, so exclude that.
   if((!defined @ws{$conn} || @ws{$conn}->{auth} eq 0) &&
           $input !~ /^\/(version|web_size|focused|blured|key_ctl_l|monitor|window|mobile)/) {
      if($input eq @state{p_password}) {
         @ws{$conn}->{auth} = 1;
         draw_screen($conn);
         ws_echo($conn,"t","%% Password validated.") if (no_world());
         echo($conn,
              "%% Authenticated web connection from: %s",
              @ws{$conn}->{ip}
             );
      } else {
         ws_echo($conn,"t","%% Invalid Password.",1);
         echo($conn,"%% Failed web connect from: %s",@ws{$conn}->{ip});
         ws_disconnect($conn);
      }
   } elsif(do_cmd(world($conn),$input,$conn)) {
      # do_cmd runs the command.
   } elsif(no_world()) {
     # do nothing
   } elsif(defined @socket{world($conn)} && 
           defined @socket{world($conn)}->{sock}) {
      out(world($conn),"%s",$input);
   }
#   unshift(@input,@state{line});                        # store keyboard history
}

sub ws_all
{
   my ($type,$txt) = @_;

   return if !web();
   my $hash = $ws_server->{conns};

   for my $key ( keys %$hash) {
      my $client = $$hash{$key}->{conn};
      next if(@ws{$client}->{auth} eq 0);

      eval {
          ws_echo($client,$type,$txt);
      };
      if($@) {
         ws_disconnect($client);
      }
   }
}

sub lord
{
   my $txt = shift;
   my @result;
#   $txt =~ s/\e/<ESC>/g;
#   return $txt;

   for my $i (0 .. (length($txt)-1)) {
      push(@result,ord(substr($txt,$i,1)));
   }
   return join(',',@result);
}


sub echo_wrap
{
   my $txt = shift;

   if(console()) {
      for my $line (ansi_wrap($txt)) {
         echo_console("%s",txt($line));
      }
   }
   if(web()) {
      my $hash = $ws_server->{conns};
   
      for my $key ( keys %$hash) {            # cycle all websocket connections
         my $c = $$hash{$key}->{conn};
         next if(@ws{$c}->{auth} eq 0);
   
         # get width of the websocket session, or default to console
         my $y=(defined @ws{$c}->{size_y}) ? @ws{$c}->{size_y} : @state{size_y}; 
   
         eval {                                   # protect against the unknown
            if($txt eq undef) {
               ws_echo($c,'t',$txt);
            } else {
               for my $line (ansi_wrap($txt,$y)) {
                  ws_echo($c,"t",txt($line));
               }
            }
         };
         if($@) {                                         # error, disconnect
            ws_disconnect($c);
         }
      }
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  console code                                                              #
#                                                                            #
#----------------------------------------------------------------------------#

sub console
{
   return @state{console};
}

#
# in_hist
#    Is the current world reviewing the history buffer?
#
sub in_hist
{
   my $w = world(shift);

   if(no_world() || !defined @socket{$w}) {
      return 0;
   } elsif(defined @socket{$w}->{hist_pos}) {
      return 1;
   } else {
      return 0;
   }
}

#
# hist_pos
#    Return if the history buffer position, set it, or delete it.
#
sub hist_pos
{
   my ($w,$action,$offset) = @_;

   $w = @state{world} if $w eq undef;
   if(no_world()) {
      return;
   } elsif($action eq "delete") {
      delete @socket{$w}->{hist_pos};
      delete @socket{$w}->{hist_offset};
   } elsif($action ne undef) {
      if($action > 0) {                # don't rollpast begining of history
         @socket{$w}->{hist_pos} = $action;
         @socket{$w}->{hist_offset} += $offset;
         if(@socket{$w}->{hist_offset} == 0) {
            delete @socket{$w}->{hist_offset};
            delete @socket{$w}->{hist_pos};
         }
      }
   } elsif(defined @socket{$w}) {
      return @socket{$w}->{hist_pos};
   }
}


sub pending
{
   my $w = shift;
   my $flag = shift;

   
   return undef if $w eq undef;

   if(!defined @pending{$w}) {
      return 0;
   } elsif(!defined @socket{$w}) {
      return $#{@pending{$w}} + 1;
   } elsif(in_more($w)) {
      return @socket{$w}->{pending};
   } else {
      return 0;
   }
}

sub history_pos
{
   my ($w,$value) = @_;

   if($value ne undef) {
      #loggit("history_pos: set $w -> $value %s",code("shortest"));
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{history_pos} = $value;
      @socket{$w}->{history_pos_partial} = -1;
   } else {
      $w = @state{world} if($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{history_pos}) {
         #loggit("history_pos: here");
         return @socket{$w}->{history_pos};
      }
   }
   return undef;
}

sub history_pos_partial
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{history_pos_partial} = $value;
   } else { 
      $w = @state{world} if ($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{history_pos_partial}) {
         return @socket{$w}->{history_pos_partial};
      }
   }
   return undef;
}


sub hist_pos_partial
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{hist_pos_partial} = $value;
   } else { 
      $w = @state{world} if ($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{hist_pos_partial}) {
         return @socket{$w}->{hist_pos_partial};
      }
   }
   return undef;
}

sub history_max
{
   my $w = shift;

   if($w ne undef && defined @history{$w}) {
      return $#{@history{$w}};
   } else {
      return undef;
   }
}

#
# no_world
#   test to see if no worlds have been opened yet.
#
sub no_world
{
   return (!defined @state{world} || @state{world} eq undef) ? 1 : 0;
}

#
# reset_more
#    Reset the more count so more doesn't turn
#
sub reset_more
{
   my ($conn,$force) = @_;
   my $w = world($conn);

   if(defined @socket{$w} && ($force || !in_more($w))) {
      @socket{$w}->{more_cnt} = 0;
   }
}

#
# echo
#   This should be replaced with history() since history() now properly
#   handles internal messages (or at lease my thoughts on it).
sub echo
{
   my ($world,$fmt,@args) = @_;

   # an internal command has been issued and that command results in output.
   # reset the more counter but only once.
   history($world,sprintf($fmt,@args));
}

sub e
{
   my ($conn,$fmt,@args) = @_;

   if(is_web($conn)) {
      ws_echo($conn,"t",sprintf("%s",@args));
   } else {
      echo_console($fmt,@args);
   }
}

#
# echo_console
#    Echo output to the console. If there is pending output or we're in the
#    history buffer, through the output into the pending queue.
#
sub echo_console
{
   my $fmt = shift;

   my $msg = sprintf("$fmt",@_);
 
   return if(!console());

   if(@state{optimize_output} <= 1) { 
      update_scroll_region("output");
      xy(output_end(),1);
      @state{optimize_output} = 2 if(@state{optimize_output} == 1);
   }

   printf("\n%s",$msg);

   if(@state{optimize_output} == 0) {
      update_scroll_region("input");
      xy(input_x(),input_y());
   }
}


sub enabled
{
   my $txt = shift;

   if(defined @state{$txt} && @state{$txt} =~ /^\s*(1|true|on|x)\s*$/i) {
      return 1;
   } else {
      return 0;
   }
}


#
# recent
#   Scan through the most recent output from the world and determine how
#   many lines have happened in $howlong seconds. This is used by to determine
#   if more should be turned on.
#
sub recent
{
   my ($w,$howlong) = @_;
   my $count = 0;

   return undef if(!defined @history{$w});

   my $array = @history{$w};

   for(my $i = $#$array;$i >= 0 && time() - $$array[$i]->{ts};$i--) {
      # always count original to make counting easier but not gagged.
      # In the situation of a text being replaced, we technically we should
      # count just the modifed version but then you have figure out how to
      # count the original version when not modified. Gagged output should
      # never be "original".
      if(!$$array[$i]->{gagged} && $$array[$i]->{original}) {
         $count++;
      }
   }
   return $count;
}

#
# 
# remove_nospoof
#    This should be replaced by something more generic. Currently it is
#    being used to remove the nospoof flag output by mushes.
#
sub remove_nospoof
{
   my $str = shift;

   return if(!@state{p_nospoof} || $$str{internal});

   if($$str{txt}=~ /^\[([^\]]+)\(([^\]]+)\)([^\]]*)\] / ||
      $$str{txt} =~ /^\[([^:]+):\] /)  {
      $$str{original} = $$str{txt};
      $$str{txt} = $';
   }
}

#
# send_to_window
#   Determine if the string should be sent to a window and do some light
#   housework.
#
sub send_to_window
{
   my ($w,$txt) = @_;

   return if($$txt{gagged} || $$txt{internal});    # gagged/internal, ignored

   if(defined @state{window} && ref(@state{window}) eq "HASH") {
      for my $id (keys %{@state{window}}) {
         my $window = @state{window}->{$id};
         if(!defined $$window{sock} && time() - $$window{created} > 60) {
            delete @state{window}->{$id};         #  connect took to long
         } elsif(defined $$window{sock} && !defined @ws{$$window{sock}}) {
            delete @state{window}->{$id};          # must have disconnected?
            ws_disconnect($$window{sock});
         } elsif(defined $$window{sock} && $$txt{txt} =~ /$$window{regexp}/i) {
            ws_echo($$window{sock},"m",
                    sprintf("%s %-7s | %s",
                            t(),
                            substr(world($w),0,7),
                            join("\n                 ",
                                 txt(ansi_wrap($$txt{txt},
                                 @ws{$$window{sock}}->{size_y} - 17))))
                    );
         }
      }
   }
}

sub displayable
{
   my $txt = shift;

   return 1 if ref($txt) ne "HASH";                             # bug?
#   return 0 if($$txt{gagged} || $$txt{internal} == 2);
   return 0 if($$txt{gagged} || $$txt{internal});
   return 1;
}

#
# gagged
#    Find output that is gagged and flag it as gagged.
#
sub gagged
{
   my ($w,$txt,$conn) = (shift,shift,shift);
   my ($match, $i,$count,$hit);

   # no defines, no need to search
#   return if scalar keys %def == 0;

   my $str = ansi_remove($$txt{txt});

   # handle watchdog matching. I.E.  Current line hits 2 of the last 5
   # lines for a total of 3 hits.
   if(TRUE(@state{p_watchdog}) && defined @history{$w}) {
      my $array = @history{$w};
      for(my ($i,$c)=($#$array-1,0);$c < 5 && $i >= 0 && $hit < 3;$i--) {
         if(displayable($$array[$i])) {
            $c++;
            if($str eq ansi_remove($$array[$i]->{txt})) {
               $hit++;
               if($hit >= 3) {
                  @def{sprintf("w_%06s",(scalar keys %def)+1)} = {
                       atr    => "g",
                       txt    => $str,
                       world  => world($w),
                       match => "exact"
                     };
               }
            }
         }
      }
   }

   # this mush duplicates messages in a particular room to the public
   # channel. This will remove the dups as long as the non-public
   # channel text comes first.
   if($w eq "n" && $#{@history{$w}} > 1) {
      my $prev = ansi_remove(@history{$w}->[-2]->{txt});
      if( $str eq "<Pub> $prev" ||                   # pub/non dup message
          ($str =~ /^<Pub> / && $str eq $prev) ||        # dup pub message
                                    # match your dups via say & pub channel
         ($str =~ /says, "(.*)"$/ && $prev eq "You say, \"$1\"")) {
         $$txt{gagged} = 1;
         delete @$txt{wrapped};
         delete @$txt{stat};
         delete @$txt{size};
         return 1;
      }
   }
    
   # handle /def defined gags
   if(!$$txt{internal}) {                         # don't gag internal output
      for my $key (keys %def) {
         if(@def{$key}->{world} eq undef ||              # world not specified
            lc(@def{$key}->{world}) eq lc($w)) {               # world matches

            if($key =~ /^w_\d{6}$/ && defined @def{$key}->{txt}) { # watchdog
                if(TRUE(@state{p_watchdog}) && $str eq @def{$key}->{txt}) {
                   $$txt{gagged} = 1;
                   return 1;
                }
            } elsif(defined @def{$key}->{regexp} && 
                    (!defined @def{$key}->{status} ||
                    @def{$key}->{status} == 1)) {
               @def{$key}->{badregexp} = 0;
               eval {
                  $match = 1 if($str =~ /@def{$key}->{regexp}/);
                  @def{$key}->{badregexp} = 1;
               };

               if($match) {
                  if(@def{$key}->{atr} =~ /g/) {
                      $$txt{gagged} = 1;
                      $$txt{keepalive} = 1 if defined @def{$key}->{keepalive};
                  }
                  if(defined @def{$key}->{cmd}) {
                    for my $cmd (split(';',@def{$key}->{cmd})) {
                       do_cmd($w,$cmd,$conn);
                    }
                  }
                  if(defined @def{$key}->{hits}) {
                     @def{$key}->{hits}--;
                     delete @def{$key} if(@def{$key}->{hits} <= 0);
                  }
                  if(defined $$txt{gagged} && $$txt{gagged} == 1) {
                     return 1;
                  } else {
                     return 0;
                  }
               }
            }
         }
         if($key =~ /^w_\d+_\d+$/ &&
            (!defined @def{$key}->{created} ||
            time() - @def{$key}->{created} > 300)) {
            delete @def{$key};
         }
      }
   }

   return 0 if($str !~ /^#(\d+)# /);

   if($str =~                                      # request start
      /^#(\d+)# Request from ([^\(]+)\(#(\d+)\): fn=([^,]+), sz=(\d+)$/) {
      if(defined @socket{$w}->{fn}) {
         send_deny("User already has file transfer in progress");
      } else {
         # send_accept();
        
         echo($w,
              "%% File transfer of %s offered from %s(#%s).",
              $4,
              $2,
              $3
             );
         @socket{$w}->{ft} = { fn => $4,
                               id => $1,
                               dbref => $3,
                               name => $2,
                               size => $5,
                               data => [],
                               approved => 0
                             };
      }
      $$txt{gagged} = 1;
      return 1;
   } elsif($str =~ /^#(\d+)# file approved for download$/) {
      if(defined @socket{$w}->{ftsend} &&
         @socket{$w}->{ftsend}->{id} == $1) {
         @socket{$w}->{ftsend}->{approved} = 1;
         echo($w,"%% File transfer offer approved by %s.",
              @socket{$w}->{ftsend}->{name}
             );
      }
   } elsif($str =~ /^#(\d+)# request complete$/) { # request end
      my $fn;
      if(defined @socket{$w}->{ft} && 
         $1 eq @socket{$w}->{ft}->{id} &&
         @socket{$w}->{ft}->{approved}) {
         if(!-e @socket{$w}->{ft}->{fn}) {
            $fn = @socket{$w}->{ft}->{fn};
         } elsif(!-e @socket{$w}->{ft}->{fn}.".".@socket{$w}->{ft}->{id}) {
            $fn = @socket{$w}->{ft}->{fn}.".".@socket{$w}->{ft}->{id};
         }

         if(!defined $fn) {
            echo($w,
                 "%% Could not save file as '%s' or '%s.%s' since they " .
                 "already exist",
                 @socket{$w}->{ft}->{fn},
                 @socket{$w}->{ft}->{fn} . "." . @socket{$w}->{ft}->{id}
                );
         } elsif(!open(FILE,"> $fn")) {
            echo($w,"%% File '%s' could not be opened for writing.",$fn);
         } else {
            printf(FILE "%s",
              decode_base64(join("\n",@{@socket{$w}->{ft}->{data}})));
            close(FILE);
            echo($w,
                 "%% File downloaded as %s from %s(#%s).",
                 $fn,
                 @socket{$w}->{ft}->{name},
                 @socket{$w}->{ft}->{dbref},
                );
             system("firefox $fn 2>&1 /dev/null &");
         }
      }
      $$txt{gagged} = 1;
      return 1;
   } elsif($str =~ /^#(\d+)# ([A-Za-z0-9\/=\+]+)$/) {       # request data
      if(defined @socket{$w}->{ft} && 
         $1 eq @socket{$w}->{ft}->{id} &&
         @socket{$w}->{ft}->{approved}) {
         push(@{@socket{$w}->{ft}->{data}},$2);
      }
      $$txt{gagged} = 1;
      return 1;
   }

   $$txt{gagged} = 1;
   return 1;
}

#
# history
#    add a line of input into the history queue
#
sub history
{
   my ($conn,$txt,$mud) = @_;
   $txt =~ s/\r//g;

   my $world = world($conn);

   if(@state{cmd_reset_more}) {
      reset_more($world,1);
      delete @state{cmd_reset_more};
   }
   @history{$world} = [] if !defined @history{$world};
   @pending{$world} = [] if !defined @pending{$world};

   my $str = { txt       =>  $txt,
               ts        => time(),
               gagged    => 0,                         # wiil line be gagged?
#              pend_code => code(),
               original  => undef,               # unmodified txt, if changed
               internal  => ($mud) ? 0 : 1,                 # internal output
               size      => @state{size_y},            # wrapped at this size
             };

   remove_nospoof($str);
   gagged($world,$str,$conn);                              # set gagged flag?

   if($$str{gagged}) {
      if(defined $$str{keepalive} && $$str{keepalive}) { # do not store keep
         undef($str);                                                # alive
      } else {
         push(@{@history{$world}},$str) && !$$str{keepalive};  # keep gagged
      }                                                # for possible review
   } else {

      $$str{wrapped} = [ ansi_wrap($$str{txt},@state{size_y}) ];
      $$str{stat} = [ @state{ansi_stat} ];
      update_pending($world,$#{$$str{wrapped}} + 1,$txt);

      send_to_window($world,$str);                    # handle /window stuff
      loggit_world($world,$txt) if($$str{internal} == 0);
      push(@{@pending{$world}},$str);
      release_some_pending($conn,$world);
   }

   draw_bar() if(!world_visible($world));
}

#
# echo_world
#    send the output to any console/websocket connection that is currently
#    on the world in question.
#
sub echo_world
{
   my ($world,$console,$web) = @_;

   if(@state{world} eq $world) {
      echo_console("%s",$console);
   } 

   my $hash = $ws_server->{conns};

   for my $key (keys %$hash) {
      my $c = $$hash{$key}->{conn};

      delete @ws{$c} if(defined @ws{$c} && ref(@ws{$c}) eq "");
      next if(!defined @ws{$c} || @ws{$c}->{auth} eq 0);
 
      if(@ws{$c}->{world} eq $world) {
         my $y=(defined @ws{$c}->{size_y}) ? @ws{$c}->{size_y}:@state{size_y}; 

         if($web eq undef) {
            ws_echo($c,"t");
         } else {
            for my $line (ansi_wrap($web,$y)) {
               ws_echo($c,"t",txt($line));
            }
         }
      }
   }
}

#
# world_visible
#   Determine if the world is currently being viewed by the console or
#   any websocket connection.
#
sub world_visible
{
   my $world = shift;

   if(console() && $world eq @state{world}) {
      return 1;
   } else {
      for my $key (keys %ws) {
         if(@ws{$key}->{world} eq $world && @ws{$key}->{active}) {
            return 1;
         }
      }
   }
   return 0;
}

#
# min_visible
#    determine the smallest visible window that is viewing the world,
#    as this is the size that should be catered too.
#
sub min_visible
{
   my $world = shift;
   my $min = 0;

   # console is on world, start with that.
   $min = output_end() if($world eq @state{world}); 

   for my $key (keys %ws) {                      # now try websocket clients
      if(ref(@ws{$key}) ne "HASH") {
         delete @ws{$key};
      } elsif(@ws{$key}->{world} eq $world && 
              (@ws{$key}->{size_x} < $min || 
              $min eq 0)
             ) {
         $min = @ws{$key}->{size_x};
      }
   }

   if($min < output_end() || $min eq undef) {
      return output_end();
   } else {
      return $min;
   }
}

#
# min_size
#    return the smallest x,y size of a window for a world
#
sub min_size
{
   my $w = world(shift);

   my ($x,$y) = (@state{size_x},@state{size_y});

   for my $key (keys %ws) {                      # now try websocket clients
      if(@ws{$key}->{world} eq $w) {
         if(defined @ws{$key}->{size_x} && @ws{$key}->{size_x} < $x) {
            $x = @ws{$key}->{size_x};
         }
         if(defined @ws{$key}->{size_y} && @ws{$key}->{size_y} < $y) {
            $y = @ws{$key}->{size_y};
         }
      }
   }
   return $x,$y;
}


#
# update_pending
#    Update the amount of lines that haven't been shown yet.
#
sub update_pending
{
   my ($conn,$count,$txt) = @_;
   my $w = world($conn);

#   my $act = calc_pending($w);
#   if(@socket{$w}->{pending} + $count != $act) {
#      loggit("More mismatch: %s + $count != $act: %s --> %s",
#             @socket{$w}->{pending},$count,code("shortest"));
#   }
   @socket{$w}->{pending} += $count if(defined @socket{$w});
#   loggit("update_pending: %s -> $count",@socket{$w}->{pending});
}

sub loggit_world
{
    my ($conn,$txt) = @_;
    my $w = world($conn);
    my $log;

    return if !@address{$w}->{log};

    if(!defined @state{"$w.log"}) {
       if(defined @address{$w}->{decode}) {
          open($log,">>:". world_encode($w), "$w.log") || return;
       } else {
          open($log,">> $w.log") || return;
       }
    } else {
       $log = @state{"$w.log"};
    }

    if($txt =~ /\e/) {
       printf($log "[%s] %s\n",ts(),txt(ansi_init($txt)));
    } else {
       printf($log "[%s] %s\n",ts(),$txt);
    }
}


#
# line_done
#    is the output line done as far as get_next_line is concerned.
#
sub line_done
{
   my $str = shift;

   if($$str{pos} > $#{$$str{wrapped}}) {
      return 1;
   } else {
      return 0;
   }
}

sub get_next_line
{
   my $w = shift;

   return undef if(!defined @pending{$w} || $#{@pending{$w}} < 0);

   my $str = @pending{$w}->[0];                        # short cut to string

   # correct for window size change
   if($$str{size} != @state{size_y}) {
      $$str{size} = @state{size_y};                                 # rewrap
      $$str{wrapped} = [ ansi_wrap($$str{txt},@state{size_y}) ];
      $$str{stat} = [ @state{ansi_stat} ];
      delete $$str{pos};                                 # start string over
   }

   if($#{$$str{wrapped}} == -1 && !defined $$str{pos}) {   # blank line fix
      $$str{pos} = 0;
      return {};
   }

   return undef if($$str{pos} > $#{$$str{wrapped}});       # string is done

   if($$str{pos} > $#{$$str{wrapped}}) {
      return undef;
   } else {
      update_pending($w,"-1");                   # update pending count
      return $$str{wrapped}->[$$str{pos}++];
   }
}

#
# in_more
#    Has the output been paused because to much has output has been
#    shown without user input.
#
sub in_more
{
   my ($conn,$debug,$add) = @_;
   my $w = world($conn);

   if(!defined @state{p_more} || !@state{p_more}) {
      return 0;
   } elsif(in_hist($w)) {    # in history buffer is just a version of more
      return 1;
   } elsif(!defined @socket{$w}) {
      return 0;
   } elsif(@socket{$w}->{more_cnt} >= min_visible($w)-overlap() &&
      $#{@pending{$w}} > -1) {
      return 1;
   } else {
      return 0;
   }
}

#
# line_cleanup
#
sub line_finish
{
   my ($w,$str) = @_;

   delete @pending{$w}->[0]->{wrapped};
   delete @pending{$w}->[0]->{stat};
   delete @pending{$w}->[0]->{size};
   delete @pending{$w}->[0]->{pos};

   if(not @pending{$w}->[0]->{internal}) {       # don't store internal msgs
      push(@{@history{$w}},@pending{$w}->[0]);
   }
      
   return shift(@{@pending{$w}});
}

#
# release_some_pending
#    Release some pending lines till the more promp kicks in.
#
sub release_some_pending
{
   my ($conn,$w) = @_;
   my (@out, @web, $result, $start,$end, @orig);

   if(!defined @socket{$w}
      || !defined @pending{$w}
      || $#{@pending{$w}} == -1
      || in_more($w) 
      || in_hist($w) 
      || !world_visible($w)) {
#       loggit("Skipping: $w [%s,%s,%s,%s]",$#{@pending{$w}},in_more($w),in_hist($w),world_visible($w));
       return 0;
   }

   my $str = @pending{$w}->[0];
   while(!in_more($w,0,1) && $#{@pending{$w}} > -1) {
      my $line = get_next_line($w);
      $start = $line if(!defined $start);
      if(!defined $line) {
         if($#orig == 0 && defined $start && $start != 0) {
            push(@orig,txt(ansi_substr(@pending{$w}->[0],$start)));
         } else {
            push(@orig,@pending{$w}->[0]->{txt});
         }
         $end = undef;

         line_finish($w);
      } else {
         push(@out,txt($line));
         if(defined @socket{$w}) {
            if(defined @socket{$w}->{more_cnt}) {
               @socket{$w}->{more_cnt}++;
            } else {
               @socket{$w}->{more_cnt} = 1;
            }
         }
         $end = $line->{end};
      }
   }

   if($#{@pending{$w}} > -1 && line_done(@pending{$w}->[0])) {
      line_finish($w);
   }
   # loggit("in_more_after: '%s'",in_more($w));

   if(defined $end && ansi_length(@pending{$w}->[0]) > $end) {
      push(@orig,txt(ansi_substr(@pending{$w}->[0],0,$end)));
   }

   if($#{@pending{$w}} == -1) {            # no pending left, set it to zero
      @socket{$w}->{pending} = 0;                             # just in case
      delete @state{activity}->{$w} if defined @state{activity}->{$w};
   }

   # no output generated and pending is empty. A call to release pending
   # must have been called with a previously finished line in it. Nothing
   # needs to be done.
   return 0 if($#out == -1 && $#{@pending{$w}});

   echo_world($w,join("\n",@out),join("\n",@orig));
   return $#out + 1;
   draw_bar();
}


sub line_pos
{
   if(defined @state{dialog} &&
      defined @state{dialog}->{dialog_x()}) {
      return @state{dialog}->{dialog_x()}->{line_pos};
   } else {
      return @state{line_pos};
   }
}

sub line_pos_set
{
   my $val = shift;

   if(defined @state{dialog} &&
      defined @state{dialog}->{dialog_x()}) {
      @state{dialog}->{dialog_x()}->{line_pos} = $val;
   } else {
      @state{line_pos} = $val;
   }
}

#
# return the X position of the input cursor
#
sub input_x
{
   my $offset = shift;

   if(in_dialog()) {
      if(dialog_x() > dialog_lines()) {          # jump down to cancel/save
         return input_start() + dialog_lines() + 2;
      } else {
         return input_start() + dialog_x() + dialog_input_offset();
      }
   } else {
      my $x = input_start() + 
              sprintf("%d",(@state{line_pos} - $offset -
                           ((@state{size_y} - 1) * @state{input_offset})) /
                           (@state{size_y} - 1));

      return ($x > @state{size_x}) ? @state{size_x} : $x;
   }
}

#
# return the Y position of the input cursor
#
sub input_y
{
   my $offset = shift;

   my $pos = 1 + ((line_pos() - $offset)%(@state{size_y} - 1));

   if(in_dialog()) {
      if(dialog_type() eq "check") {         # handle fixed position checkbox
         return 5;
      } elsif(dialog_type() =~ /^cycle\./) {
         return dialog_max() + 8;
      } elsif(dialog_x() > dialog_lines()) { # handle fixed position "buttons"
         return @state{dialog}->{bpos}->[dialog_x()-dialog_lines()-1];
      }
   }
   return ((in_dialog()) ? dialog_max() + 5 : 0) + $pos;
}

#
# output_end
#    The line number where the output region ends.
#
sub output_end
{
   my $w = shift;

   if(is_web($w)) {
      return @ws{$w}->{size_x} + 5;
   } else {
      return input_start() - 2;
   }
}


#
# wrap_garbage_collect
#    Look at the cache for wrapped lines and delete any wrapped text
#    that haven't been used in over 15 minutes.
#
sub wrap_garbage_collect
{
   my $count = 0;
   @state{cache} = {} if !defined @state{cache};
   my $cache = @state{cache};
   delete $$cache{del}; 
   for my $w (keys %$cache) {
      for my $id (keys %{$$cache{$w}}) {
         for my $y (keys %{$$cache{$w}->{$id}}) {
            if(time() - $$cache{$w}->{$id}->{$y}->{ts} > 900) {
               delete @$cache{$w}->{$id}->{$y};
            }
         }
         if(scalar keys %{$$cache{$w}->{$id}} == 0) {
            delete $$cache{$w}->{$id};
         }
      }
   }
}

#
# ansi_wrap
#    Wrap text appropriate for the client connected while keeping
#    ansi sequences out of the counting process.
#
sub ansi_wrap
{
   my ($str,$size_y) = @_;
   $size_y = @state{size_y} if(!defined $size_y);
   my ($break, $start, @result,@stat,$cbreak);

   $str = ansi_init(shift) if(ref($_[0]) ne "HASH");

   my $i = 0;
   my $start = 0;
   while($i < $#{@$str{ch}}) {
      if($$str{ch}->[$i] eq "\n") {
         push(@result,ansi_substr($str,$start,$i - $start));
         push(@stat,{start => $start, end => $i});
         @result[-1]->{start} = $start;
         @result[-1]->{end} = $i;
         ($break,$cbreak,$start) = (undef,undef,$i + 1);
      } elsif($i - $start >= $size_y - 1) {             # line too long, break
         if(defined $break && $i - $break < 30 && $$str{ch}->[$i] ne " ") {
            if($cbreak eq " ") {          # eat space when breaking on space
               push(@result,ansi_substr($str,$start,$break-$start-1));
               push(@stat,{ start => $start, end => $break - 1});
               @result[-1]->{start} = $start;
               @result[-1]->{end} = $break - 1;
               $start = $break;
            } else {                             # save the break character
               push(@result,ansi_substr($str,$start,$break-$start));
               push(@stat,{start=>$start, end => $break});
               @result[-1]->{start} = $start;
               @result[-1]->{end} = $break;
               $start = $break;
            }
         } elsif($$str{ch}->[$i] eq " ") {
            push(@result,ansi_substr($str,$start,$i-$start));
            @result[-1]->{start} = $start;
            @result[-1]->{end} = $i;
            push(@stat,{start => $start, end => $i});
            $start = $i + 1;
         } else {
            push(@result,ansi_substr($str,$start,$i-$start));
            push(@stat,{start => $start, end => $i});
            @result[-1]->{start} = $start;
            @result[-1]->{end} = $i;
            $start = $i + 1;
         }
         $break = undef;
         $cbreak = undef;
      } elsif(is_in($$str{ch}->[$i],"["," ",",","\\","/","-",".")) {
         $break = $i+1;
         $cbreak = $$str{ch}->[$i];
      }
      $i++;
   }

   # add left overs
   if($start <= $#{@$str{ch}}) {
      push(@result,ansi_substr($str,$start));
      @result[-1]->{start} = $start;
      @result[-1]->{end} = $#{@$str{ch}};
      push(@stat,{start => $start, end => $#{@$str{ch}} });
   }
   @state{ansi_stat} = @stat;
   return @result;
}

sub wrap_add
{
   my ($array,$str,$start,$end) = @_;

   push(@{$$array},{ txt => ansi_substr($str,$start,$end - $start),
                     start => $start,
                     end   => $end
                   }
       );
}
#
# ansi_wrap
#    Wrap text appropriate for the client connected while keeping
#    ansi sequences out of the counting process. 
#
sub ansi_stat_wrap
{
   my ($str,$size_y) = @_;
   $size_y = @state{size_y} if(!defined $size_y);
   my ($break, $start,$cbreak);
   my $result = [];

   $str = ansi_init(shift) if(ref($_[0]) ne "HASH");

   my $i = 0;
   while($i < $#{@$str{ch}}) {
      if($$str{ch}->[$i] eq "\n") {
         wrap_add($result,$str,$start,$i);
         ($break,$cbreak,$start) = (undef,undef,$i + 1);
      } elsif($i - $start >= $size_y - 1) {             # line too long, break
         if(defined $break && $i - $break < 30 && $$str{ch}->[$i] ne " ") {
            if($cbreak eq " ") {          # eat space when breaking on space
               wrap_add($result,$str,$start,$break-1);
               $start = $break;
            } else {                             # save the break character
               wrap_add($result,$str,$start,$break);
               $start = $break;
            }
         } elsif($$str{ch}->[$i] eq " ") {
            wrap_add($result,$str,$start,$i);
            $start = $i + 1;
         } else {
            wrap_add($result,$str,$start,$i);
            $start = $i + 1;
         }
         $break = undef;
         $cbreak = undef;
      } elsif(is_in($$str{ch}->[$i],"["," ",",","\\","/","-",".")) {
         $break = $i+1;
         $cbreak = $$str{ch}->[$i];
      }
      $i++;
   }

   # add left overs
   if($start <= $#{@$str{ch}}) {
      wrap_add($result,$str,$start,$#{$$str{ch}});
   }
   return @$result;
}


#
# overlap
#    shortcut to show how many lines should be overlapped so the user
#    can follow what happened.
#
sub overlap
{
   return @state{p_overlap};
}

sub history_location
{
   my $conn = shift;
   my $w = world($conn);

   if(in_hist($w)) {                              # determine starting point
      return hist_pos($w), hist_pos_partial($w);
   } 

   my ($pos,$off) = (history_pos($w),history_pos_partial($w));

   if($pos == -1 && defined @history{$w}) {
      return $#{@history{$w}},undef;
   }

   return $pos,$off;
}

#
# get_output
#    Find an appropriate number of lines of text to show in the output
#    region. Since text is wrapped this output could be different for
#    each client connected.
#
sub get_output
{
   my ($conn,$full) = @_;
   my ($start_pos,$partial,@out,@line,$x,$y,$max);

   if(is_console($conn)) {
      ($x,$y) = (@state{size_x},@state{size_y});
   } elsif(is_web($conn)) {
      ($x,$y) = (@ws{$conn}->{size_x},@ws{$conn}->{size_y});
   }

   my $w = world($conn);                                  # save some typing

   if(in_hist($w)) {                              # determine starting point
      $start_pos = hist_pos($w);
      $partial = hist_pos_partial($w);                    # start in history
   } else {
      $start_pos = history_pos($w);
      $partial = history_pos_partial($w);                   # regular output
   }

   my $hist = @history{$w};

   $max = $x - (($full) ? 0 : 3);
   for(my $i=$start_pos;
       $i >= 0 && $#out < $max && $i <= $#$hist;
       $i--) {
      next if $$hist[$i]->{gagged};
      next if $$hist[$i]->{internal} == 2;

      if($i == $start_pos) {                   # possible partial line at end
         @line=ansi_wrap(ansi_substr($$hist[$i]->{txt},0,$partial),$y);
      } else {
         @line=ansi_wrap($$hist[$i]->{txt},$y);  # full line, may not use all
      }

      if($#line == -1 && $#out +1 < $x) {    # blank line, fix in ansi_wrap?
         unshift(@out,{ pos => $i, txt => ""});
      } else {                                   # add each line if possible
         for my $y (reverse 0 .. $#line) {
            if($#out - 1 < $x) {
               unshift(@out,{ pos => $i, 
                              txt => txt(@line[$y])
                            }
                      );
            }
         }
      }
   }

   while($#out + 1 < $x) {
      unshift(@out,{ pos => -2, txt => "\033[K"});
   }

   return @out;
}

sub get_original_txt
{
   my ($w,$pos,$line) = @_;

   my $str = @history{$w}->[$pos];
   if(defined @history{$w}->[$pos]->{stat}) {
      my $stat = @history{$w}->[$pos]->{stat}->[$line];
      if(defined $$stat{end}) {
         return ansi_substr($$str{txt},$$stat{start},$$stat{end}-$$stat{start});
      } else {
         return ansi_substr($$str{txt},$$stat{start});
      }
   }
}

sub draw_output
{
   my $conn = shift;
   my $w = world($conn);

   if(is_console($conn)) {
      draw_output_world_new($conn,@_);
   }

   for my $s (keys %ws) { 
      draw_output_world_new(@ws{$s}->{conn}) if(@ws{$s}->{world} eq $w);
   }
}

sub draw_output_world_new
{
   my $conn = shift;
   my $w = current_world($conn);
   return if !defined @history{$w};
   my ($x,$y,$h,$cnt,@out)=(output_end($conn),size_y($conn),@history{$w});
   my ($off,$pos,$str);

   update_scroll_region("output") if(is_console($conn));

   if(in_hist($w)) {                               # history starting point
      $pos = hist_pos($w);
      $off = hist_pos_partial($w);
   } else {                                            # or end of history
      # release_some_pending($conn,$w);
      $pos = $#{@history{$w}};
      $off = @history{$w}->[$pos]->{offset} if(defined $$h[$pos]);
   }
   my $start = $pos;

   for(;$cnt <= $x && $pos >= 0;$pos--) {   # walk history
      if(!$$h[$pos]->{gagged} && $$h[$pos]->{internal} != 1) {  # skip?
         if($$h[$pos]->{txt} eq "") {                          # empty line hack
            unshift(@out,"");
            $cnt++;
         } else {                            # cycle wrapped line
            if($pos == $start && $off > 0) {               # handle offset
               $str = txt(ansi_substr($$h[$pos]->{txt},0,$off));
               $off = 0;
            } else {
               $str = $$h[$pos]->{txt};
            }
            for my $line (reverse ansi_wrap($str,$y)) {
               if($cnt > $x) {
                  last;
               } else {
                  unshift(@out,txt($line));
                  $cnt++;
               }
            }
         }
      }
   }

   while($cnt++ < $x) {                 # fill in blanks at top of screen
      unshift(@out,"");
   }
   # optimize_start();
   e($conn,"%s",join("\n",@out));
   # optimize_end();
}

#
# draw_input
#    Draw the input window which is where the user to composes whatever they
#    have to say. Replacing this with nothing would probably be a better
#    replacement as I probably shouldn't ever say what I do say.
#
sub draw_input
{
   my $conn = shift;

   return if(!console());

   if(is_console($conn) || is_remote()) {
      update_scroll_region("input");
      xy(input_start(),1,1);
      printf("\033[J");

      if(in_dialog()) {
         dialog_draw();
      } else {
         my $pos = @state{input_offset}+1;
         my $end = $pos + input_size() - 1;
         for my $i (input_start() .. input_end()) {
            if($pos <= $end) {                      # line $pos of typed input
               printf("%s\033[K%s",input_line($pos),
                  ($i != input_end()) ? "\n" : "");
            } else {            # blank line with return but not on last line
               printf("\033[K%s",($i != input_end()) ? "\n" : "");
            }
            $pos++;
         }
         xy(input_x(),input_y(),1);
      }
   }
}

sub draw_screen
{
   my ($conn,$flag) = @_;

   return if defined @state{monitor_value};
   my $clear = shift;

   return if(!console());
   printf("\033[r\033[2J") if(is_console($conn) && $clear);
   clear_screen($conn);
   draw_output($conn,$flag);
   draw_bar(1);
   draw_input($conn);
}

#
# good($var,$value)
#    determine if the value is a good positional value for the array $var
sub good
{
   return ($_[1] >= 0 && $_[1] <= $#{$_[0]}) ? 1 : 0;
}

#
# scroll_history
#    Scroll backwards/forwards in the history
#
sub scroll_history
{
   my ($conn,$inc) = @_;
   my ($pos,$sub,$cnt,$txt,$line,$start);
   my $cnt = 0;

   my $w = world($conn);
   my ($x,$y) = min_size($w);
   my $max = min_visible($w) - overlap();
   my ($pos,$off) = history_location($w);
   my $pos = hist_pos($w);
   my $off = hist_pos_partial($w);                    # start in history

   $pos = $#{@history{$w}} if(!defined $pos);
   

   my $h = @history{$w};
   while(good($h,$pos)) {                         # loop through history
      if(displayable($h->[$pos])) {                 # loop through string
         if($off > 0 && $inc == -1) {
            $txt = [ansi_wrap(txt(ansi_substr($$h[$pos]->{txt},0,$off)),$y)];
         } elsif($off > 0) {
            $txt = [ansi_wrap(txt(ansi_substr($$h[$pos]->{txt},$off)),$y)];
            $start = $off;
         } else {
            $txt = [ansi_wrap($$h[$pos]->{txt},$y)];
         }
         $line = ($inc == -1) ? $#$txt : 0;

         while(good($txt,$line)) {
            # loggit("# %s",txt($$txt[$line]));
            if(++$cnt >= $max + 1) {              # output buffer full, done
               hist_pos($w,$pos,$cnt * $inc);
               # hist_pos_partial($w,$off);
               hist_pos_partial($w,$start + $txt->[$line]->{end});
               draw_output($w,1);
               draw_bar($w);
               return 1;
            } else {
               $line += $inc;
            }
         }
      }
      $off = undef;
      $start = undef;
      $pos += $inc;
   }

   if($inc > 0) {                                 # at bottom of history
      hist_pos($w,"delete");
      draw_output($w,1);
      draw_bar($w);
   } else {
      hist_pos($w,$pos,$cnt * $inc);
      hist_pos_partial($w,undef);
   }
   return 0;
}


sub key_home
{
   my ($conn,$size) = @_;

   # reset input location to the begining
   @state{input_offset} = 0;
   line_pos_set(0);
   draw_input($conn);
}

#
# update_input_offset
#    Update the line_pos and then call this function to set the input_offset
#    to something appropriate
#
sub update_input_offset
{
   my $lines = sprintf("%d",@state{line_pos} / (@state{size_y}-1));
   $lines++ if(@state{line_pos} % (@state{size_y}-1) >= 0);
   $lines = 1 if $lines < 1;

   if($lines > input_end() - input_start() + 1) {
      @state{input_offset} = $lines - (input_end() - input_start() + 1);
   } else {
      delete @state{input_offset};
   }
}

sub key_end
{
   my ($conn,$size) = @_;

   my $input = input();
   line_pos_set($#{$$input[-1]}+1);
   update_input_offset() if(!in_dialog());
   draw_input($conn);
}

sub key_shift_up
{
  key_up(@_,1);
}

sub key_shift_down
{
  key_down(@_,1);
}

#
# key_pgup
#    Move up a screen full in the history. This will pause all output
#    as well.
#
sub key_pgup
{
#-# summary: Moves back into the history of the current world
   my ($conn,$size) = @_;
   my $count = -1;

   return wc_out("/key_pgup") if(is_remote());

   scroll_history($conn,-1);
}

#
# key_pgdn
#    Move a screen down in the history.
#
sub key_pgdn
{
#-# summary: Moves forward in the history of the current world
   my ($conn,$size) = @_;

   return wc_out("/key_pgdn") if(is_remote());

   my $w = world($conn);
   if(in_hist($w)) {
      scroll_history($conn,1);
   } else {
      reset_more($w,1);
      release_some_pending($conn,$w,1);
   }
}

sub print_state
{
   my $out;

   my %skip = (
      pos_sequence => 1,
      240 => 1,
      241 => 1,
      250 => 1,
      251 => 1,
      252 => 1,
      253 => 1,
      254 => 1,
      255 => 1,
      DO  => 1,
      DONT=> 1,
      IAC => 1,
      SB  => 1,
      SE  => 1,
      WILL=> 1,
      WONT=> 1,
      activity=> 1,
      ansi_wrap=> 1,
      cache => 1,
      chksum => 1,
      console => 1,
      ctl_c => 1,
      help => 1,
      key_last => 1,
      last_active => 1,
      pending =>1,
      pid =>1,
      region =>1,
      secure =>1,
      size_x =>1,
      size_y =>1,
      tick_last => 1,
      web => 1,
      world => 1,
      world_last => 1,
      wrap_garbage_collect_last => 1,
      nocache => 1,
      mush => 1,
      optimize_output => 1,
      cached => 1,
      ta => 1,
      spelling_error => 1,
      telnet_mode => 1,
#      hist_start => 1,
      state => 1,
      World_last => 1,
   );

   $out = sprintf("\@state = {\n");
   for my $key (sort keys %state) {
      if(ref(@state{$key}) eq undef && 
         !defined @skip{$key} &&
         $key !~ /^(mod|bar|p)_/) {
         $out .= sprintf("   %s = %s\n",$key,@state{$key});
      }
   }
   $out .= "}\n";
   my $input = input();
   for my $i (-1) {
      $out .= sprintf("%s : %s\n",$i,join('',@{$$input[$i]}));
   }
   $out .= sprintf("x/y: %s,%s\n",input_x(),input_y());
   return $out;
}


#
# key_dump
#   Write out the data in the history variable for debuging purposes.
#
sub key_dump
{
   my ($conn,$txt,$force) = @_;
   my $w = world($conn);

   my $input = input();
   for my $i (0 .. $#$input) {
      LOGGIT("$i : '%s'\n",join('',@{$$input[$i]}));
   }

   for my $i (0 .. $#{@history{$w}}) {
      LOGGIT("$i : %s",print_var(@history{$w}->[$i]));
   }
}


#
# key_ctl_p
#    Move down into the keyboard input history
#
sub key_ctl_p
{
#-# summary: Moves back one entry in the keyboard history.
   my ($conn,$txt) = @_;

   my $input = input();

   return if in_dialog();

   if(!defined @state{input_pos} || @state{input_pos} == -1) {  # first time
      if($#{$$input[-1]} >= 0) {            # store initial text if it exists
         push(@$input,[]);
         @state{input_pos} = $#$input - 1;
      } else {
         @state{input_pos} = $#$input;                 # no text, point to top
      }
   } elsif(@state{input_pos} <= 0) {
      @state{input_pos} = $#$input;                              # wrap around
   }

   @{$$input[-1]} = @{$$input[@state{input_pos} -1]};         # overwrite input

   # set offset so just the end of the line is shown if the whole line is
   # not visible.
   if(max_input() > input_size()) {
      @state{input_offset} = max_input() - input_size();
   } else {
      delete @state{input_offset};
   }
   @state{input_pos}--;
   line_pos_set($#{$$input[-1]} + 1);
   draw_input($conn);
}

#
# key_ctl_n
#    Move down in the keyboard input history
#
sub key_ctl_n
{
#-# summary: Moves forward one entry in the keyboard history.
   my ($conn,$txt) = @_;

   my $input = input();
   if(!defined @state{input_pos} || @state{input_pos} == -1) {  # first time
      push(@$input,[]) if($#{$$input[-1]} >= 0); # store initial text if exists
      @state{input_pos} = $#$input - 1;
   }

   if(@state{input_pos} == $#$input) {
      @state{input_pos} = 0;
   } elsif(defined $$input[@state{input_pos} + 1]) {
      @state{input_pos}++;
   }

   @{$$input[-1]} = @{$$input[@state{input_pos}]};           # overwrite input
   line_pos_set($#{$$input[-1]} + 1);

   # set offset so just the end of the line is shown if the whole line is
   # not visible.
   if(max_input() > input_size()) {
      @state{input_offset} = max_input() - input_size();
   } else {
      delete @state{input_offset};
   }
   draw_input($conn);
}

#
# key_ctl_R
#    Reload the code without typing in any commands.
#
sub key_ctl_r
{
#-# summary: Reloads the code for muddler if there are any changes
   my $conn = shift;

   @state{ansi_wrap} = 0;
   reload_code($conn);

   wc_out("/key_ctl_r\n") if(is_remote());
}

sub get_console_size
{
   # screen seems to have some sort of bug where it stop sending winch
   # signals after a month of use but yet GetTerminalSize is still returning
   # the correct size. So update the screen size when a control-l is done as
   # a "work around". This shouldn't cause an impact on cpu usage.
   if(module_enabled("Term::ReadKey")) {
      (@state{size_y},@state{size_x}) = GetTerminalSize();
   } else {
      (@state{size_x},@state{size_y}) = 
         `stty size`=~/(\d+)\s+(\d+)/?($1,$2):(80,25);
   }
}

#
# key_ctl_l
#    Redraw the screen.
#
sub key_ctl_l
{
#-# summary: Erases the screen and redraws it
   my ($conn,$txt) = @_;

   get_console_size();

   if(is_remote()) {
      wc_out("/web_size @state{size_x},@state{size_y}\n");
      draw_bar();
      draw_input($conn);
   } else {
      draw_screen($conn,1);
   }
}
   

sub key_shift_tab
{
   key_tab(@_,1);
}

#
# key_tab
#    Show the next screen full of data if more/history is enabled.
#
sub key_tab
{
#-# summary: Moves forward a screen full when more is enabled/triggered.
   my ($conn,$txt,$shift_down) = @_;

   my $w = world($conn);

   if(is_remote() && !in_dialog()) {
      return wc_out("/key_tab");
   } elsif(in_dialog() && !$shift_down) {
      if(dialog_lines() + dialog_buttons() -1 < dialog_x()) {
         dialog_x(1);
      } else {
         dialog_x(dialog_x() + 1);
      }
      xy(input_x(),input_y());
   } elsif($w eq undef || !defined @socket{$w}) {
      return;
   } elsif(in_hist($w)) {                      # same as key_pgdn, just call it
      key_pgdn(@_);
      release_some_pending($conn,$w,1) if(!in_hist($w));
   } elsif(in_more($w)) {
      key_pgdn(@_);
      reset_more($w,1);
      release_some_pending($conn,$w,1);
   }
}

# key_ctl_u
#    Clear keyboard input
#
sub key_ctl_u
{
#-# summary: Clears the keyboard input
   my ($conn,$txt) = @_;

   my $input = input();
   if(is_console($conn)) {
      $$input[-1] = [];
      line_pos_set(0);
      delete @state{input_offset};
      xy(input_x(),input_y());
      
      if(console()) {
         if(in_dialog()) {
            dialog_draw();
         } else {
            printf("\033[J");
         }
      }
   }
}

#
# key_ctl_w
#    Delete the last word before the cursor
#
sub key_ctl_w
{
#-# summary: Delete the last word before the cursor
   my $count = 0;
   my $i;

   my $input = input();
   # delete any initial spaces
   for($i = line_pos()-1;$i >= 0 && $$input[-1]->[$i] eq " ";$i--) {
      key_delete();
   }

   # delete any non-spaces after the spaces
   for(;$i >= 0 && $$input[-1]->[$i] ne " ";$i--) {
      key_delete();
   }
}


#
# key_escape
#    The escape key has been found. This could be part of a escape sequence
#    for something like an arrow key or something like escape-w. Signal the
#    escape has been found by setting the multikey variable for later use.
#
sub key_escape
{
   if(defined @state{multikey} && in_dialog()) {
      dialog_cancel();
   }
   @state{multikey} = [];
}

#
# key_esc_j
#    Jump to the end of the world buffer without displaying all the output
#    Output can still be done via history or /recall.
#
sub key_esc_j
{
#-# summary: Skip to the end of any "mored" output.
   my ($conn,$txt) = @_;
   my $w = world($conn);

   delete @socket{world($conn)}->{hist_pos};
   history_pos($conn,$#{@history{$conn}});
   update_pending(world($conn),@socket{world($conn)}->{pending} * -1);

   # populate @history with @pending data.
   while($#{@pending{$w}} > -1) {
      line_finish($w);
   }

   draw_screen($conn,1);
}

#
# out
#    send a message out to the world with some basic error checking
#
sub out
{
   my ($world,$fmt,@args) = @_;

   return if(defined @socket{socket_pending} && @socket{socket_pending} == 0);
   return if $world eq "muddler";

   $world = @state{world} if($world eq undef);
   if(defined @socket{$world} && defined @socket{$world}->{sock}) {
      my $msg = sprintf("$fmt",@args);
      $msg .= "\n" if($msg !~ /\n$/);               # add returns if needed.

      my $sock = @socket{$world}->{sock};
      # loggit("\nout[%s] %s [%s]",$world,$msg,code("short"));
      # loggit("out[%s] %s",$world,$msg);

      if(module_enabled("Encode")) {
         printf($sock "%s",encode(world_encode($world),$msg));
      } else {
         printf($sock "%s",$msg);
      }
      if(!defined @state{out_nomore}) {
         reset_more($world);
      } else {
         delete @state{out_nomore};
      }

      @socket{$world}->{connected} = 1 if ($msg =~ /^\s*connect/i);

      # keep track of last send time for sending keepalives
      @socket{$world}->{last_send} = time();
   }
}
   
sub out_noret
{
   my ($world,$fmt,@args) = @_;

   return;
   if(defined @socket{$world} && defined @socket{$world}->{sock}) {
      my $sock = @socket{$world}->{sock};
      printf($sock $fmt, @args);
      @socket{$world}->{last_send} = time();
   }
}


#
# key_return
#    The return key has been pressed, now what?
#
sub key_return
{
   my ($conn,$txt) = @_;

   my $input = input();
   my $array = $$input[-1];
   $array = [] if ref($array) ne "ARRAY";

   if(in_dialog()) {
      if(dialog_x() > dialog_lines()) {
         my $b=@state{dialog}->{buttons}->[dialog_x()-dialog_lines()-1];
         if(defined @call{(split(":",$b))[1]}) {
            return &{@call{(split(":",$b))[1]}}();
         }
      } else {
         return key_tab(@_);
      }
   }
   my $txt = join('',@$array);

   reset_more($conn);
   if(do_cmd(@state{world},$txt,$conn)) {
      # do_cmd runs the command
   } elsif(no_world()) {
     # do nothing
   } elsif(defined @socket{@state{world}} && 
           defined @socket{@state{world}}->{sock}) {
      out(@state{world},"%s",$txt) if(!in_dialog());
   }
   @state{input_pos} = -1;                    # reset keyboard history pos
   push(@$input,[]);
   line_pos_set(0) if (!in_dialog());
   @state{buffer_pos}++ if(@state{buffer_pos} < input_size());
   delete @state{input_offset};

   # just entered input, don't be so quick to show the more
   if(!no_world()) {
      @socket{@state{world}}->{more_last} = $#{@history{@state{world}}};
   }
   input_clear() if(!in_dialog());
#   printf("\n");
   xy(input_x(),input_y());
}

sub input_lines
{
    my $pos = shift;
    $pos = -1 unless $pos;
    my $chars;

    my $input = input();
    # there may only be X characters but the cursor might be one past it.
    if(line_pos() > $#{$$input[$pos]}) {
       $chars = line_pos();
    } else {
       $chars = $#{$$input[$pos]};
    }

    my $result = sprintf("%d",($chars + 1) / (@state{size_y} - 1));
    return $result + 1 if(($chars + 1) % (@state{size_y} - 1) >= 1);
    return $result;
}

sub input_on_line
{
    my $result = sprintf("%d",line_pos() / (@state{size_y} - 1));
    return $result + 1 if(line_pos() % (@state{size_y} - 1) >= 1);
    return $result;
}

#
# max_input
#   Max number of input lines in the keyboard buffer
#
sub max_input
{
   my $input = input();
    my $result = sprintf("%d",($#{$$input[-1]}+1) / (@state{size_y} - 1));
    return $result + 1 if(($#{$$input[-1]}+1) % (@state{size_y} - 1) >= 0);
    return $result;
}


#
# key_delete
#    Handle when the user presses the delete key.
#
sub key_delete
{
   my $ch = shift;

   return if !console();
   update_scroll_region("input");
   
   my $input = input();

   if(line_pos() < 1) {                             # nothing left to delete
      return;
   } elsif(line_pos() < $#{$$input[-1]}+1) {          # delete in middle

      if((line_pos()-1)-(@state{input_offset}*(@state{size_y} - 1))==-1){
         # at begining of visible buffer, input window needs to be erased
         # and redrawn. key_left will do this + move cursor one over.

         splice(@{$$input[-1]},line_pos()-1,1);      # remove character
         key_left($ch);
      } else {                            # deleting in the middle of a line.
         my $bol =                                  # [find begining of line] 
             (@state{size_y} - 1) *           # number of characters per line
             (@state{input_offset} +            # number of lines not visible
             input_x() - input_start());            # number of visible lines

         # loop from current line to end of screen horizontally

         xy(input_x(),input_y()-1);
         printf("\033[P");                 # delete ch before cursor
         for my $i (input_x(1) .. @state{size_x}) {
            my $pos=((@state{input_offset} + $i - input_start() + 1)
                    * (@state{size_y} - 1));
#            loggit("Test1: '%s' != '%s'",$i,input_x(1));
#            loggit("Test2: '%s' == '%s'",input_x(),input_x(1));
#           loggit("Test3: '%s' >= '%s'",$#{$$input[-1]},$pos-@state{size_y}+1);
            if($i != input_x(1) &&                     # not on cursor's line
               input_x() == input_x(1) &&           # not when moving up line
               $#{$$input[-1]} >= $pos - @state{size_y} + 1) {     # past EOL
               xy($i,0);
               printf("\033[P");
            }
#            loggit("Test2: '%s' <= '%s'",$pos,$#{$$input[-1]});
            if($pos <= $#{$$input[-1]}) {
               xy($i,@state{size_y} - 1);
               printf("%s",$$input[-1]->[$pos]);
            }
         }
         splice(@{$$input[-1]},line_pos()-1,1);      # remove character
         line_pos_set(line_pos() - 1);
         xy(input_x(),input_y());                            # return cursor
      }
   } elsif(line_pos() >= 1) {                           # delete at EOL
      line_pos_set(line_pos() - 1);                # move cursor pos back one
      pop(@{$$input[-1]});                           # remove char from buffer
      xy(input_x(),input_y());             # move cursor back incase it moved
      printf("\033[P");                       # delete character under cursor

      if(in_dialog()) {
         xy(input_x(),dialog_max() + 5 + dialog_input_size());
         printf("_");
         xy(input_x(),input_y());
      }

      # check to see if the cursor needs to go up a line, and therefor needs
      # to redraw the line.
      if((line_pos()-1)-(@state{input_offset}*(@state{size_y} - 1))==-2){
         xy(input_x(),1);                   # move cursor to begining of line
         @state{input_offset}--;               # move input focus one line up
         printf("%s",input_line(input_on_line()));               # print line
         # xy() - no need to move cursor to right location, its there.
      }
   }
}

#
# make_string_bold
#    Given a word/string in the input buffer that immediate preceeds where
#    the cursor is, make it bold.
#
sub make_string_bold
{
   my ($txt,$bold) = @_;

   return if $txt =~ /^\s*$/;

   my $i = line_pos() - length($txt);

   # move cursor to begingin of word
   xy(input_x(length($txt)),input_y(length($txt)));

#   printf("\033[1m") if($bold);                                  # start bold
   printf("\033[1m\033[1;31m") if($bold);                         # start bold
   for my $ch (split('',$txt)) {

      # determine if character would be off the screen, if so done.
      if($i >= ((@state{size_y}-1) * input_size()) + 
               (@state{input_offset} * (@state{size_y}-1))) {
         last;
      }

      # determine if we should drop down a line before next character
      if($i % (@state{size_y}-1) == 0 && $i != line_pos()-length($txt)){
         printf("\n");
      }
      printf("%s",$ch);                                # print out character
      $i++;
   }
   printf("\033[0m") if($bold);                               # turn off bold
}

sub input_eol
{
   my $pos = shift;

   if($pos % (@state{size_y}-1) == 0 && $pos != 0) {
      return 1;
   } else {
      return 0;
   }
}

# input_onscreen
#    deteremine if the current position is within the current viewable
#    area of the input scroll region.
sub input_onscreen
{
   my $pos = shift;

   my $input = input();
   return 0 if(!defined $$input[-1]->[$pos]);    # pos larger then array

   my $start = @state{input_offset} * (@state{size_y} -1);
   my $end  = $start + ((@state{size_y} - 1) * input_size());
   if($pos >= $start && $pos < $end) {
      return 1;                          # pos is in the input scroll region
   } else {
      return 0;                                              # nope, outside.
   }
}

sub cycle_next
{
   my $list = shift;
   my ($first,$next);
   my $current = dialog_value(dialog_x());

   for my $item (split(/\./,$list)) {
      $first = $item if($first eq undef);
      if($item eq $current) {
         $next = 1;
      } elsif($next) {
         return $item;
      }
   }
   return $first;
}

sub key_default
{
   my ($conn,$ch) = @_;
   my $pre_x = input_x();
   my $debug=0;
   my $ret;

   return if !console();
    update_scroll_region("input");

   my $input = input();
   # spell checker code
   if($ch eq " " && module_enabled("Text::Aspell") &&
     (!defined @state{p_spell} || TRUE(@state{p_spell}))) {
      if(substr(join('',@{$$input[-1]}),0,line_pos()) =~ 
            /(^| |^:|^"|^@)([a-zA-Z']+)([,\.!"']{0,1})(\s*)$/) {
         @state{speller} = Text::Aspell->new if(!defined @state{speller});
         if(!@state{speller}->check($2)) {
             make_string_bold("$2$3$4",1);
             @state{spelling_error} = 1;
         } elsif(@state{spelling_error} == 1) {  # this will not unbold every
             make_string_bold("$2$3$4",0);              # thing, improve later?
             @state{spelling_error} = 0;
         }
      }
   }


   if(in_dialog()) {
      if(dialog_type() eq "word" && $ch eq " ") {
         return;
      } elsif(dialog_type() eq "num" && $ch !~ /^[0-9]+$/) {
         return;
      } elsif(dialog_type() =~ /^cycle\./) {
         dialog_populate(dialog_x(),cycle_next($'));
         xy(input_x(),dialog_max() + 6);
         printf("\033[K[ %s ]",dialog_value(dialog_x()));
         xy(input_x(),input_y());
         return;
      } elsif(dialog_type() eq "check") {
         if($ch ne "x") {
            $ch = (dialog_value(dialog_x()) eq "x") ? " " : "x";
         }
         dialog_populate(dialog_x(),$ch);
         xy(input_x(),input_y());
         printf("%s",$ch);
         xy(input_x(),input_y());
         return;
      } else {
         return if(line_pos() >= dialog_input_size());
      }
   }

   splice(@{$$input[-1]},line_pos(),0,$ch);         # add ch to buffer
   line_pos_set(line_pos() + 1);                # move cursor position over 1
   printf("%s",$ch);                                     # print out new char

   # at end of line, drop down to next line
   if(input_eol(line_pos())) {
      printf("\r\n");
      $ret = 1;                                    # flag return was printed
      # has a line has scrolled off the input buffer
      @state{input_offset}++ if($pre_x == @state{size_x});
   }

   # display characters after cursor
   if(defined @$input[-1] && $#{$$input[-1]} >= line_pos()) {
      for(my $i=line_pos();input_onscreen($i);$i++){
         if(input_eol($i)) {                    # only if not already printed
            printf("\r\n") if(($ret && $i != line_pos()) or !$ret);
            $ret = 0;
         }
         printf("%s",$$input[-1]->[$i]);
      }
      xy(input_x(),input_y());
   }
}

#
# key_ctl_a
#    Move the cursor to the begining of the line
#
sub key_ctl_a
{
#-# summary: Move the cursor to the begining of the line
   my ($conn,$key) = @_;
   my $offset = @state{input_offset};

   @state{input_offset} = 0;                    # reset the cursor location
   line_pos_set(0);

   if($offset > 0) {     # line is not fully viewable, so a redraw is needed.
      draw_input($conn);
   } else {                                            # just move the cursor
      xy(input_x(),input_y());
   }
}

#
# key_ctl_e
#    Move the cursor to the end of the line
#
sub key_ctl_e
{
#-# summary: Move the cursor to the end of the line
   my ($conn,$key) = @_;

   input_lines();
   return;
   my $original = @state{input_offset};

   # determine the number of lines that aren't being shown for offset
   my $input = input();
   if($#{$$input[-1]} / (@state{size_y} - 1)+1 > input_size()) {
      @state{input_offset} = sprintf("%d",$#{$$input[-1]} / (@state{size_y}
          - 1) + 1 - input_size());
   } else {
      @state{input_offset} = 0;
   }
   line_pos_set($#{$$input[-1]} + 1);

   if(@state{input_offset} != $original) {
      draw_input($conn);
   } else {
      xy(input_x(),input_y());
   }
}

#
# input_size
#    Shortcut for stored variable with default to a size of 2.
#
sub input_size
{
   if(in_dialog()) {
      return dialog_lines() + 3;
   } else {
      return nvl(@state{p_input_size},2);
   }
}



#
# key_left
#    Move the cursor one character to the left
#
sub key_left
{
   return if !console();

   my $ret = "\n";
   my $input = input();
   if(@state{input_offset} > 0 && line_pos() % (@state{size_y}-1)==0 &&
      input_x() == input_start()) {
      @state{input_offset}--;
      for my $i (input_on_line() .. input_lines()) {
         last if(input_size() < $i - @state{input_offset});
         my $start = ($i-1) * (@state{size_y} -1);
         my $stop = $start + @state{size_y}-2;

         # only draw lines that are currently visible.
         if(input_size() < $i + 1 - @state{input_offset}) {
            $ret = undef;                          # last line? no return
         }
         printf("\033[J%s$ret",join('',@{$$input[-1]}[$start .. $stop]));
      }
   }
   if(line_pos() >= 1) {
      line_pos_set(line_pos() - 1);
      xy(input_x(),input_y());
   }
}


#
# input_line
#   Returns the keyed in input for a line on the screen.
#
sub input_line
{
   my ($line,$pos) = @_;
   $pos = -1 if $pos eq undef;

   my $input = input();
   my $start = ($line - 1) * (@state{size_y} -1);
   my $stop = $start + @state{size_y}-2;
   return join('',@{$$input[$pos]}[$start .. $stop]);
}

sub name
{
   my $name = lc(shift);

   return undef if($name eq undef && @state{world} eq undef);
   $name = lc(@state{world}) if $name eq undef;

   if(defined @address{$name} && defined @socket{$name}) {
      return ((defined @socket{$name}->{sock}) ? "" : "!") .
             @address{$name}->{name};                      # correct case?
   } elsif($name eq "muddler") {
      return "muddler";
   } else {
      return "(Unnamed)";
   }
}

#
# state
#    Simplify the retriveal / storage of values from the current state
#    that may exist in one of two different locations.
#
sub mstate
{
   if($#_ == 1) {
      if(is_console(@_[0])) {
         return @state{@_[1]};
      } elsif(is_web(@_[0])) {
         return @ws{@_[0]}->{@_[1]};
      }
   } elsif($#_ == 2) {
      if(is_console(@_[0])) {
         return @state{@_[1]} = @_[2];
      } elsif(is_web(@_[0])) {
         return @ws{@_[0]}->{@_[1]} = @_[2];
      }
   }
}

#
# key_up
# 
sub key_up
{
#-# summary: Switch to world with activity, or cycle up through worlds.
   my ($conn,$txt,$force) = @_;
   my $w = world($conn);
   my ($tmp, $first);

   return wc_out("/key_up") if(is_remote());

   if(in_dialog()) {
      if(dialog_x() == 1) {
         dialog_x(dialog_lines() + 2);
      } else {
         dialog_x(dialog_x()-1);
      }
      return xy(input_x(),input_y());
   }
   
   if(@state{p_updown} eq "Cursor Movement" && is_console($conn)) {
      if(@state{line_pos} > @state{size_y} - 1) {
         @state{line_pos} -= @state{size_y} - 1;
         update_input_offset();
         draw_input($conn);
      }
      return;
   } elsif((my $active = get_active($w))) {                 # try most active
      return switch_world($conn,$active);
   } else {
      for my $key (sort {$a cmp $b} keys %socket){      # next alphabetically
         if(defined @socket{$key}->{sock} || $force ||
            (defined @pending{$key} && $#{@pending{$key}} >= 0)) {
            $first = $key if !defined $first;
            if($key eq $w) {
               $tmp = 1;
            } elsif($tmp) {
               return switch_world($conn,$key);
            }
         }
      }
   }
   # Try first on list if not current world
   delete @socket{muddler} if($first ne "muddler");
   switch_world($conn,$first) if(defined $first && $first ne $w);
}

#
# key_down
#   Move down one world and switch to it.
#
sub key_down
{
#-# summary: Switch to world with activity, or cycle up through worlds.
   my ($conn,$txt,$force) = @_;
   my $w = world($conn);
   my ($tmp, $first);

   return wc_out("/key_up") if(is_remote());

   if(in_dialog()) {
      if(dialog_lines() + 3 <= dialog_x() + 1) {
         dialog_x(1);
      } else {
         dialog_x(dialog_x()+1);
      }
      return xy(input_x(),input_y());
   } elsif(@state{p_updown} eq "Cursor Movement" && is_console($conn)) {
      my $input = input();
      if(@state{line_pos} + @state{size_y} - 1 > $#{$$input[-1]}) {
         key_end(@_);
      } else {
         @state{line_pos} += @state{size_y} - 1;
         update_input_offset();
         draw_input($conn);
      }
      return;
   } elsif((my $active = get_active($w))) {                # try most active
      return switch_world($conn,$active);
   } else {
      for my $key (reverse sort {$a cmp $b} keys %socket){      # next alpha
         if(defined @socket{$key}->{sock} || $force ||
            (defined @pending{$key} && $#{@pending{$key}} >= 0)) {
            $first = $key if !defined $first;
            if($key eq $w) {
               $tmp = 1;
            } elsif($tmp) {
               return switch_world($conn,$key);
            }
         }
      }
   }
   # Try first on list if not current world
   switch_world($conn,$first) if(defined $first && $first ne $w);
}

#
# key_right
#   Handle the pressing of the right arrow key
#
sub key_right
{
   return if !console();

   my $input = input();
   if(line_pos() <= $#{$$input[-1]}) {     # not at the end of the line?
      # will cursor go off screen?
      #    1 adjust the input_offset to reflect this
      #    2 show next line
      if(line_pos() % (@state{size_y}-1)==@state{size_y} - 2 &&
         input_x() == @state{size_x}) {
         @state{input_offset}++;
         printf("\n%s",input_line(input_on_line()+1));
      }

      line_pos_set(line_pos() + 1);
      xy(input_x(),input_y());         # move cursor to expected location
   }
}

#
# TRUE
#    What is true these days? no idea. We'll accept 1, on, yes, and true.
#
sub TRUE
{
   my $txt = shift;

   return ($txt =~ /^\s*(1|on|yes|true)\s*$/i) ? 1 : 0;
}

#
# switch_world
#    Switch the current world or all of them.
#
sub switch_world
{
   my ($conn,$world) = @_;

   return if $world eq undef;

   mstate($conn,"world_last",world($conn));

   if(TRUE(@state{p_sync})) {                       # switch all interfaces
      @state{world_last} = @state{world};
      @state{world} = $world;
      for my $key (keys %ws) {
         @ws{$key}->{world_last} = @state{world};
         @ws{$key}->{world} = $world;
      }
   } elsif(is_web($conn)) {                              # switch websocket
      @ws{$conn}->{world} = $world;
   } else {                                               # switch console
      @state{world} = $world;
   }


   if(TRUE(@state{p_sync})) {                     # world syncing turned on,
      draw_output($conn,0);                      # keep all worlds in sync
      for my $key (keys %ws) {
         draw_output(@ws{$key}->{conn},0);
      }
   } else {
      draw_output($conn,0);
   }
   release_some_pending($conn,$world);
   update_scroll_region("input");
#   if(in_dialog() && dialog_name(1) eq "World Name") {
#      cmd_editor($conn,$world);
#   }
}

#
# get_active
#    Return the world with the most pending lines
#
sub get_active
{
   my $w = world(shift);
   my $max = -1;
   my $name;

   for my $world (keys %pending) {
      if($w ne $world &&
         defined @pending{$world} &&
         defined @socket{$world} &&
         $#{@pending{$world}} > $max) {
         $name = $world;
         $max = @{@pending{$world}};
      }
   }

   return $name;
}

#
# key_esc_w
#   Go to the next active world
#
sub key_esc_w
{
#-# summary: Go to the next active world, or the last world
   my ($conn,$txt) = @_;

   return wc_out("/key_esc_w") if(is_remote());

   my $w = world($conn);
   my $new = get_active($conn);

   if($new eq undef) {
      if(is_web($conn)) {
         return switch_world($conn,@ws{$conn}->{world_last});
      } else {
         return switch_world($conn,@state{world_last});
      }
   }

   # fall back to previous world the client was showing.

   if($new eq undef) {                    # use last world if no activity
      if(is_console($conn)) {
         $new = @state{world_last};
      } elsif(is_web($conn)) {
         $new = @ws{$conn}->{world_last};
      }
   }

   # nothing found, do nothing.
   return if $new eq undef;

   switch_world($conn,$new);
}

#
# update_scroll_region
#   Send the escape sequence to set a scroll region in the terminal.
#   The region will not be set if the region is already in affect unless
#   $force is true.
#
sub update_scroll_region
{
   return if !console();
   return if defined @state{monitor_value};

   my ($region,$force) = @_;

   if($region ne "input" && $region ne "output") {
      die("Invalid region '$region' specified.");
   }

   my $start = ($region eq "input") ? input_start() : 1;
   my $stop  = ($region eq "input") ? input_end() : output_end();

   if(@state{region} ne "$start,$stop" || $force) {           # do the work
      printf("\033[%s;%sr",$start,$stop);
      @state{region} = "$start,$stop";
      @state{r} = $region;
   }
}

sub is_in
{
   my ($txt,@list) = @_;

   for my $i (0 .. $#list) {
      return 1 if($txt eq @list[$i]);
   }
   return 0;
}

#
# key_multi
#   Process multiple character keys. key_escape will start the sequence
#   off and this will grab characters till it makes a match or no match
#   can be made. This should be more of a decision tree instead of an
#   emulated tree.
#
sub key_multi
{
   my ($conn,$ch) = @_;

   my $array = @state{multikey};
   push(@$array,ord($ch));

   if($#$array >= 10) {             # shoudln't happen but protect against it
      delete @state{multikey};
      key_process($ch);                       # process character generically
   }


   if(defined @key{"multi_" . join("_",@$array)}) {
      if(ref(@key{"multi_" . join("_",@$array)}) eq "CODE") {
         delete @state{multikey};
         return &{@key{"multi_" . join('_',@$array)}}(@state{world},$ch);
      }
   } else {                                                        # error?
      delete @state{multikey};
      key_process($ch);                       # process character generically
   }
}

#
# key_process
#    Process input one key at a time while allowing for multi character
#    keys that begin with a escape and are followed by an arbitrary number
#    of letters afterwards (1 to 2?).
#
sub key_process
{
   my $input;

   if(module_enabled("Encode")) {
      $input = decode("UTF-8",shift);
   } else {
      $input = shift;
   }
   return unless defined $input;

   
   @state{key_last} = time();
   for my $ch (split(//,$input)) {
#      LOGGIT("ch: '%s' -> '%s'",ord($ch),$ch);
      if(defined @key{ord($ch)}) {
         &{@key{ord($ch)}}(@state{world},$ch);
      } elsif(defined @state{multikey}) {
         &{@key{multi}}(@state{world},$ch);
      } else {
         # clear suggestion list on new character.
         if(defined @state{suggest}) {
            delete @state{suggest};
            delete @state{suggest_pos};
         }
         &{@key{def}}(@state{world},$ch);
      }
   }
}

sub is_console
{
   my $conn = shift;

   return ($conn eq "muddler" || defined @socket{$conn}) ? 1 : 0;
}

sub is_web
{
   my $conn = shift;

   return (defined @ws{$conn}) ? 1 : 0;
}

sub clear_screen
{
   my $conn = shift;
   return if defined @state{monitor_value};

   if(is_console($conn) && console()) {
      for my $line (1 .. @state{size_x}) {
         if($line == @state{size_x}) {
            printf("\033[K");
         } else {
            printf("\033[K\n");
         }
      }
   } elsif(is_web($conn)) {
      ws_echo($conn,"d","clear");          # clear output websocket window
   }
}

#
# x,y
#    Move the cursor to a location. This should be able to be optimized
#    when we are sure we always know where the cursor is all the time.
#
sub xy
{
   my ($x,$y,$use_the_force_luke) = @_;

   return if !console();
   return if defined @state{monitor_value};
   printf("\033[%s;%sH",$x,$y);
}

#
# more_bar
#    Determine what the more text should look like on the bar.
#
sub more_bar
{
   my $conn = shift;

   my $w = world($conn);
   return if $w eq undef || !defined @socket{$w};

   if(in_hist($w)) {
      return sprintf("\033[7mHist %4s\033[0m",abs(@socket{$w}->{hist_offset}));
   } elsif(in_more($w) && pending($w) != 0) {
      return sprintf("\033[7mMore %4s\033[0m",pending($w));
   }
   return undef;
}

#
# world
#    determine the world name based upon the connection id. For console
#    connections these are the same things, for websocket connections
#    they are not.
#
sub world
{
   my $conn = shift;

   if(is_remote() && defined @state{remote_bar} &&
      @state{remote_bar} =~ /^_+(.+?)_+$/) {
      return $1;
   } elsif(defined @socket{$conn}) {
      return $conn;
   } elsif(defined @ws{$conn}) {
      return @ws{$conn}->{world};
   } else {
      return "muddler";
   }

#   if(is_console($conn)) {
#      return @state{world};
#   } elsif(is_web($conn)) {
#      return @ws{$conn}->{world};
#   } else {
#      return "muddler";
#   }
}

sub current_world
{
   my $conn = shift;

   if(defined @ws{$conn}) {
      return @ws{$conn}->{world};
   } else {
      return @state{world};
   }
}

sub size_x
{
   my $conn = shift;

   if(is_web($conn)) {
      return @ws{$conn}->{size_x} if(defined @ws{$conn});
   } else {
      return @state{size_x};
   }
}

sub size_y
{
   my $conn = shift;

   if(is_web($conn)) {
      return @ws{$conn}->{size_y} if(defined @ws{$conn});
   } else {
      return @state{size_y};
   }
}

#
# activity_count
#    Count up the number of worlds that have activity, excluding those
#    worlds that are currently visibile. Worlds with pending activity
#    should get activity notices as long as they're not visible.
#
sub activity_count
{
   my $cnt = 0;

   # exclude currently viewed worlds in counts;

   for my $world (grep {!/muddler/} keys %pending) {
      if($#{@pending{$world}} >= 0 && !world_visible($world)) {
#         loggit("Acvity: '%s' %s",$world,print_var(@pending{$world}));
         $cnt++;
      }
   }
   return $cnt;
}

#
# draw_bar
#    draw/redraw the input bar if need.
#
sub draw_bar
{
   return if defined @state{window_value};
   my $force = shift;
   my $new = time();
   my ($hr,$min,$act) = ((localtime($new))[2,1]);
   $hr -= 12 if($hr > 12);
   $hr = 12 if $hr == 0;
   my $cnt = activity_count();

   if(is_remote()) {
      if(@state{size_x}.@state{size_y} ne @state{bar_size} ||
         @state{remote_bar} ne @state{bar_prev} ||
         @state{bar_time} ne "$hr$min") {
         @state{bar_time} = "$hr$min";
         @state{bar_size} = @state{size_x}.@state{size_y};
         @state{bar_prev} = "_" if(!defined @state{bar_prev});
         @state{bar_prev} = @state{remote_bar};
            xy(@state{size_x} - input_size(),0);
            printf("%s%s%s:%02d",
                   @state{remote_bar},
                   "_" x (@state{size_y} - ansi_length(@state{remote_bar}) - 
                       length($hr) - 3),
                   $hr,
                   $min
                  );
            update_scroll_region("input");
            xy(input_x(),input_y());
      }
      return;
   } elsif(console() && ($force || "$hr$min" ne @state{bar_time} ||
      @state{bar_activity} ne $cnt ||
      @state{bar_name} ne name(@state{world}) ||
      @state{bar_more} ne pending(@state{world}) ||
      @state{bar_pos} ne hist_pos(@state{world}) ||
      @state{size_x}.@state{size_y} ne @state{bar_size})) {
      #---
#      loggit("draw_bar: force=%s,act=%s/%s,name=%s/%s,more=%s/%s/%s,pos=%s/%s",
#         $force,
#         @state{bar_activity},$cnt,
#         @state{bar_name},name(@state{world}),
#         @state{bar_more},pending(@state{world}),in_more(@state{world}),
#         @state{bar_pos},hist_pos(@state{world}));
#      loggit("draw_bar: %s",code("shortest"));
      @state{bar_time} = "$hr$min";
      @state{bar_name} = name(@state{world});
      @state{bar_more} = pending(@state{world});
      @state{bar_pos} = hist_pos(@state{world});
      @state{bar_size} = @state{size_x}.@state{size_y};
      @state{bar_activity} = $cnt;
      # determine activity count, if any.
      if($cnt >= 1) {
         $act = sprintf("(Act%s: %d)",(@state{size_y}<50) ? "" : "ive",$cnt);
      }

      my $more = more_bar(@state{world});
      #---
      xy(input_start() - 1,0);

      printf("%s%s_%s%s_%s_%s_%s:%02d",
             "_" x (9 - ansi_length($more)),
             $more,
             name(),
             "_" x (12 - length(name())),
             $act,
             "_" x (@state{size_y} - length("$act$hr")-28),
             $hr,
             $min
            );
#      update_scroll_region("input");
      xy(input_x(),input_y());
   }


   my $hash = $ws_server->{conns};
   for my $key ( keys %$hash) {
      
      my $conn = $$hash{$key}->{conn};

      if(!defined @ws{$conn}) {
         ws_disconnect($conn);
         next;
      }
      if($force || "$hr$min" ne @ws{$conn}->{bar_time} ||
         @ws{$conn}->{bar_activity} ne $cnt ||
         @ws{$conn}->{bar_name} ne name(world($conn)) ||
         @ws{$conn}->{bar_more} ne pending(world($conn)) ||
         @ws{$conn}->{bar_pos} ne hist_pos(world($conn))) {
         #---
         @ws{$conn}->{bar_time} = "$hr$min";
         @ws{$conn}->{bar_name} = name(world($conn));
         @ws{$conn}->{bar_more} = pending(world($conn));
         @ws{$conn}->{bar_pos} = hist_pos(world($conn));
         @ws{$conn}->{bar_activity} = $cnt;


         # determine activity count, if any.
         if($cnt >= 1) {
            $act = sprintf("(Act%s: %d)",(@state{size_y}<50) ? "" : "ive",$cnt);
         }

         my $more = more_bar($conn);
         ws_echo($conn,
                 "*",
                 sprintf("%s:%02d    ",$hr,$min)
                );
         ws_echo($conn,
                 "b",
                 sprintf("%-*s %-10s %s",
                         9 - ansi_length($more),
                         $more,
                         name(@ws{$conn}->{world}),
                         $act
                        )
               );
      }
   }
}

sub ws_all
{
   my ($type,$txt) = @_;

   return if !web();
   my $hash = $ws_server->{conns};

   for my $key ( keys %$hash) {
      my $client = $$hash{$key}->{conn};

      delete @ws{$client} if defined @ws{$client} && ref(@ws{$client}) eq "";
      next if(!defined @ws{$client} || @ws{$client}->{auth} eq 0);

      eval {
          ws_echo($client,$type,$txt);
      };
      if($@) {
         ws_disconnect($client);
      }
   }
}

#
# input_start
#    Return the starting line number of the input window.
#
sub input_start
{
   if(in_dialog()) {
      return @state{size_x} - (dialog_lines() + 2);
   } else {
      return @state{size_x} - input_size() + 1;
   }
}

#
# input_end
#    Return the line ending line of the console. This function exists
#    mostly to make things more readable.
#
sub input_end
{
   return @state{size_x};
}

#
# revert_console
#    Send whatever is needed to reset the terminal to normal operation.
#    i.e. turning off scroll regions.
#
sub revert_console
{
   if(!console() || @state{fatal} || $term eq undef) {
      return;
   } else {
      normal();
      printf("\033[r\033[2J");
      xy(24,1);
   }
}


#
# loggit
#    Write a to the muddler.log file if debugging is enabled. Output to
#    the screen probably won't be readable.
#
sub loggit
{
   my ($fmt,@args) = @_;
   my $file;

   # @state{p_debug} = 1;
   #   die("no debug - " . code()) if !@state{p_debug};
   return if !defined @state{p_debug} || !@state{p_debug};

   my $msg = sprintf("$fmt",@args);
   $msg .= "\n" if($msg !~ /\n/);

   # syswrite on closed filehandle. Happens when the websocket client
   # is closed. Can't seem to stop these, so lets ignore them.
#   return if $msg =~ /syswrite/;
   open($file,">> muddler.log");
   binmode($file, ":utf8");
   printf($file "%s",$msg);
   close($file);
}

# LOGGIT
#    Alias for loggit function. The idea is that LOGGIT calls are calls
#    that are logging commands that should always be kept in muddler and
#    that loggit() calls are more temporary.
#
sub LOGGIT
{
   loggit(@_);
}

#
# code
#    Provide just the list of line numbers from perl's stack of what sub-
#    routines or optionally the full output. The line numbers will be
#    adjusted as code is reloaded because the numbers will change.
#
sub code
{
   my $type = shift;
   my @stack;

   my $prev = @state{chksum};
   $type = "shortest" if $type eq "smallest";
   if(!$type || $type eq "short" || $type eq "shortest") {
      for my $line (split(/\n/,Carp::shortmess)) {
         if($line =~ /at ([^ ]+) line (\d+)\s*$/) {
            my ($fun,$ln) = ($1,$2);
            if(defined $$prev{$fun} && $type eq "shortest") {
               push(@stack,@{$$prev{$fun}}{line} + $ln);
            } elsif(defined $$prev{$fun}) {
               push(@stack,(@{$$prev{$fun}}{line} + $ln) . "[$fun]");
            } else {
               push(@stack,"$ln*");
            }
         }
      }
      if($type eq "shortest") {
         return join(',',@stack[0 .. 5]);
      } else {
         return join(',',@stack);
      }
   } else {
      return Carp::shortmess;
   }
}
sub input_clear
{
   return if !console();
   update_scroll_region("input");
   my $start = @state{size_x} - input_size() + 1;
   xy($start,0);
   for my $i ($start .. @state{size_y}) {
      printf("\033[K\n");
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  commands                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

sub key_esc_q
{
#-# summary: Show spell suggestions for last word. Cycle thru on next esc-q
   my ($conn,$txt) = @_;
   my ($spell, $found);

   my $input = input();
   if(module_enabled("Text::Aspell")) {
      if(substr(join('',@{$$input[-1]}),0,line_pos()) =~ 
            /(^| |^:|^"|^@)([a-zA-Z']+)([,\.!"']{0,1})(\s*)$/) {

         if(!defined @state{suggest}) {                   # no saved results
            @state{speller} = Text::Aspell->new if(!defined @state{speller});
            if(!@state{speller}->check($2)) {             # not spelled right
               @state{suggest} = [ (@state{speller}->suggest($2))[0.. 4] ];
           
               @state{suggest_pos} = 0;                      # show results
               echo($conn,"%s : %s",$2,join(", ",@{@state{suggest}}));

               if($#{@state{suggest}} == -1) {               # no suggestions
                  delete @state{suggest};
                  return;
               } else {
                  push(@{@state{suggest}},$2);    # add original word to list
               }

               @state{suggest_pos} = $#{@state{suggest}};
            }
            return;
         }

         for my $i (1 .. length($2 . $3 . $4)) {
            key_delete();
         }

         @state{suggest_pos}++;
         if(@state{suggest_pos} > $#{@state{suggest}}) {
            @state{suggest_pos} = 0;
         }

         for my $ch (split('',@{@state{suggest}}[@state{suggest_pos}]."$3$4")){
            key_default($conn,$ch);
         }
      }
   }

   return;

   my $input = join('',@{$$input[-1]});

   $input =~ s/[^a-zA-Z0-9 ]+//g;
   open($spell,"echo $input | aspell -a -S |") ||
      return echo($conn,"%% Unable to run aspell");
   while(<$spell>) {
      if(/^& ([^ ]+) [^:]+: /) {
         my @data = split(/,/,$');
         echo($conn,"%% %-15s  =>  %s",$1,join(', ',(split(/,/,$'))[0..4]));
         $found++;
      }
   }
   close($spell);
   echo($conn,"%% No misspelled words found.") if (!$found);
}

#
# glob2re
#    Convert a global pattern into a regular expression
#
sub glob2re
{
    my ($pat) = trim(shift);

    return "^\s*\$" if $pat eq undef;
    $pat =~ s{(\W)}{
        $1 eq '?' ? '(.)' :
        $1 eq '*' ? '(*PRUNE)(.*?)' :
        '\\' . $1
    }eg;

    $pat =~ s/\\\(.\)/?/g;

#    return "(?mnsx:\\A$pat\\z)";
    return "(?msix:\\A$pat\\z)";
}

#
# single
#    Take the input and smash it together into one line by removing any
#    returns or linefeeds.
#
sub single
{
    my $txt = shift;
    $txt =~ s/\r|\n//g;
    return $txt;
}

sub call_addworld
{
   my ($conn,$data) = @_;

   if(!defined $$data{"World Name"} ||
      trim($$data{"World Name"}) eq "") {
      return echo($conn,"A required World Name was not provided.");
   }
   if(!defined $$data{"Host"} ||
      trim($$data{"Host"}) eq "") {
      return echo($conn,"A required Host was not provided.");
   }
   if(!defined $$data{"Port"} ||
      trim($$data{"Host"}) eq "") {
      return echo($conn,"A Port was not provived.");
   }

   cmd_editor($conn,
           sprintf("%s %s %s %s %s %s",
                   ($$data{"Use SSL to connnect"} eq "x") ? "-s" : "",
                   $$data{"World Name"},
                   $$data{User},
                   $$data{Password},
                   $$data{Host},
                   $$data{Port}
                  )
          );
}


#----------------------------------------------------------------------------#
#                                                                            #
#  dialog support                                                            #
#    Support for some generic "dialog" box routines. This is actually just   #
#    Increasing the size of the input box on the bottom of the screen andt   #
#    using this space for prompting the user with input boxes/prompts.       #
#                                                                            #
#----------------------------------------------------------------------------#

sub input
{
   if(in_dialog()) {
      return @state{dialog}->{dialog_x()}->{input};
   } else {
      return \@std_input;
   }
}

sub dialog_input_offset
{
   my $pos = shift;

   my $pos = ($#_ == -1) ? dialog_x() : shift;

   if(defined @state{dialog} &&
      defined @state{dialog}->{$pos}->{input_offset}) {
      return @state{dialog}->{$pos}->{input_offset};
   }
}

sub dialog_populate
{
   my ($pos,$txt) = @_;

   if(in_dialog()) { 
       if(dialog_type($pos) eq "check") {
          if($txt ne " " && $txt ne "" && $txt ne "0") {
             $txt = "x";
          } else {
             $txt = " ";
          }
       }
       @state{dialog}->{$pos}->{orig} = $txt;
       @state{dialog}->{$pos}->{input} = [[ split(//,$txt) ]];
       @state{dialog}->{$pos}->{line_pos} = length($txt);
   }
}

sub dialog_init
{
   my ($conn,$definition,$buttons,$indent) = @_;
   my $count = 0;
   my $max;

   line_pos_set(0);

   @state{dialog} = {};
   @state{dialog}->{input_x} = 1;
   @state{dialog}->{input_offset} = 1;

   for my $i (split(/,/,$definition)) {                 # find max
      $count++;
      my ($name,$type) = split(/:/,$i);
      my $size = length($name);
      $max = $size if($max < $size && $type  ne "check");
      @state{dialog}->{$count} = {};
      @state{dialog}->{$count}->{type} = $type;
      @state{dialog}->{$count}->{name} = $name;
      @state{dialog}->{$count}->{line_pos} = 0;
      if($type =~ /^cycle\.([^\.]+)/) {
         @state{dialog}->{$count}->{input} = [[ split(//,$1) ]];
      } else {
         @state{dialog}->{$count}->{input} = [[ ]];
      }
   }

   @state{dialog}->{max} = $max;
   @state{dialog}->{count} = $count;
   @state{dialog}->{conn} = $conn;
   @state{dialog}->{buttons} = $buttons;
}

sub dialog_lines
{
   if(defined @state{dialog} &&
      defined @state{dialog}->{count}) {
      return @state{dialog}->{count};
   }
}

sub dialog_buttons
{
   if(defined @state{dialog} &&
      defined @state{dialog}->{buttons}) {
      return $#{@state{dialog}->{buttons}} + 1;
   }
}

sub dialog_max
{
   if(defined @state{dialog} &&
      defined @state{dialog}->{max}) {
      return @state{dialog}->{max};
   }
}

sub rjust
{
   my ($txt, $size,$ch) = @_;

   $ch = " " if($ch eq undef);
   my $val = substr($txt,0,$size);
   return $val . ($ch x ($size - length($val)));
}

sub in
{
   my ($value,@list) = @_;

   for my $i (0 .. $#list) {
      return 1 if($value eq @list[$i]);
   }
   return 0;
}

sub cycle_first
{
   return (split(".",shift))[0];
}

sub dialog_draw
{
   my @buttons;

   update_scroll_region("input",1);
   xy(input_start(),1,1);
   printf("\033[J\n");

   for my $i (1 .. dialog_lines()) {
      if(in(dialog_type($i),"word","text","num")) {
         printf("   %-*s: %s\n",
                dialog_max(),
                dialog_name($i),
                rjust(join('',@{@state{dialog}->{$i}->{input}->[-1]}),
                      dialog_input_size(),"_")
               );
      } elsif(dialog_type($i) =~ /^cycle\./) {
         if(dialog_value($i) eq "") {
            dialog_populate($i,cycle_first($i));
         }
         printf("   %-*s: [ %s ]\n",
                dialog_max(),
                dialog_name($i),
                dialog_value($i)
               );
      } elsif(dialog_type($i) eq "check") {
         printf("   [%1s] %s\n",
                dialog_value($i),
                dialog_name($i),
               );
      }
   }

   my $wsize = 8 + dialog_input_size() + dialog_max();
   for my $but (@{@state{dialog}->{buttons}}) {
      push(@buttons,sprintf("[ %s ]",(split(":",$but))[0]));
   }

   my $start = $wsize - length(join(' ',@buttons));
   my $pos = $start + 1;
   @state{dialog}->{bpos} = [];
   for my $but (@{@state{dialog}->{buttons}}) {
      push(@{@state{dialog}->{bpos}},$pos + 2);
      $pos += length((split(':',$but))[0]) + 5;
   }

   printf("\n%s%s"," " x $start,join(' ',@buttons));

   xy(input_x(),input_y(),1);
}

# in_dialog
#
#    Determine if a "dialog" menu/box/whatever is open. Its probably,
#    silly to do it with this simple of a test but maybe this will be
#    expanded later.
#
sub in_dialog
{
   return (defined @state{dialog}) ? 1 : 0;
}

sub dialog_x
{
   return if !in_dialog();

   if($#_ == -1) {
      if(defined @state{dialog} &&
         defined @state{dialog}->{input_x}) {
         return @state{dialog}->{input_x};
      }
   } elsif($#_ == 0) {
      @state{dialog}->{input_x} = shift;
   } else {
      die("dialog_x supports either no or one arguements");
   }
}


sub dialog_cancel
{
   delete @state{dialog};
   draw_screen(@state{world},1);
}

sub editor_connect
{
   my $name = dialog_value(1);
   my $conn = @state{dialog}->{conn};
   editor_save();
   cmd_world($conn,$name);
}

sub editor_save
{
   my $data = {};
   for my $i (0 .. dialog_lines()) {
      $$data{dialog_name($i)} = dialog_value($i);
      if(dialog_name($i) eq "World Name") {
         $$data{"Orig_World_Name"} = dialog_orig_value($i);
      }
   }
   my $conn = @state{dialog}->{conn};
   my $w = world($conn);

   if(!defined $$data{"World Name"} ||
      trim($$data{"World Name"}) eq "") {
      return echo($conn,"A required World Name was not provided.");
   }

   if($$data{"World Name"} =~ /^\s*new\s*$/i) {
      return echo($conn,"The world name may not be 'new'.");
   }
  
   if(!defined $$data{"Host"} ||
      trim($$data{"Host"}) eq "") {
      return echo($conn,"A required Host was not provided.");
   }
   if(!defined $$data{"Port"} ||
      trim($$data{"Port"}) eq "") {
      return echo($conn,"A Port was not provived.");
   }
   if(!defined $$data{"Encoding"} ||
      trim($$data{"Encoding"}) eq "") {
      return echo($conn,"An encoding type was not provived.");
   }

   dialog_cancel();

   if($$data{"Orig_World_Name"} ne $$data{"World Name"}) {
      delete @address{$$data{"Orig_World_Name"}};
      save($conn,"WORLD",$$data{"Orig_World_Name"});
   }
   my $name = lc($$data{"World Name"});
   @address{$name} = {};
   if($$data{"Use SSL to connnect"} eq "x") {
      @address{$name}->{ssl} = 1;
   }
   if($$data{"Log output to $w.log"} eq "x") {
      @address{$name}->{log} = 1;
   }
   @address{$name}->{name} = $$data{"World Name"};
   @address{$name}->{user} = $$data{"User"} if trim($$data{"User"}) ne undef;
   if(trim($$data{"Password"}) ne undef) {
      @address{$name}->{pass} = $$data{"Password"};
   }
   @address{$name}->{host} = $$data{"Host"};
   @address{$name}->{port} = $$data{"Port"};
   if(trim($$data{"KeepAlive CMD"}) ne undef) {
      @address{$name}->{keepalive} = $$data{"KeepAlive CMD"};
   }
   @address{$name}->{encode} = encoding_detranslate($$data{Encoding});
   save($conn,"WORLD",$name);
}

sub editor_delete
{
   my $conn = @state{dialog}->{conn};
   if(defined @address{dialog_value(1)}) {
      delete @address{dialog_value(1)};
      echo($conn,"%% World %s has been deleted",dialog_value(1));
      dialog_cancel();
      delete @address{dialog_value(1)};
      save($conn,"STATE",dialog_value(1));
   } else {
      echo($conn,"%% Unable to find and delete world '%s'",dialog_value(1));
   }
}


sub dialog_fixed_value
{
   my $pos;
   if( $#_ == -1 ){
      $pos = @state{dialog_x};
   } elsif($#_ == 0) {
      $pos = shift;
   } else {
      die("dialog_fixsupports either 0 or 1 arguements");
   }

   if(defined @state{dialog} &&
      defined @state{dialog}->{$pos} &&
      defined @state{dialog}->{$pos}->{input}) {

      my $val = join('',@{@{@state{dialog}->{$pos}->{input}}[-1]});

      if(@state{dialog}->{$pos}->{type} eq "check") {
        return ($val eq "x") ? 1 : 0;
      } else {
        return $val;
      }
   }
}

sub set_save
{
   my $conn = @state{dialog}->{conn};
   my $count = 0;
   my %lookup;
   my $web;
   my $theme;

   for my $key (keys %var) {
      @lookup{@var{$key}->{setup}} = $key if(defined @var{$key}->{setup});
      @lookup{@var{$key}->{web}} = $key if(defined @var{$key}->{web});
   }

   for my $i (1 .. dialog_lines()) {
       my $val = dialog_fixed_value($i);
       # loggit("val: '%s'\n",$val);
       if(@state{"p_" . @lookup{dialog_name($i)}} ne $val) {
          if(@lookup{dialog_name($i)} eq "web") {
             $web = $val;
             $count++;
          } elsif(@lookup{dialog_name($i)} eq "theme") {
             $theme = $val;
             $count++;
          } else {
             @state{"p_" . @lookup{dialog_name($i)}} = $val;
             save($conn,"STATE","p_" . @lookup{dialog_name($i)});
             $count++;
          }
       }
   }

   dialog_cancel();

   cmd_set($conn,"theme=$theme") if($theme ne undef);

   if($web ne undef) { # run here or output will be lost
      cmd_web($conn,($web) ?  "on" : "off");
   }

   if($count == 0) {
      echo($conn,"%% No changes made, nothing saved.");
   } else {
      echo($conn,"%% %s changes saved to ~/.muddler.",$count);
   }

   if($web ne undef) {    # run here or output will be lost by dialog_cancel
      cmd_web($conn,($web) ?  "on" : "off");
   }
}

#
# dialog_input_size
#   Return the size of the current dialog window
#
sub dialog_input_size
{
   return size_y() - dialog_max() - 14;
}

#
# dialog_type
#   Return the type of the requested dialog item/line. i.e. text/check/etc.
#
sub dialog_type
{
   my $pos;

   if( $#_ == -1 ){
      $pos = dialog_x();
   } elsif($#_ == 0) {
      $pos = shift;
   } else {
      die("dialog_type supports either one or no arguements");
   }

   if(defined @state{dialog} &&
      defined @state{dialog}->{$pos} &&
      defined @state{dialog}->{$pos}->{type}) {
      return @state{dialog}->{$pos}->{type};
   }
}

#
# dialog_name
#    return the name of the requested dialog item/line as defined in @var
#
sub dialog_name
{
   my $pos;

   if( $#_ == -1 ){
      $pos = @state{dialog_x};
   } elsif($#_ == 0) {
      $pos = shift;
   } else {
      die("dialog_type supports either no or one arguements");
   }

   if(defined @state{dialog} &&
      defined @state{dialog}->{$pos} &&
      defined @state{dialog}->{$pos}->{name}) {
      return @state{dialog}->{$pos}->{name};
   }
}

#
# dialog_value
#    return the value of the requested dialog item/line
#
sub dialog_value
{
   my $pos;

   if( $#_ == -1 ){
      $pos = @state{dialog_x};
   } elsif($#_ == 0) {
      $pos = shift;
   } else {
      die("dialog_type supports either 0 or 1 arguements");
   }

   if(defined @state{dialog} &&
      defined @state{dialog}->{$pos} &&
      defined @state{dialog}->{$pos}->{input}) {

      return join('',@{@{@state{dialog}->{$pos}->{input}}[-1]});
   }
}

#
# dialog_value
#    return the original value of the requested dialog item/line
#
sub dialog_orig_value
{
   my $pos;

   if( $#_ == -1 ){
      $pos = @state{dialog_x};
   } elsif($#_ == 0) {
      $pos = shift;
   } else {
      die("dialog_type supports either 0 or 1 arguements");
   }

   if(defined @state{dialog} &&
      defined @state{dialog}->{$pos} &&
      defined @state{dialog}->{$pos}->{orig}) {

      return @state{dialog}->{$pos}->{orig};
   }
}

sub safe
{
   my $txt = shift;

   my $ret = chr(23);
   $txt =~ s/\\/\\\\/g;
   $txt =~ s/\r\n/$ret/g;
   $txt =~ s/\n/$ret/g;
   $txt =~ s/\r/$ret/g;
   $txt =~ s/;/\\;/g;

   return $txt;
}

sub hash_dump
{
   my $hash = shift;
   my $out;

   for my $key (keys %$hash) {
      if($$hash{$key} ne "0" && $$hash{$key} ne undef) {
         $out .= (($out ne undef) ? ";" : "") . $key .":". safe($$hash{$key});
      }
   }

   return $out;
}

sub save
{
   my ($conn,$type,$key) = @_;

   if($type eq "STATE") {
      if(defined @state{$key}) {
         save_entry("%s:\"%s\"",$key,single(@state{$key}));
      } else {
         save_entry("%s:\"%s\"",$key,"%DELETE%");
      }
   } elsif($type eq "WORLD") {
      if(defined @address{$key}) {
         save_entry("%s:{%s}",$key,hash_dump(@address{$key}));
      } else {
         save_entry("%s:{%s}",$key,"%DELETE%");
      }
   } else {
      echo($conn,"Invalid 'save' request");
   }
}

#
# seperate
#   grab a block of text that ends with a $sep seperator. Honor escaped
#   characters and drop the "\" as an escape character when found.
#
sub seperate
{
   my ($sep,$txt) = @_;
   my $result;

   my $len = length($txt);
   for(my $i = 0;$i < $len;$i++) {
      if(substr($txt,$i,1) eq "\\") {
         $result .= substr($txt,$i+1,1);
         $i++;
      } elsif(substr($txt,$i,1) eq $sep) {
         return (substr($txt,$i+1),$result);
      } else {
         $result .= substr($txt,$i,1);
      }
   }
   return (undef,$result);
}

#
# hashsplit
#    take a string and split it into a hash. The format is the key name
#    seperated by a colon and ending with a semi-colon. Semi-colons may
#    be escaped out if they are not significant. This format then repeats.
#
#    Format: <key>:<value>;<key .. >
#    
sub hashsplit
{
   my ($world,$txt) = @_;
   @address{$world} = {};
   my $val;

   while($txt =~ /^([^:]+):/) {
      ($txt,$val)  = seperate(";",$');
      @address{$world}->{$1} = $val;
   }
}

sub cmd_sync
{
   my ($conn,$txt) = @_;
   my $fd;

   open($fd,"> @ENV{HOME}/.muddler") ||
      e("Unable to open .muddler for writing");
   @state{save_fd} = $fd;

   for my $world (keys %address) {
      save($conn,"WORLD",$world);
   }

   for my $key (grep {/^p_/} keys %state) {
      save($conn,"STATE",$key);
   }
}

#
# cmd_request_info
#    The user on the remote interface just requested information that is
#    stored on the "local" process. Send a message requesting this
#    information.
#
sub cmd_request_info
{
   my ($conn,$txt) = (shift,lc(trim(shift)));
   my $out;

   if(!module_enabled("Data::Dumper")) {
      return echo($conn,"%% remote /editor disabled due to missing " .
         "Data::Dumper module");
   }
   if(!module_enabled("MIME::Base64")) {
      return echo($conn,"%% file transfers disabled due to missing " .
         "MIME::Base64 module");
   }

   if(!is_remote()) {
      return echo($conn,"%% request_info is an internal command and cannot " .
                        "be used directly.");
   } elsif(defined @address{$txt}) {
      ws_echo($conn,"r",mydump($txt,@address{$txt}));
   } else {
      LOGGIT("Invalid world. '$txt'");
   }
}

sub make_safe
{
   my $txt = encode_base64(shift);
   $txt =~ s/\r|\n//g;
   return $txt;
}

sub mydump
{
    my ($id,$hash) = @_;
    my @out;

    for my $key (keys %$hash) {
       push(@out,make_safe($key) . ":" . make_safe($$hash{$key}));
    }
    return $id . ":" . join(',',@out);
}

sub undump
{
   my $txt = shift;
   my ($id, %hash);

   if($txt =~ /^([^:]+):/) {
      $id = $1;
     $txt = $';
      while($txt =~ /^([^:,]+):([^:,]+),{0,1}/) {
         $txt = $';
         @hash{decode_base64($1)} = decode_base64($2);
      }
   }
   return $id, \%hash;
}

#----------------------------------------------------------------------------#
#                                                                            #
#  end dialog support                                                        #
#                                                                            #
#----------------------------------------------------------------------------#


sub items
{
   my $txt = shift;

   my @list = (split(',',$txt));
   return $#list + 1;
}

sub words
{
    my $text = shift;

    my $num; 
    $num++ while $text =~ /\S+/g;     #/
    return $num
}

sub cmd_accept
{
   my ($conn,$txt) = @_;

   if(defined @socket{$conn}->{ft}) {
      out($conn,"\@pemit #%s=#%d# file approved for download",
         @socket{$conn}->{ft}->{dbref},@socket{$conn}->{ft}->{id});
      @socket{$conn}->{ft}->{approved} = 1;
      echo($conn,"%% File transfer from %s(#%s) accepted.",
         @socket{$conn}->{ft}->{name},
         @socket{$conn}->{ft}->{dbref});
   } else {
      echo($conn,"%% No requested file transfers have been offered.");
   }
}

sub cmd_file
{
   my ($conn,$txt) = @_;
   my ($fh, $content,$name,$file);

   if(!module_enabled("MIME::Base64")) {
      return echo($conn,"%% file transfers disabled due to missing " .
         "MIME::Base64 module");
   } elsif($txt =~ /=/) {
      ($name,$file) = (trim($`),trim($'));
   } else {
      return echo($conn,"%% usage: /file <person> = <filename>");
   }

   if(!-e $file) {
      echo($conn,"%% File '%s' does not exist.",$file);
   } else {
      open($fh,$file) ||
         return echo($conn,"%% Could not open '%s' for reading",$file);
      binmode($fh);

      {
         local $/;
         $content =  <$fh>;
      };
      close($fh);

      @socket{$conn}->{ftsend} = { fn  => $file,
                                   data=>[split(/\n/,encode_base64($content))],
                                   pos => 0,
                                   id  => time(),
                                   name => $name,
                                   approved => 0,
                                 };

      @socket{$conn}->{ftsend}->{size} =
          length(join('',@{@socket{$conn}->{ftsend}->{data}}));
      out($conn,"\@pemit %s=#%s# Request from %%n(%%#): fn=%s, sz=%d",
          "*" . $name,
          @socket{$conn}->{ftsend}->{id},
          $file,
          @socket{$conn}->{ftsend}->{size}
         );
      echo($conn,"%% $file file offered to $name.");
   }
}

sub cmd_window
{
#-# summary: Open window showing output matching pattern.
#-# ------------------------------------------------------------------------
#-# /window <pattern>
#-#
#-#      Fires off another terminal window that will only show those
#-#      lines that match <pattern> as they show up. 
#-#
#-#      Behind the scenes:
#-#         This command will startup another instance of muddler in
#-#         another window. That additional instance will connect via
#-#         websockets to the first instance. The two copies of muddler
#-#         will then relay the text that matches <pattern>.
#-#
#-#         For this to work, the following settings need to be set:
#-#
#-#            /web on
#-#            /set terminal=<your prefered xterm>
#-#            /password <secure password>
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;


   if($txt =~ /^\s*kill\s*$/) {
      delete @state{window};
   } elsif($txt =~ /^\s*socket\s*=\s*(\d+)$/) {
      if(defined @state{window} && 
         defined @state{window}->{$1}) {
         @state{window}->{$1}->{sock} = $conn;
         @state{reverse_window}->{$conn} = $conn;
      } else {
         echo($conn,"%% Window session $1 does not exist");
         ws_disconnect($conn);
      }
   } elsif($txt =~ /^\s*value\s*=\s*(\d+)\s*/) {
      my ($id,$glob,$good) = ($1,trim($'),0);
      my $reg = glob2re($glob);
      eval {                                      # check if pattern is bad
         if ("badglob" =~ /$reg/) {
            # nothing
         } 
         $good = 1;
      };
      return echo($conn,"%% Invalid pattern '%s' specified",$glob) if(!$good);

      @state{window} = {} if !defined @state{window};
      @state{reverse_window} = {} if !defined @state{reverse_window};

      @state{window}->{$id} = {                         # store window info
         glob    => $glob,
         regexp  => $reg,
         created => time()
      };
      
   } elsif((is_remote() || is_web($conn)) && length $txt) {
      my $t = time();
      wc_out("/window value=%s %s\n",time(),$txt);
      if(length $txt) {
         @state{terminal_app} = "/usr/bin/xfce4-terminal -x ";
         system("@state{terminal_app} perl ./muddler --remote=" .
                "@state{remote_address} --window=$t &");
      }
   } elsif(!length $txt && is_remote()) {
      wc_out("/window");
   } elsif(!length $txt) {
      if(!defined @state{window} || scalar keys %{@state{window}} == 0) {
         echo($conn,"%% No window monitoring patterns defined.");
      } else {
         echo($conn,"%15s | %-15s | %20s | %s",
              "Id",
              "Status",
              "Host",
              "Pattern"
             );
         for my $key (keys %{@state{window}}) {
            my $hash = @state{window}->{$key};
            if(!defined $$hash{sock} && time() - $$hash{created} > 60) {
               echo($conn,"%15s | %-15s | %20s | %s",
                    $key,
                    "timeout-deleted",
                    $$hash{glob}
                   );
               delete @state{window}->{$key};
            } elsif(!defined $$hash{sock}) {
               echo($conn,"%15s | %-15s | %20s | %s",
                    $key,
                    "unconnected",
                    "N/A",
                    $$hash{glob});
            } elsif(!defined @ws{$$hash{sock}}) {
               echo($conn,"%15s | %-15s | %20s | %s",
                    $key,
                    "active",
                    "orphaned?",
                    $$hash{glob}
                   );
               delete @state{window}->{$key};
            } else {
               echo($conn,
                    "%15s | %-15s | %20s | %s",
                    $key,
                    "active",
                    @ws{$$hash{sock}}->{ip},
                    $$hash{glob}
                   );
            }
         }
      }
   } else {
      if(is_remote()) {
         echo($conn,"Usage: /window or /window <pattern>");
      } else {
         echo($conn,"Usage: /window");
      }
   }
}

#
# cmd_blurred
#   The browser has just told muddler that the document/tab/whatever
#   is no longer focused. This will be used for activity notifications.
#
sub cmd_blurred
{
   my ($conn,$txt) = @_;

   @ws{$conn}->{active} = 0 if(is_web($conn));
}

#
# cmd_blurred
#   The browser has just told muddler that the document/tab/whatever
#   is no focus. This will be used for activity notifications.
#
sub cmd_focused
{
   my ($conn,$txt) = @_;

   @ws{$conn}->{active} = 1 if(is_web($conn));
   release_some_pending($conn,world($conn));
}

#
# cmd_dc
#   Disconnect from a the current world.
#
sub cmd_dc
{
#-# summary: Disconnect from the current world.
#-# ------------------------------------------------------------------------
#-# /dc
#-# /dc [<world>]
#-#
#-#      Disconnect from from the current world or from a named world.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt eq "" && defined @socket{$conn} && defined @socket{$conn}->{sock}) {
      history(world($conn),"% Connection closed to $conn.");
      socket_disconnect(@socket{$conn}->{sock});
   } elsif(defined @address{lc(trim($txt))} && 
           defined @socket{lc(trim($txt))}) {
      if(defined @socket{lc(trim($txt))}->{sock}) {
         history(world($conn),"% Connection closed to $conn.");
         socket_disconnect(@socket{lc(trim($txt))}->{sock});
       } else {
         history(world($conn),"% Connection already closed.");
       }
   } else {
      history(world($conn),"% Connection already closed.");
   }
}

sub cmd_stat
{
   my ($conn,$txt) = @_;
   my (%stat, %cache, $max,$sock, %lines);

#   @history{dev} = [];
#   delete @history{dev};
#   @socket{dev}->{history_pos} = -1;
#   @socket{dev}->{history_pos_partial} = -1;

   for my $world (keys %history) {
      $max = length($world) if length($world) > $max;
      for my $i (0 .. $#{@history{$world}}) {
         @stat{$world} += length(@history{$world}->[$i]->{txt});
         @lines{$world} += 1;
      }

      my $cache = @state{cache};
      for my $id (keys %{$$cache{$world}}) {
         for my $y (keys %{$$cache{$world}->{$id}}) {
            @cache{$world} += length($$cache{$world}->{$id}->{$y}->{txt});
         }
      }
   }
   for my $world (keys %stat) {
      if(defined @socket{$world} && defined @socket{$world}->{sock}) {
         $sock = @socket{$world}->{sock};
      } else {
         $sock = "N/A";
      }
      echo($conn,"%% %*s : %10s  %10s",
           $max,$world,@stat{$world},@lines{$world});
   }

   for my $world (keys %stat) {
      if(!defined @socket{$world} || !defined @socket{$world}->{sock}) {
         delete @socket{$world};
         delete @history{$world};
      }
   }

#   @history{ascii} = [];
#   delete @history{ascii};
#   @socket{ascii}->{history_pos} = -1;
#   @socket{ascii}->{history_pos_partial} = -1;
}


sub cmd_perl
{
   my ($conn,$txt) = @_;
#-# summary: Run an native perl command.
#-# ------------------------------------------------------------------------
#-# /perl <command>
#-#
#-#      Runs the specified command directly via eval(); The <command> 
#-#      needs to be valid perl command(s).    
#-#
#-# ------------------------------------------------------------------------
   eval($txt);
}

sub vencode
{
   my ($conn,$value) = @_;
   my $enc;

   if($value =~ /^\s*(utf8|cp437|iso-8859-1)\s*$/i) {
      $enc = lc($1);
   } elsif($value =~ /^\s*fansi\s*$/) {
      $enc = "cp437";
   } elsif($value =~ /^\s*latin\s*$/) {
      $enc = "iso-8859-1";
   } elsif($value =~ /^\s*\+\s*([^ ]+)\s*$/) {
      $enc = $1;
   } else {
      echo($conn,"%% Recommended encodings are utf, fansi, and latin.");
      return echo($conn,"%% Non-tested encodings can be set with: " . 
          "/set encode = + <encoding_name>");
   }

   if(!defined @address{world($conn)}) {
      return echo($conn,"%% Not connected to a world");
   }

   if(!module_enabled("Encode")) {
      return echo($conn,"%% Encoding disabled with Encoding module missing");
   }

   eval {
      decode($enc,"this is a test");
   };
   if($@) {
      return echo($conn,"%% Encoding '%s' not supported.",$value);
   } else {
      @address{world($conn)}->{decode} = $enc;
      save($conn,"WORLD",world($conn));
   }
}

# undef= can value be undef/empty/null
# fn   = is the value a file name
# set  = should cmd_set save the variable
# fun  = function to run to handle variable
# pfun  = function to run to handle variable (run post setting)
sub var_init
{
   for my $key (keys %var) {
      delete @var{$key};
   }
  
   @var{cert}      = { web=>"SSL Cert File",type=>"text",null=>1,fn=>1,
                       set=>1                                              };
   @var{key}       = { web=>"SSL Key File",type=>"text",null=>1,fn=>1,
                       set=>1                                              };
   @var{input_size}= { setup=>"Input Size",type=>"num",
                       pfun=>sub { draw_screen(@_);}                       };
   @var{port}      = { web=>"Port",type=>"num",set=>1                      };
   @var{encode}    = { fun => sub { vencode(@_); }                         };
   @var{debug}     = { set=>1                                              };
   @var{password}  = { web=>"Password",type=>"word",set=>1                 };
   @var{allow}     = { web=>"Allow List",type=>"text",set=>1, null=>1      };
   @var{web}       = { web=>"Web Interface On",type=>"check",set=>1        };
   @var{watchdog}  = { setup=>"WatchDog Matching",type=>"check",set=>1,
                       chk => "on|off|0|1"                                 };
   @var{theme}     = { web=>"Theme",type=>"cycle.light.dark",set=>1, 
                       chk => "light|dark", 
                       fun => sub { ws_all("d","theme " . @_[1]); }        };
   @var{keepalive} = { set=>1, null=>1,fun => sub { update_keepalive(@_)}  };
   @var{overlap}   = { set=>1, chk => "\\d+"                               },
   @var{sync}      = { setup=>"All windows show same world",type=>"check",
                       set=>1, chk => "on|off|0|1",
                       fun => sub { switch_world(@_,@state{world}); }      };
   @var{updown}    = { setup=>"Up/Down Keys",
                       type=>"cycle.Cycle Worlds.Cursor Movement",
                       chk => "Cycle Worlds|Cursor Movement", set=>1       };
   @var{more}      = { setup=>"Pause for More",type=>"check",set=>1        };
   @var{reconnect} = { setup=>"Auto re-connect",type=>"check",set=>1,
                       chk=>"on|off|0|1"                                   };
   @var{spell}     = { setup=>"Enable Spell Check",type=>"check",set=>1,
                       chk=>"on|off|0|1"                                   };
}

sub update_keepalive
{
   my ($conn,$val) = @_;

   @address{world($conn)}->{keepalive} = $val;
   save($conn,"WORLD",world($conn));
   echo($conn,"% Keepalive for %s set to: %s",world($conn),$val);
}

sub cmd_set
{
#-# summary: Set internal variables to customize muddler
#-# ------------------------------------------------------------------------
#-# /set [list]
#-#   Use an settings editor to modify Muddler's preferences or list all
#-#   variables.
#-#
#-# /set <variable> = <value>
#-#   Sets the variable to a value.
#-#
#-# Variables:
#-#   cert       : Full path & filename to certificate file for /web
#-#   key        : Full path & filename to key file for /web
#-#   input_size : Input window size in rows when using the console
#-#   port       : Port used for incoming connections for /web
#-#   encode     : Set encoding style to either fansi, utf8, or latin.
#-#   debug      : Turns debugging on for logging to muddler.log file.
#-#   password   : Password required to log for /web
#-#   allow      : Allow hostname(s) via web interface without a password
#-#   watchdog   : Supress spam when 2-5 duplicate lines are found
#-#   theme      : Select either a dark or light theme for /web
#-#   overlap    : number of lines kept on the screen from the previous
#-#                "page" of text to give context.
#-#   sync       : Keep the viewed world in the same on console/web
#-#   reconnect  : Reconnect to world upon a connect to the web interface
#-#   keepalive  : Sets the keepalive for the current world
#-# ------------------------------------------------------------------------
my ($conn,$txt) = @_;
   my $enc;

   if($txt eq "") {
      return echo($conn,"%% Sorry, the settings editor is only " .
         "compatible with the console.") if(is_web($conn));

      my (@fields,@values);
      for my $i (sort {@var{$b}->{type}.@var{$b}->{setup} cmp
                       @var{$a}->{type}.@var{$a}->{setup}} keys %var) {
         if(defined @var{$i}->{setup}) {
            push(@fields,"@var{$i}->{setup}:@var{$i}->{type}");
         }
      }
      dialog_init($conn,
                  join(",",@fields),
                  ["Cancel:dialog_cancel","Save:set_save"],0);
      my $pos = 1;
      for my $i (sort {@var{$b}->{type}.@var{$b}->{setup} cmp
                       @var{$a}->{type}.@var{$a}->{setup}} keys %var) {
         if(defined @var{$i}->{setup}) {
            if(@var{$i}->{type} eq "check") {
               if(@state{"p_$i"} eq " " || @state{"p_$i"} eq "0") {
                  dialog_populate($pos," ");
               } else {
                  dialog_populate($pos,"x");
               }
            } elsif(defined @state{"p_$i"} && trim(@state{"p_$i"}) ne "") {
               dialog_populate($pos,@state{"p_$i"});
            }
            $pos++;
         }
      }
      return draw_screen($conn);
   } elsif($txt =~ /^\s*([^=]+?)\s*=\s*/) {
      my ($name,$val) = ($1,$');
      if(defined @var{$name}) {
         if(defined @var{$name}->{chk}) { 
            if($val =~ /^\s*(@var{$name}->{chk})\s*$/) {
               $txt = $val;
            } else {
               return echo($conn,"%% %s expects a value of: %s\n",$name,
                  join(", ",split(/\|/,@var{$name}->{chk})));
            }
         }
         if(!length $val) {
            if(@var{$name}->{null}) {
               echo($conn,"%% Variable '%s' has been removed.",$name);
            } else {
               return echo($conn,
                           "%% A value is required for variable '%s'",
                           $name
                          );
            }
         } else {
            if(@var{$name}->{fn}) {
               echo($conn,"%% file '%s' does not exist.",$val);
            }
         }

         if(@var{$name}->{fun} ne undef) {
            &{@var{$name}->{fun}}($conn,$val);
         }
         
         if(defined @var{$name}->{set} && @var{$name}->{set} == 1) {
            @state{"p_$name"} = trim($val);
            save($conn,"STATE","p_$name");
            if(length trim($val)) {
               if(@state{state} ne "init") {
                  echo($conn,
                       "%% Variable %s has been set to '%s'",
                       $name,trim($val)
                      );
               }
            } elsif(@state{state} ne "init") {
               echo($conn,"%% Variable %s has been deleted.",$name);
            }
         }

         if(@var{$name}->{pfun} ne undef) {
            &{@var{$name}->{pfun}}($conn,$val);
         }
      } else {
         echo($conn,"%% Unknown variable '%s'",$name);
         echo($conn,"%% Valid variables are: ");
         echo($conn,"%%    %s\n",join(', ',keys %var));
      }
   } elsif($txt =~ /^\s*list\s*$/) {
      cmd_showset(@_);
   } else {
      cmd_showset(@_,$txt);
   }
}

sub cmd_common
{
#-# summary: Connect to multiple worlds in one command.
#-# ------------------------------------------------------------------------
#-# /common
#-#      Connect to a list of places that someone might frequent often.
#-# /common list
#-#      Shows the list of worlds that are currently setup within /common
#-# /common -world
#-#      Deletes a world from the list of common worlds.
#-# /common world
#-#      Adds a world to the list of common worlds.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my %list;

   for my $world (split(/:/,@state{p_common})) {
      @list{trim($world)} = 1;
   }

   if($txt =~ /^\s*list\s*$/) {
      echo($conn,"%% Worlds: %s\n",join(', ', keys %list));
   } elsif($txt =~ /^\s*$/) {
      if(scalar keys %list == 0) {
         echo($conn,"%% No worlds defined in /common.");
      } else {
         for my $world (keys %list) {
            cmd_world(@state{world},$world);
         }
      }
      return;
   } elsif($txt =~ /^\s*-\s*/) {
      if(defined @list{trim($')}) {
         delete @list{trim{$'}};
         @state{p_common} = join(":",keys %list);
         save($conn,"STATE","p_common");
      } else {
         echo($conn,"%% Worlds '%s' not defined in /common",trim($'));
      }
   } else {
      if(defined @list{trim($txt)}) {
         echo($conn,"%% Worlds '%s' already defined in /common",trim($txt));
      } elsif($txt =~ /:/) {
         echo($conn,"%% World name may not contain \":\"");
      } else {
         @list{trim($txt)} = 1;
         @state{p_common} =  join(":",keys %list);
         save($conn,"STATE","p_common");
      }
   }
}

sub cmd_log
{
#-# summary: Log a message to muddler.log
#-# ------------------------------------------------------------------------
#-# /log <message>
#-#
#-#      Logs <message> to muddlers log file if debugging is enabled.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   LOGGIT("log: $txt");
}

#
# safe_match:
#   See if $pat matches $txt. If $pat doesn't contain a pattern then its
#   considered a match. $pat could be a malformed regexp which would cause
#   an error,  so protect against that situation too.
#
sub safe_match
{
   my ($txt,$pat) = @_;

   return 1 if $pat eq undef;

   my $match = 0;
   eval {
      $match = 1 if($txt =~ /^\s*$pat\s*$/);
   };
   return $match;
}

sub cmd_showset
{
#-# ------------------------------------------------------------------------
#-# /set
#-#
#-#      Lists all variables that have been set that are preserved 
#-#      across restarts of muddler.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my ($count,$pat) = (0);

#   echo($conn,"# cache hits      %s",@state{cached});
#   echo($conn,"# cache misses    %s",@state{nocache});
#
#   if(defined @state{cache}) {
#      my $cache = @state{cache};
#      for my $w (keys %$cache) {
#         for my $id (keys %{$$cache{$w}}) {
#            $count += scalar keys %{$$cache{$w}->{$id}}
#         }
#      }
#      echo($conn,"# cache_size      %s",$count);
#   }
   $pat = glob2re($txt) if($txt ne undef);
   for my $key (keys %state) {
      if(@state{$key} !~ /^\s*(0|off)\s*$/ && $key =~ /^p_/) {
         if(safe_match($',$pat)) {
            echo($conn,"# %-15s %s",$',@state{$key});
         }
      }
   }
 
   if($pat eq undef && defined @address{world($conn)} &&
      defined @address{world($conn)}->{decode}) {
      echo($conn,"# %-15s %s","encode",@address{world($conn)}->{decode});
   }
   if($pat eq undef && defined @address{world($conn)} &&
      defined @address{world($conn)}->{keepalive}) {
      echo($conn,"# %-15s %s","keepalive",@address{world($conn)}->{keepalive});
   }
   if($pat eq undef) {
   echo($conn,"# %-15s %sx%s","screen size",@state{size_x},@state{size_y});
   }
}

#
# cmd_mobile
#
sub cmd_mobile
{
#-# summary: internal
#-# ------------------------------------------------------------------------
#-# /mobile [on|off]
#-#
#-#      Enable a tweaks for the web/webosocket interface that should make
#-#      mobile browsers more useable. This includes showing buttons for
#-#      keys which the mobile users may not have.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if(is_console($conn)) {
      return echo($conn,"%% /mobile is only for web/websocket sessions");
   } elsif(!is_web($conn)) {
      return echo($conn,"%% /mobile is only for web/websocket sessions");
   } elsif($txt =~ /^\s*(on|1|enable)\s*$/) {
      @ws{$conn}->{mobile} = 1;
      ws_echo($conn,"d","mobile on");                    # tell js to turn on
   } elsif($txt =~ /^\s*(off|1|disable)\s*$/) {
      @ws{$conn}->{mobile} = 0;
      ws_echo($conn,"d","mobile off");                  # tell js to turn off
   } elsif($txt =~ /^\s*$/) {
      if(@ws{$conn}->{mobile} == 1) {
         @ws{$conn}->{mobile} = 0;
         ws_echo($conn,"d","mobile off");            # tell js to turn on off
      } else {
         @ws{$conn}->{mobile} = 1;
         ws_echo($conn,"d","mobile on");                 # tell js to turn on
      }
   }
}


sub cmd_update
{
#-# summary: Download & update muddler's code.
#-# ------------------------------------------------------------------------
#-# /update
#-#
#-#      Downloads the newest copy of muddler from github and loads it.
#-#      muddler may need to be restarted to work properly but also may not.
#-#
#-# ------------------------------------------------------------------------
   my $conn = shift;
   my $update;

   open($update,"wget -q -O muddler.tmp --no-cache " .
        "https://github.com/c-hudson/muddler/raw/master/muddler " .
        " |") ||
      return echo("muddler",
                  "%% Unable to update muddler at this time. Does wget exist?"
                 );
   while(<$update>) {
   }
   close($update);

   unlink("muddler");
   rename("muddler.tmp","muddler");
   system("chmod u+x muddler");
   reload_code($conn);
}

sub cmd_more
{
#-# summary: Pause output when lots of output shown.
#-# ------------------------------------------------------------------------
#-# /more [on|off]
#-#
#-#      Enables or disables more prompting that pauses the screen if
#-#      text is arriving to quickly.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt =~ /^\s*(1|on)\s*$/) {
      if(@state{state} eq "init") {
         echo($conn,"%% \"More\" paging enabled.  Use TAB to scroll.");
      }
      @state{p_more} = 1;
      save($conn,"STATE","p_more");
   } elsif($txt =~ /^\s*(0|off)\s*$/) {
      if(@state{state} eq "init") {
         echo($conn,"%% \"More\" paging disabled.");
      }
      @state{p_more} = 0;
      save($conn,"STATE","p_more");
   } elsif($txt =~ /^\s*$/) {
      echo($conn,"%% more is %s",(@state{p_more} eq 1) ? "on" : "off");
   } else {
      echo($conn,"% Invalid more syntax, syntax is: /more [on|off]");
   }
}

sub cmd_console
{
#-# summary: Turn on/off the console output
#-# ------------------------------------------------------------------------
#-# /console <on|off>
#-#
#-#      Turn the console on or off. The console output can be re-
#-#      enabled via a web/websocket interface.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($txt =~ /^\s*(on|1|enable)\s*$/) {
      @state{console} = 1;
      cbreak();
      draw_screen(@state{world},1);
   } elsif($txt =~ /^\s*(off|0|disable)\s*$/) {
      revert_console();
      clear_screen($conn);
      @state{console} = 0;
      if(@state{p_web} == 0) {
         cmd_web($conn,"on");
         printf("%% WeB enabled due to disabling console. Connect via:\n");
         printf("%%   http://localhost:@state{p_port}, Password: @state{p_password}");
      }
   } else {
      echo($conn,"%% usage: /console <on|off>");
   }
}

sub encoding_init
{
   @state{encoding} = {};
   @state{encoding}->{default} = "utf8";
   @state{encoding}->{utf8} = "utf8";
   @state{encoding}->{cp437} = "fansi";
   @state{encoding}->{"iso-8859-1"} = "latin";
}

sub encoding_values
{
   my %list;

   for my $key (keys %{@state{encoding}}) {
      @list{@state{encoding}->{$key}} = 1;
   }
   return keys %list;
}


sub encoding_translate
{
   my $txt = shift;

   if(defined @state{encoding}->{$txt}) {
      return @state{encoding}->{$txt};
   } else {
      return $txt;
   }
}

sub encoding_detranslate
{
   my $txt = shift;

   for my $key (keys %{@state{encoding}}) {
      if($txt eq @state{encoding}->{$key} && $key ne "default") {
         return $key;
      }
   }

   return @state{encoding}->{default};
}

sub cmd_editor
{
#-# summary: Edit/define a world that can be connected to.
#-# ------------------------------------------------------------------------
#-# /edit [or /editor]
#-# /edit <world>
#-#      This command will show a "world editor" input window at the
#-#      bottom of the screen. Enter/edit the values as needed to
#-#      setup a world that can be connected to. Use the tab/return
#-#      to switch between fields/buttons. Hitting escape twice will
#-#      will do the same as selecting the cancel button.
#-#
#-#      Note: A world editor has not been written for the web interface
#-#            yet. Use the below commandline when editing/defining worlds.
#-#
#-# /edit [-s] <name> [<user> <pass>] <host> <port>
#-#
#-#      Adds a world or overwrites an existing world. If a username and
#-#      password are provided, muddler will issue a connect command
#-#      to log into the user.
#-#
#-#      Options:
#-#         -s   Use ssl to connect to the world.
#-# ------------------------------------------------------------------------
   my ($conn,$txt,$noremote) = @_;
   my $w = world($conn);
   my $opt = {};

   return echo($conn,"%% Sorry, the world settings editor is only " .
      "compatible with the console.") if(is_web($conn));

   my $txt = getopt("sl",trim($txt),$opt);
   my @field = split(" ",$txt);

   # trim all fields and lc the first field
   for my $i (0 .. $#field) {
      if($i == 0) {
         @field[0] = lc(trim(@field[0]));
      } else {
         @field[$i] = trim(@field[$i]);
      }
   }
   if((is_console($conn) || is_remote()) && 
      ($#field == -1 || $#field == 0)) {  # use a dialog
      if($#field == -1 && (@state{world} ne "muddler" || is_remote())) {
         @field[0] = world($conn);
      }
      if(is_remote() && @field[0] ne "" && !$noremote) {
         return wc_out("/request_info @field[0]");
      }
      dialog_init($conn,
                  "World Name:word," .
                  "User:word," .
                  "Password:word,Host:word," .
                  "Port:word," .
                  "KeepAlive CMD:text," .
                  "Log File:text,".
                  "Encoding:cycle." . join(".",encoding_values()) .",".
                  "Use SSL to connnect:check," .
                  "Auto Reconnect w/web interface:check",
                  ["Cancel:dialog_cancel",
                   "Save:editor_save",
                   "Delete:editor_delete",
                   "Connect:editor_connect"],1);
      if($#field == 0) {
         dialog_populate(1,@field[0]);
         if(defined @address{@field[0]}) {
            if(defined @address{@field[0]}->{user}) {
               dialog_populate(2,@address{@field[0]}->{user});
            }
            if(defined @address{@field[0]}->{pass}) {
               dialog_populate(3,@address{@field[0]}->{pass});
            }
            if(defined @address{@field[0]}->{host}) {
               dialog_populate(4,@address{@field[0]}->{host});
            }
            if(defined @address{@field[0]}->{port}) {
               dialog_populate(5,@address{@field[0]}->{port});
            }
            if(defined @address{@field[0]}->{keepalive}) {
               dialog_populate(6,@address{@field[0]}->{keepalive});
            } else {
               dialog_populate(6,"@@ idle");
            }
            if(defined @address{@field[0]}->{decode}) {
               dialog_populate(8,
                   encoding_translate(@address{@field[0]}->{decode}));
            }
            if(defined @address{@field[0]}->{ssl} && 
               @address{@field[0]}->{ssl} == 1) {
               dialog_populate(9,"x");
            }
            # if(defined @address{@field[0]}->{log} &&
            #    @address{@field[0]}->{log} eq "1") {
            #    dialog_populate(9,"x");
            # }
         }
      }
      return draw_screen($conn);
   }

   return wc_out("/editor $txt") if(is_remote());
   my $append = 0;

   $append = 1 if(!defined @address{trim(lc(@field[0]))});

   if(trim(@field[0]) =~ /^p_/) {
      echo($conn,"%% World names may not start with 'p_' at this time");
   } elsif($#field == 2) {
      @address{@field[0]} = { host => @field[1],
                              port => @field[2],
                              name => @field[0],           # preserve case
                              ssl  => 0,
                              log  => 0
                            };
   } elsif($#field == 4) {
      @address{@field[0]} = { name => @field[0],           # preserve case
                              user => @field[1],
                              pass => @field[2],
                              host => @field[3],
                              port => @field[4],
                              ssl  => 0,
                              log  => 0
                            };
   } elsif($#field == 5) {                                         # has type
      @address{@field[0]} = { name => @field[0],              # preserve case
                              user => @field[2],                  # skip type
                              pass => @field[3],
                              host => @field[4],
                              port => @field[5],
                              ssl  => 0,
                              log  => 0
                            };
   } else {
      return cmd_help($conn,"add");
   }

   @address{@field[0]}->{ssl} = 1 if($$opt{s});
   @address{@field[0]}->{log} = 1 if($$opt{l});

   save($conn,"WORLD",@field[0]);
}

sub chksum
{
   if(module_enabled("Digest::MD5")) {
      my $chk = Digest::MD5->new;
      $chk->add(shift);
      return $chk->hexdigest;
   } else {
      return unpack("%32W*",shift) % 65535;
   }
}

sub save_entry
{
   my ($fmt,@args) = @_;
   my $fd;

   if(ref(@state{save_fd}) ne "GLOB") {
      open($fd,">> @ENV{HOME}/.muddler") ||
         e("Unable to open .muddler for writing");
      @state{save_fd} = $fd;
   } else {
      $fd = @state{save_fd};
   }

   seek($fd,0,SEEK_END);
   # optionally add return at end of the line
   my $txt = sprintf("$fmt",@args);
   printf($fd "%s",$txt . (($txt =~ /\n$/) ? "" : "\n"));
   $fd->flush;
}

sub load
{
   my ($conn,$quiet) = @_;
   my ($file,$name,$data);

   if(!open($file,"@ENV{HOME}/.muddler")) {
      if(!$quiet) {
         echo($conn,"%% Unable to open @ENV{HOME}/.muddler for reading");
         return 0;
      }
   }

   while(<$file>) {
      my $orig = $_;
      s/\r|\n//g;
      if(/^([^: ]+):{(.*)}$/) {                # handle new world format
         if($2 eq "%DELETE%") {
            delete @address{$1};
         } else {
            hashsplit($1,$2);
         }
      } elsif(/^([^: ]+):"(.*)"$/) {               # handle new set format
         if($2 eq "%DELETE%") {
            delete @state{$1};
         } else {
            @state{$1} = $2;
         }
      } elsif(/^\s*state:([^:]+):/) {              # state variable values
         @state{$1} = $';
      } elsif(/^\s*([^ ]+)\s*{\s*$/) {                   # start of segment
         $name = $1;
         delete @$data{keys %$data};
      } elsif(/^\s*([^:]+)\s*:\s*/) {                      # segment value
         if($name eq undef) {
            return echo($conn,"% Corrupted .muddler file found on line $.");
         }
         $$data{$1} = $';
      } elsif(/^\s*}\s*$/) {                             # end of segment
         if($$data{type} eq "address") {          # segment was an address
            @address{$name} = { %$data };
         }
         $name = undef;
      } else {
        echo($conn,"% Corrupted @ENV{HOME}/.muddler file found on line $. - '%s'",$_);
        close($file);
        return 1;
      }
   }
   close($file);
   return 1;
}

sub cmd_null
{
#-# ------------------------------------------------------------------------
#-# /null
#-#      Do nothing
#-# ------------------------------------------------------------------------
   # do nothing for now
}


#
# connected:
#    Determine if a world is connected or not.
#
sub connected
{
   my $world = lc(shift);

   if(defined @socket{$world} && 
      defined @socket{$world}->{sock} &&
      @socket{$world}->{sock}->connected()) {
      return 1;
   } else {
      return 0;
   }
}

#
# is_loggedin
#    Determine if your character is logged in yet or at least should
#    have been logged in. You have 360 seconds to log in, you have been
#    warned but only if you read the code.
#
sub is_loggedin
{
   my ($conn) = @_;
   my $w = world($conn);

   if(defined @socket{$w}->{sock}) {
      @socket{$w}->{created} = time() if !defined @socket{$w}->{created};

      if((@socket{$w}->{do_login} && @socket{$w}->{connected}) ||
         time() - @socket{$w}->{created} > 360) {
         return 1;
      }
   }
   return 0;
}

sub cmd_send
{
#-# summary: Sends text directly to a world.
#-# ------------------------------------------------------------------------
#-# /send [-w -W -n] <text> 
#-#
#-#      Sends <text> to the current world or a specified world with -w.
#-# Options
#-#    -w<world>    Sends <text> to the <world> world.
#-#    -W           Sends <text> to all connected worlds.
#-#    -n           Sends <text> without a \r\n [not implimented yet]
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $hit = 0;
   my $opt = {};

   my $str = getopt("w:Wn",$txt,$opt);

   # send to all worlds & send to just one world can't be defined
   if(defined $$opt{w} && defined $$opt{W}) {
      return echo($conn,"%% send: You may not use -w and -W at the same time.");
   }

   # default to current world.
   if(!defined $$opt{W} && !defined $$opt{w}) {
      $$opt{w} = world($conn);
   }

   for my $key (keys %socket) {
      if((defined $$opt{W} || (defined $$opt{w} && lc($$opt{w}) eq $key)) &&
         connected($key)) {
         $hit++;
         out($key,"%s",$str);
      }
   }

   if(!$hit && defined $$opt{w}) {
      return echo($conn,"%% send: Not connected.");
   } elsif(!$hit) {
      return echo($conn,"%% send: Not connected to any worlds.");
   }
}


sub cmd_listdef
{
#-# summary: Lists all defined triggers or user defined commands
#-# ------------------------------------------------------------------------
#-# /listdef <pattern>
#-#
#-#      Lists all defines or any matching <pattern>
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $w = world($conn);
   my $opt = {};
   my $pat;
   my $wmax = 5;
   my $nmax = 3;
   my $cwin = min_size($w);
   $cwin = 50 if $cwin < 50;

   my $str = getopt("sSm:t:b:B:E:T:h:a:P:iIw:",$txt,$opt);

   for my $key (keys %def) {
      if(($pat eq undef || $key =~ /^$pat$/i) &&
         (!defined $$opt{w} || lc(@def{$key}->{world}) eq lc($$opt{w}))) {
         if(length(@def{$key}->{world}) > $wmax) {
            $wmax = length(@def{$key}->{world});
         }
         $nmax = length($key) if length($key) > $nmax;
      }
   }
   history(world($conn),
           sprintf("%-*s %4s %-*s %s",
                   $nmax,"NAME",
                   "ATTR",
                   $wmax,"WORLD",
                   "STRING")
          );

   $pat = glob2re(trim($str)) if($str !~ /^\s*$/);
   
   for my $key (sort keys %def) {
      my $count = 0;

      if(($pat eq undef || $key =~ /^$pat$/i) &&
         (!defined $$opt{w} || lc(@def{$key}->{world}) eq lc($$opt{w}))) {
        for my $line (ansi_wrap(@def{$key}->{txt},$cwin - $nmax - $wmax - 7)) {
           if($count++ == 0) {
               history(world($conn),sprintf("%-*s %4s %-*s %s",
                    $nmax,$key,
                    @def{$key}->{atr},
                    $wmax,@def{$key}->{world},
                    txt($line)
                   ),0);
            } else {
               history(world($conn),sprintf("%-*s %4s %-*s %s",
                    $nmax,"",
                    "",
                    $wmax,"",
                    txt($line)
                   ),0);
            }
         }
         if(defined @def{$key}->{cmd}) {
            for my $line (ansi_wrap(@def{$key}->{cmd},70)) {
               history(world($conn),"   cmd: " . txt($line),0);
            }
         }
      }
   }
}

sub cmd_list
{
#-# summary: List connected worlds or defined worlds.
#-# ------------------------------------------------------------------------
#-# /list [-c] [<pattern>]
#-#
#-#      Lists connected worlds, defined worlds, or worlds matching
#-#      <pattern>. The default behavoir is to show defined worlds.
#-#      Using the -s option will list connected worlds.
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $opt = {};

   my $txt = getopt("cd",$txt,$opt);

   if(defined $$opt{c}) {
      cmd_listsockets($conn);
   } elsif(defined $$opt{c}) {
      cmd_def($conn,$txt);
   } else {
      cmd_listworlds($conn,$txt);
   }
}

sub cmd_listworlds
{
#-# summary: internal
#-# ------------------------------------------------------------------------
#-# /listworlds <pattern>
#-#
#-#      Lists all worlds or any matching <pattern>
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = (shift,trim(@_));

   my $w = world($conn);
   my ($maxh, $maxn,$pat) = (5,5,undef);
#   my $opt = {};

#   my $str = getopt("sSm:t:b:B:E:T:h:a:P:iI");

   $pat = glob2re($txt) if($txt ne undef);
   for my $key (keys %address) {
      if($txt eq undef || $key =~ /$pat/) {
         $maxn = length($key) if length($key) > $maxn;
         if(length(@address{$key}->{host}) > $maxh) {
            $maxh = length(@address{$key}->{host});
         }
      }
   }
   history($w,sprintf("%-*s %-*s %6s %s",$maxn,"NAME",$maxh,"HOST",
       "PORT","CHARACTER"),);
   for my $key (keys %address) {
      if($txt eq undef || $key =~ /$pat/) {
         history($w,sprintf("%-*s %-*s %6s %s",
                            $maxn,
                            $key,
                            $maxh,
                            @address{$key}->{host},
                            @address{$key}->{port},
                            @address{$key}->{user},
                            @address{$key}->{pass}
                           )
                );
      }
   }
}

sub cmd_def
{
#-# summary: Define text to be gagged/not shown.
#-# ------------------------------------------------------------------------
#-# /def <options> <name>
#-#
#-#      Options
#-#      -a<attributes>   Specifies what should happen when the text is
#-#                       matched.
#-#
#-#                       Attributes:
#-#                          g      : Text will be not be shown when
#-#                                   matched.
#-#
#-#      -w<world>        Match will be limited to a specific world
#-#      -t"text"         Text to match. May include wild cards.
#-#      -s<seconds>      Time to live for this define in seconds
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my ($opt,$reg,$name,$value) = ({},undef,undef,undef);
   

   my $str = getopt("m:n:E:t:h:b:B:p:c:w:T:Fa:P:fiIq1s:L",$txt,$opt);

   if($str =~ /=/) {
      $name = trim($`);
      $value = $';
   } else {
      $name = $str;
   }

   return if($name =~ /^\s*$/ || $$opt{t}=~ /^\s*$/);

   if(!$$opt{h}) {

      if($str =~ /^\s*$/) {
         echo($conn,"%% No definition name provided.");
         return echo($conn,"%% Usage: /def [<options>] [<name>] [= <body>]");
      }

      if($$opt{t}=~ /^\s*$/) {
         return echo($conn,"%% No text to match provided.");
         return echo($conn,"%% Usage: /def [<options>] [<name>] [= <body>]");
      }

      if(defined $$opt{m}) {
         if(lc($$opt{m}) eq "r" || lc($$opt{m}) eq "regexp") {
            $reg = $$opt{t};
         } elsif(lc($$opt{m}) eq "g" || lc($$opt{m}) eq "global" ||
                 lc($$opt{m}) eq "s" || lc($$opt{m}) eq "simple") {
            $reg = glob2re($$opt{t});
         } else {
            echo("%% Invalid -m value \"%s\".",$$opt{m});
            echo("%% Values are: simple, global, regexp, and substr");
         }
      } else {
         $reg = glob2re($$opt{t});
      }

      @def{$name} = { atr     => $$opt{a},
                      txt     => $$opt{t},
                      world   => $$opt{w},
                      regexp  => $reg,
                      created => time(),
                    };
      @def{$name}->{LOGIN} = 1 if defined $$opt{L};
      @def{$name}->{ttl} = $$opt{s} if defined $$opt{s};
      @def{$name}->{cmd} = trim($value) if(trim($value) ne undef);
      @def{$name}->{hits} = 1 if $$opt{1};
   }
}

sub cmd_undef
{
#-# summary: Delete a define/macro
#-# ------------------------------------------------------------------------
#-# /undef <name>
#-#
#-#      Removes the definition of the macro/define with that name.
#-#
#-# Also see: /def
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$str) = (shift,trim(shift));
   my $count = 0;
   my $pat;
   my $name;

   if($str !~ /^\s*$/) {
      $pat = glob2re(trim($str));
   } else {
      return echo($conn,"%% UNDEF: No macro or pattern provided.");
   }

   for my $key (sort keys %def) {
      eval {
         if($key =~ /^$pat$/i) {
            $name = $key;
            $count++;
            delete @def{$key};
         }
      };
      if($@) {
         return echo($conn,"%% UNDEF: Aborting, Invalid pattern '%s'");
      }
   }

   if($count == 1) {
      echo($conn,"%% UNDEF: '%s' macro undefined",$name);
   } elsif($count) {
      echo($conn,"%% UNDEF: $count macros undefined matched by pattern.");
   } else {
      echo($conn,"%% UNDEF: no macros matched '%s'",$str);
   }
}

sub first
{
   my $str = shift;

   return $1 if(/^\s*([^ ]+)/);
}

#
# cmd_ps
#    List all running processes
#
sub cmd_ps
{
   my ($conn,$txt) = @_;

#-# summary: List any virtual process running inside muddler
#-# ------------------------------------------------------------------------
#-# /ps
#-#    List any running virtual processes such as /repeat.
#-#
#-# ------------------------------------------------------------------------
   echo($conn,                                             # show header
        "%-5s %-8s %-11s %-8s %8s %s",
        "PID",
        "NEXT",
        "WORLD",
        "PTIME",
        "COUNT",
        "COMMAND"
       );
   for my $i (keys %pid) {
      my $tl = @pid{$i}->{last} + @pid{$i}->{tick} - time();
      $tl = 0 if($tl <= 0);
      echo($conn,
           "%-5s %-8s %-11s %-8s %8s %s",
           $i,
           to_hhmmss($tl),
           @pid{$i}->{world},
           to_hhmmss(@pid{$i}->{tick}),
           @pid{$i}->{count},
           @pid{$i}->{cmd},
          );
   }
}

sub cmd_kill
{
#-# summary: Kill a virtual process listed in /ps.
#-# ------------------------------------------------------------------------
#-# /kill <pid>
#-#    Kill a running process listed in /ps.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   if($txt =~ /^\s*(\d+)\s*$/) {
      if(defined @pid{$1}) {
         delete @pid{$1};
      } else {
         echo($conn,"% KILL: no process %s",$1);
      }
   } else {
      echo($conn,"% KILL: invalid or missing numeric arguement");
   }
}

sub cmd_echo
{
#-# summary: echo a message to the screen.
#-# ------------------------------------------------------------------------
#-# /echo <message>
#-#    Echo <message> to the screen
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   echo($conn,$txt);
}
sub cmd_repeat
{
#-# summary: Send commands on a time interval
#-# ------------------------------------------------------------------------
#-# /repeat <options> <time> <command>
#-#    <time> A time between commands should be specified in hour, minute,
#-#    second format using -00:00:00.
#-#
#-#    -0          Sepecify seconds between commands.
#-#    -00:00      Sepecify hours minutes between commands.
#-#    -00:00:00   Sepecify hours, minutes, seconds  between commands.
#-#
#-#    <command>   The command that will be sent to the world.
#-#
#-#    <options>
#-#      -w<world>   Which would should the commands be run on.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my ($count,$sec,$min,$hr);
   my $opt = {};
   my $orig = $txt;

   if($txt =~ /(^| )\-(\d+)( |$)/) {
      $sec = $2;
      $txt = "$` $'";
   } elsif($txt =~ /(^| )\-(\d+):(\d+)( |$)/) {
      ($hr,$min) = ($2,$3);
      $txt = "$` $'";
   } elsif($txt =~ /(^| )\-(\d+):(\d+):(\d+)( |$)/) {
      ($hr,$min,$sec) = ($2,$3,$4);
      $txt = "$` $'";
   }
   my $txt = getopt("w:nSP",$txt,$opt);

   if($txt =~ /^\s*(\d+)\s*/ && $1 > 0 && $1 < 20) {
      $count = $1;
      $txt = $';
   } else {
      echo($conn,"%% Invalid repeat count (%s)",$txt);
   }

   my $tick = $sec + ($min * 60) + ($hr * 3600);
   $tick = 1 if($tick <= 1);

   @pid{++@state{pid}} = { cmd   => $txt,
                           count => $count,
                           last  => time() - $tick - $tick,
                           tick  => $tick,
                           world => ($$opt{w} eq undef) ? @state{world} : 
                                    $$opt{w},
                         };
}

sub to_hhmmss
{
   my $secs = shift;
   my ($hr,$min);

   if($secs >= 3600) {
      $hr = sprintf("%d",$secs / 3600);
      $secs = $secs - ($hr * 3600);
   }
   if($secs >= 60) {
      $min = sprintf("%d",$secs / 60);
      $secs = $secs - ($min * 60);
   }

   return sprintf("%02d:%02d:%02d",$hr,$min,$secs);
}

sub run_pid
{
   my $id = shift;

   if(defined @pid{$id}) {
      if(@pid{$id}->{count} <= 0) {                       # done, don't run
         delete @pid{$id};
      } else {
         @pid{$id}->{last} = time();
         @pid{$id}->{count}--;
         do_cmd(@pid{$id}->{world},@pid{$id}->{cmd});
      }
   }
}

     
#
# do_cmd
#   Run an internal command.
# 
sub do_cmd
{
   my ($world,$input,$conn) = @_;


   if(is_remote() && $input !~ /^\s*\/(window|quit|key_ctl_l|edit)\s*/) {
      return wc_out($input);
   }

   if($input =~ /^\/([^ ]+)\s*/) {
      @state{cmd_reset_more} = 1;
      if(defined @command{lc($1)} && ref(@command{lc($1)}) eq "CODE") {
         &{@command{lc($1)}}($conn,$');         # regular non-aliased command
         return 1;
      } elsif(defined @command{lc($1)} && ref(@command{lc($1)}) eq "" &&
         defined @command{@command{lc($1)}} &&
         ref(@command{@command{lc($1)}}) eq "CODE") {          # handle alias
         &{@command{@command{lc($1)}}}($conn,$');
         return 1;
      } else {
         echo($conn,"%% %s: no such command or macro",lc($1));
         return 1;
      }
      delete @state{cmd_reset_more};
  }
  return 0;
}

#
# cmd_web_size
#    Set tell muddler the size of the websocket connection.
#
sub cmd_web_size
{
#-# summary: internal
#-# ------------------------------------------------------------------------
#-# /web_size <height>,<width>
#-#
#-#      Sets the height and width of the browser in number of characters
#-#      that can be displayed. This is used internally and will not be
#-#      needed to be set by the user.
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;

   if($conn ne undef) {
      my (@size) = split(',',$txt);

      if(@size[0] =~ /^\s*(\d+)\s*$/) {
         @ws{$conn}->{size_x} = $1;
      }
      if(@size[1] =~ /^\s*(\d+)\s*$/) {
         @ws{$conn}->{size_y} = $1 - 3;
      }
   }

   reconnect($conn);
   draw_output($conn,1);
   draw_bar($conn,1);
}

sub nvl
{
   my ($value,$default) = @_;

   if($value eq undef) {
      return $default;
   } else {
      return $value;
   }
}

sub use_secure
{
   # required for ssl so the socket doesn't hang too long on a non SSL connect
   if(!module_enabled("IO::Socket::Timeout")) {
      return 0;
   } elsif(defined @state{p_key} && trim(@state{p_key}) ne "" &&
           defined @state{p_cert} && trim(@state{p_key}) ne "") {
      return 1;
   } else {
      return 0;
   }
}

sub cmd_web
{
#-# summary: Configure muddler's web interface
#-# ------------------------------------------------------------------------
#-# /web                : Shows the current status of the web interface
#-# /web [on|off]       : Enables / Disables the web interface
#-# /web cert = <file>  : Specifies the cert file location
#-# /web key = <file>   : Specifies the key file location
#-#
#-# NOTE: If both the cert & key file are defined, muddler will enable the
#-#       https protocol.
#-#
#-#       A non-self signed cert/key is required for https to work. Without
#-#       one your browser will fail to connect.
#-# ------------------------------------------------------------------------
   my ($conn,$status,$startup) = @_;

   if(is_remote()) {
      return echo($conn,
                  "%% Web/Websocket is disabled when --remote is enabled."
                 );
   } elsif(!module_enabled("Net::WebSocket::Server")) {
      return echo($conn,"%% Web interface disabled due to missing " .
         "Net::WebSocket::Server module");
   } elsif($status eq "") {
      return echo($conn,"%% Sorry, the web settings editor is only " .
         "compatible with the console.") if(is_web($conn));

      my @fields;
      for my $i (sort {@var{$a}->{web} cmp @var{$b}->{web}} keys %var) {
         if(defined @var{$i}->{web}) {
            push(@fields,"@var{$i}->{web}:@var{$i}->{type}");
         }
      }
      dialog_init($conn,
                  join(",",@fields),
                  ["Cancel:dialog_cancel","Save:set_save"],0);
      my $pos = 1;
      for my $i (sort {@var{$a}->{web} cmp @var{$b}->{web}} keys %var) {
         if(defined @var{$i}->{web}) {
            dialog_populate($pos,@state{"p_$i"});
            $pos++;
         }
      }
      return draw_screen($conn);
#   } elsif($status =~ /^\s*$/) {
#      echo($conn,"Web Interface: %s",@state{p_web} ? "on" : "off");
#      echo($conn,"   Protocol:      %s",use_secure() ? "https [secure]" :
#          "http [non-secure]");
#      echo($conn,"   Cert file:     %s",nvl(@state{p_cert},"Not defined"));
#      echo($conn,"   Key file:      %s",nvl(@state{p_key},"Not defined"));
   } elsif($status =~ /^\s*(key|cert)\s*=(.*)$/i) {
      if(! length trim($2)) {
         echo($conn,"%% Certificate will no longer be used.");
      } elsif(!-e trim($2)) {
         echo($conn,"%% Could not locate file: %s",trim($2));
      } else {
         echo($conn,"%% %s file is now: %s",lc($1),trim($2));
      }
      @state{"p_" . lc($1)} = trim($2);
      save($conn,"STATE","p_" . lc($1));
   } elsif($status =~ /^\s*on\s*$/i) {
      if(@state{p_web} == 1 && !$startup) {
         echo($conn,
              "%% Web already enabled, Connect via: http%s://localhost:%s",
              use_secure() ? "s" : "",
              @state{p_port}
             );
          echo($conn,"%%    Password: %s",@state{p_password});
      } else {
         if(ws_init()) {
            echo($conn,"%% Web enabled, Connect via: http%s://localhost:%s",
                 use_secure() ? "s" : "",
                 @state{p_port}
             );
             echo($conn,"%%    Password: %s",@state{p_password});
         }
      }
   } elsif($status =~ /^\s*off\s*$/i) {
      if(@state{p_web} == 0) {
         echo($conn,"%% Web/Websocket server is already disabled.");
      } else {
         echo($conn,"%% Web/Websocket server has been disabled.");
         for my $key (keys %http) {
            @http{$key}->{sock}->close;
         }
         @state{p_web} = 0;
         eval { # manually shutdown http/websock. Calling websock's
                # way will shut everything down. This is good for their
                # code but not ours.
            for my $s (keys %ws) { 
               @ws{$s}->{conn}->disconnect;
               delete @ws{$s};
            }
            for my $s (keys %http) {
               @http{$s}->{sock}->close();
               delete @http{$s};
            }

            if($ws_listen ne undef) {
               $ws_server->{select_readable}->remove($ws_listen);
               $ws_listen->shutdown(2);
               $ws_listen = undef;
            }

            if($http_listen ne undef) {
               $ws_server->{select_readable}->remove($http_listen);
               $http_listen->shutdown(2);
               $http_listen = undef;
            }
         };
      }
   } else {
      cmd_help($conn,"web");
   }
}

sub cmd_help
{
#-# summary: internal
#-# ------------------------------------------------------------------------
#-# Common Commands:
#-#   /dc              :  Forcefully disconnect from current world
#-#   /list [-c]       :  Lists all saved worlds, -c list connections
#-#   /world new       :  Setup a connection to a new world
#-#   /world [<world>] :  Connect or switch to an existing world
#-#   /quit            :  Quit Muddler
#-# All Commands Help: 
#-#   /help commands   :  Lists all of muddlers internal commands
#-#   /help keys       :  Help entry for keyboard short cuts
#-#   /help <command>  :  Help entry for a command
#-# ------------------------------------------------------------------------
   my ($conn,$cmd) = (shift, lc(trim(shift)));

   $cmd =~ s/^\s*\/\s*//g;                          # remove / if provided
   $cmd = "help" if $cmd eq undef;
   if(!defined @state{help}) {
      echo($conn,"% No help loaded.");
   } elsif(trim($cmd) =~ /^commands{0,1}$/) {
      for my $item (sort keys %command) {
         if(defined @state{help}->{"cmd_$item"}) {
            if(defined @state{summary}->{"cmd_$item"}) {
               if(@state{summary}->{"cmd_$item"} !~ /^\s*internal\s*$/) {
                  history(world($conn),sprintf("/%-15s | %s",
                          $item,
                          @state{summary}->{"cmd_$item"}),
                         );
               }
            } else {
               history(world($conn),sprintf("/%-15s | %s",$item,"n/a"));
            }
#         } else {                                     # tf null commands?
#            history(world($conn),sprintf("/%-15s | %s",$item,"N/A"));
         }
      }
   } elsif(trim($cmd) =~ /^keys{0,1}$/) {
      for my $item (sort grep {/^key_/} keys %{@state{summary}}) {
         if($item =~ /^key_/) {
            my $name = $';
            $name =~ s/_/-/;
            $name =~ s/([\w']+)/\u\L$1/g;
            history(world($conn),sprintf("%-6s | %s",
                    $name,
                    @state{summary}->{$item}),
                   );
         }
      }
   } elsif(defined @state{help}->{"cmd_$cmd"} && defined @command{$cmd}) {
      echo($conn,"%s",@state{help}->{"cmd_$cmd"});         # non-aliased cmd
   } elsif(defined @command{$cmd} && ref(@command{$cmd}) eq "" &&
           defined @state{help}->{"cmd_@command{$cmd}"}) {
      echo($conn,"This command is an alias for @command{$cmd}\n");
      echo($conn,"%s",@state{help}->{"cmd_@command{$cmd}"});     # alias cmd
   } else {
      echo($conn,"%% Help on subject %s not found.",$cmd);
   }
}

sub cmd_version
{
#-# summary: Show version information
#-# ------------------------------------------------------------------------
#-# /version
#-#      Shows the current version at startup of muddler. This is currently
#-#      not refreshed when the code is reloaded.
#-# ------------------------------------------------------------------------

   my ($conn,$txt) = @_;
   show_banner($conn,1);
}

#
# remove_quotes
#    Remove quotes from a string that occure at the begining and end
#    of the string.
#
sub remove_quotes
{
   my $txt = shift;

   if($txt =~ /^('|")(.*)('|")$/) {
      return $2;
   } else {
      return $txt;
   }
}

sub get_segment_end
{
   my $txt = shift;
   my ($in_single, $in_double);

   for(my $i=0;$i <= length($txt);$i++) {
      my $ch = substr($txt,$i,1);

      if($ch eq "\\") {
         $ch++;
      } elsif($ch eq "\"" && !$in_single) {
         $in_double = !$in_double;
      } elsif($ch eq "\'" && !$in_double) {
         $in_single = !$in_single;
      } elsif($ch eq " " && !$in_single && !$in_double) {
         return $i;                                       # done
      }
   }
   return length($txt);
}

#
# getopt
#    My own implimentation of get opts that better fits how tinyfugue
#    handles options and doesn't require loading a module that isn't
#    standard on my system.
#
sub getopt
{
   my ($opts,$txt,$result,$time) = @_;
   my ($in_arg,%lookfor,$prev,$end);

   for(my $i = 0;$i < length($opts);$i++) {     # determine what to look for
      my $ch = substr($opts,$i,1);
      if($ch eq ":") {
         @lookfor{$prev} = 2 if($prev ne undef); # populate hash with details
      } else {
         @lookfor{$ch} = 1;
      }
      $prev = $ch;
   }

   for(my $i = 0;$i <= length($txt);$i++) {         # take apart $txt string
      my $ch = substr($txt,$i,1);

      if($ch eq "\\") {                                       # escaped char
         $i++;
      } elsif($ch eq "-" && !$in_arg) {                  # start of   option 
         $in_arg = 1;
      } elsif($in_arg and $ch eq " ") {                      # end of option
         $in_arg = 0;
      } elsif($in_arg) {                                   # option contents
         if(defined @lookfor{$ch} || ($time && $ch =~ /^\d+$/)) {
            if(@lookfor{$ch} == 1) {                         # simple option
               $$result{$ch} = 1;
            } elsif(@lookfor{$ch} == 2 || ($time && $ch =~ /^\d+$/)) {
               # option w/value
               $end = get_segment_end(substr($txt,$i));      # scan to end
               if($time && $ch =~ /^\d+$/) {
                  $$result{time} = remove_quotes(trim(substr($txt,$i,$end))); 
                  $i += $end - 1;
               } elsif($end eq undef) {                      # nothing found
                  $$result{$ch} = "";
               } else {                                    # found something
                  $$result{$ch} = remove_quotes(trim(substr($txt,$i+1,$end))); 
                  $i += $end - 1;
               }
            }
         } else {
           # invalid option, probably should die/error out here
         }
      } else {                                  # store string minus options
         return substr($txt,$i);
      }
   }
}


sub t
{
   my $pm;
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime();
   if($hour > 12) {
      $pm = "p";
      $hour -= 12;
   } else {
      $pm = "a";
   }
   
   return sprintf("%2d:%02d%s",$hour,$min,$pm);
}
sub ts
{
   my $time = shift;

   $time = time() if $time eq undef;
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime($time);
   $mon++;

   return sprintf("%02d:%02d@%02d/%02d",$hour,$min,$mon,$mday);
}

sub cmd_quote
{
#-# summary: Send text to a world from unix command or file.
#-# ------------------------------------------------------------------------
#-# /quote [options] [<time>] <command>
#-#
#-#      Quotes a command, file, or muddler command to a world.
#-# Time:
#-#    The duration between commands may be specified in hh:mm:ss, mm:ss,
#-#    or ss format. The format must be prefixed with a "-". 
#-#
#-#    Example: /quote -1:00:00 think idle
#-#                  Sends "think" idle every hour
#-#             /quote -1:00 think idle
#-#                  Sends "think" idle every minute
#-#             /quote 5 think idle
#-#                  Sends "think" idle every second
#-#    
#-# Options:
#-#   -d<option>  How to display: echo, send, exec [not impliemented]
#-#   -w<world>   Which world to send the output to
#-#
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my $w = world($conn);
   my ($fd,$pre,$array,$when);
   my $world = $conn;
   my $opt = {};

   $txt = getopt("d:w:",$txt,$opt,1);

   # future impliment?
   my $delay = 0;
   if(defined $$opt{time}) {
      if($$opt{time} =~ /^\s*([\d]+):([\d+]):([\d+])\s*/) {
         if($1 > 24) {
            return echo($conn,"%% QUOTE : there are only 24hrs in a day.");
         } elsif($2 > 59) {
            return echo($conn,
                        "%% QUOTE : there are only 60 minutes in an hour."
                       );
         } elsif($3 > 59) {
            return echo($conn,
                        "%% QUOTE : there are only 60 seconds in an minute."
                       );
         }
         $delay = ($1 * 3600) + ($2 * 60) + $3;
      } elsif($txt =~ /^\s*([\d]+):([\d+])\s*/) {
         if($1 > 59) {
            return echo($conn,"%% QUOTE : there are only 24hrs in a day.");
         } elsif($2 > 59) {
            return echo($conn,
                        "%% QUOTE : there are only 60 minutes in an hour."
                       );
         }
         $delay = ($1 * 60) + $2;
      } elsif($$opt{time} =~ /^\s*([\d]+)\s*/) {
         if($1 > 59) {
            return echo($conn,
                        "%% QUOTE : there are only 60 seconds in an minute."
                       );
         }
         $delay = $1;
      }
   }

   $$opt{w} = $conn if(!defined $$opt{w});
   $$opt{d} = "send" if(!defined $$opt{d});
   if($$opt{d} !~ /^(echo|send|exec|0|1|2)$/) {
      return echo($conn,"%% QUOTE -d: Invalid -d value \"$$opt{d}\".  Valid " .
         "values are: echo (0), send (1), exec (2)");
   }

   if(!defined @socket{$$opt{w}}) {
      return echo($conn,"%% QUOTE: Not connected to world $$opt{$w}");
   }

   if($txt =~ /^([^!`']+)!\s*/) {
      $pre = $1;
      open($fd,"$' |") ||
         return echo($conn,"%% Unable to run commmand '$''.");
   } elsif($txt =~ /^([^!`']+)'\s*/) {
      $pre = $1;
      open($fd,"< $'") ||
         return echo($conn,"%% Unable to open file '$txt' for reading.");
   } elsif($txt =~ /^([^!`']+)`\s*/) {
      $pre = $1;
      return echo($conn,"%% Quoting muddler commands not supported yet");
   } else {
      return echo($conn,"%% QUOTE: missing command character");
   }

  
   @socket{$$opt{w}}->{quote} = [] if(!defined @socket{$$opt{w}}->{quote});
   $array = @socket{$$opt{w}}->{quote} = [];
   $when = time();

   while(<$fd>) {
      # queue up output so it can be processed $when it is time, even
      # if that is now.
      push(@$array,{ when => $when,
                     what => $pre . $_,
                     how  => $$opt{d},
                   }
          );
      $when += $delay;
   }
   close($fd);
}

sub cmd_recall
{
#-# summary: Recall lines from the history buffer.
#-# ------------------------------------------------------------------------
#-# /recall [<count>] <pattern>
#-#      Does a recall of ten lines from the current world's history
#-#      buffer that matches pattern. The amount of lines can be
#-#      changed by specifying a count.
#-#
#-# Patterns:
#-#      Patterns may contain text that will be matched as is but also
#-#      May contain * as a wild card or ? to match a single character.   
#-#
#-# Example:
#-#      /recall *pages*
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = @_;
   my ($count,$pat,@out,$gagged,$ts) = 10;
   my $opt = {};

   return echo($conn,"%% Not connected to a world.") if(no_world());
   $txt = getopt("a:t",$txt,$opt);
   my $w = world($conn);

   if($txt =~ /^\s*(\d+)\s*/) {
      $count = $1;
      $pat = $';
   } elsif($txt =~ /^\s*\/(\d+)\s*/) {
      $count = $1;
      $pat = $';
   } else {
      $pat = $txt;
   }

   $pat = "*" if $pat eq undef;

   # include gagged content?
   if($$opt{a} =~ /g/) {
      $gagged = 1;
   } else {
      $gagged = 0;
   }

   $pat = glob2re($pat);
   for(my $i=$#{@history{@state{world}}};$i >= 0 && $count > 0;$i--) {
      eval {
         if(($gagged || !$gagged && !@history{$w}->[$i]->{gagged}) &&
            @history{$w}->[$i]->{internal} == 0&& 
            ansi_remove(@history{@state{world}}->[$i]->{txt}) =~ /$pat/) {

            # order will be backwards, so store.
            if($$opt{t}) {
               $ts = "[" . ts(@history{$w}->[$i]->{ts}) . "] ";
            } else {
               $ts = undef;
            }

            if($gagged && defined @history{$w}->[$i]->{original}) {
               unshift(@out,$ts . @history{$w}->[$i]->{original});
            } else {
               unshift(@out,$ts . @history{$w}->[$i]->{txt});
            }

            $count--;
         }
      };
      if($@) {
         LOGGIT("ERROR: $@\n");
      }
   }
   for my $i (0 .. $#out) {
#      echo_wrap(@out[$i]);                       # output in correct order
      history(world($conn),@out[$i]);              # output in correct order
   }
}

sub small
{
   my $txt = shift;

   if($txt =~ /\(([^\)]+)\)/) {
      return $1;
   } else {
      return $txt;
   }
}

sub shorten_time
{
   my $secs = shift;

   if($secs > 86400) {
      return sprintf("%ds",$secs / 86400);
   } elsif($secs > 3600) {
      return sprintf("%dh",$secs / 3600);
   } elsif($secs > 60) {
      return sprintf("%dm",$secs / 60);
   } else {
      return $secs. "s";
   }
}

sub cmd_listsockets
{
#-# summary: internal
#-# ------------------------------------------------------------------------
#-# /list_sockets
#-#      Shows all open connections and some minimal data about them.
#-# ------------------------------------------------------------------------
   my $conn = shift;
   my ($maxh, $maxn) = (5,5);

   for my $key (keys %ws) {
      if(length(@ws{$key}->{auth} ? "Web [ath]" : "Web") > $maxn) {
         $maxn = length(@ws{$key}->{auth} ? "Web [ath]" : "Web");
      }
      $maxn = length(@ws{$key}->{ip}) if length(@ws{$key}->{ip}) > $maxn;
   }
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock} && $w ne "muddler") {
         $maxn = length($w) if (length($w) > $maxn);
         if(length(@address{$w}->{host}) > $maxh) {
            $maxh = length(@address{$w}->{host})
         }
      }
   }

   echo($conn,"%-*s %-*s %-5s %6s %-4s %-4s %-6s",
        $maxn,"NAME",$maxh,"HOST","PORT","Secure","Ping", "Idle","Pend");
   for my $key (keys %ws) {
       echo($conn,
            "%-*s %-*s %-5s %-6s %-4s %-4s %s",
            $maxn,
            @ws{$key}->{auth} ? "Web [ath]" : "Web",
            $maxh,
            @ws{$key}->{ip},
            @ws{$key}->{port},
            @state{secure} ? "Yes" : "No",
            "",
            "","",
            " [". @ws{$key}->{world} . "]"
           );
   }
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock} && $w ne "muddler") {
         echo($conn,
              "%-*s %-*s %-5s %-6s %-4s %-4s %s",
              $maxn,
              @address{$w}->{name},
              $maxh,
              @address{$w}->{host},
              @address{$w}->{port},
              @address{$w}->{ssl} ? "Yes" : "No",
              shorten_time(@socket{$w}->{next_check} - 
                           (time() - @socket{$w}->{last_send})),
              shorten_time(time() - @socket{$w}->{last_send}),
              ((defined @pending{$w} && $#{@pending{$w}} > -1) ?
                 ($#{@pending{$w}}+1) : ""));
      }
   }
}

sub reconnect
{
   my ($conn) = shift;

   if(enabled("p_reconnect")) {
      for my $w (keys %socket) {
         if(!defined @socket{$w}->{sock} && $w ne "muddler") {
            cmd_world($conn,$w);
         }
      }
   }
}

sub cmd_quit
{
#-# summary: exit out of muddler
#-# ------------------------------------------------------------------------
#-# /quit
#-#      Exits out of muddler
#-# ------------------------------------------------------------------------
   revert_console();
   exit(1);
}

sub cmd_world
{
#-# summary: Connect if needed and switch to world.
#-# ------------------------------------------------------------------------
#-# /world
#-#      Edit the current connection in a world editor.
#-# /world <world>
#-#      Initiate a new connection or switch to an already connected world.
#-# 
#-# Options:
#-#     -l            don't send a user connecton string when connecting
#-#     -e <world>    edit the existing or new world entry 
#-#
#-# Ex: /world puggy, /world -l puggy, /world -e puggy
#-# ------------------------------------------------------------------------
   my ($conn,$txt) = (shift,lc(trim(shift)));
   my $opt = {};
   $txt = trim(getopt("le",$txt,$opt));


   if($txt =~ /^([^ ]+)\s+(\d+)$/) {
      for my $i (1 .. 100) {
         if(defined @address{lc("(Unnamed_#" . $i . ")")} &&
            trim(@address{lc("(Unnamed_#" . $i . ")")}->{host}) eq trim($1) &&
            trim(@address{lc("(Unnamed_#" . $i . ")")}->{port}) eq trim($2)) {
            $txt = "(Unnamed_#" . $i . ")";
            last;
         } elsif(!defined @address{lc("(Unnamed_#" . $i . ")")}) {
            cmd_editor($conn,"(Unnamed_#" . $i . ") $txt");
            $txt = "(Unnamed_#" . $i . ")";
            last;
         }
      }
   }


   if($txt =~ /^\s*$/) {
      cmd_editor($conn);
   } elsif(defined $$opt{e}) {
      cmd_editor($conn,$txt);
   } elsif(!defined @address{lc($txt)} || $txt eq "muddler") {
      return echo($conn,"% CONNECT: no such world '%s'",$txt);
   } elsif(defined @socket{lc($txt)} && defined @socket{lc($txt)}->{sock}) {
      # loggit("# switch");
      switch_world($conn,lc($txt));
   } else {
      # loggit("# connect");
      socket_connect($conn,
                     @address{lc($txt)}->{name},
                     @address{lc($txt)}->{host},
                     @address{lc($txt)}->{port},
                     (!defined @address{lc($txt)}->{ssl} ||
                      !@address{lc($txt)}->{ssl}) ? 0 : 1,
                     $opt
                    );
   }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  misc code                                                                 #
#                                                                            #
#----------------------------------------------------------------------------#

END {
     revert_console();
     printf("%s\n",@state{err}) if(@state{err});
}

sub center
{
    my ($conn,$txt) = @_;

    return sprintf("%s%s",(" " x ((size_y($conn)- length($txt)-1) / 2)),$txt);
}

#
# optimize_start
#    Flag that the script will probably be doing multiple outputs. This flag
#    will cause the script to not reset the scroll regions after each output
#    until otimize_end is called.
#
sub optimize_start
{
   if(!@state{optimize_output}) {
      @state{optimize_output} = 1;
   }
}

#
# optimize_end
#    The script has just finished sending a block of output to the screen.
#    Its now okay to set the scroll region and move the cursor back to where
#    the user is expecting.
#
sub optimize_end
{
   @state{optimize_output} = 0;
   update_scroll_region("input");
   xy(input_x(),input_y());
}

#
# show_banner
#    Show the banner from the top of this script as our version / initial
#    screen. The @state{version} is gathered by the get_checksums function
#    as it is already reading the whole script. This is done this way
#    simply to avoid having it "twice" within the script and editing it
#    doesn't require any messy escaping out of characters.
#
sub show_banner
{
   my ($conn,$flag) = @_;

   optimize_start();                        # optimize for multiple outputs

   for my $line (split(/\n/,@state{version})) {          # center the output
      echo($conn,center($conn,$line));             # instead of just echoing
   }
   if(!$flag) {
      echo($conn);                           # this should be just one echo, 
      echo($conn);                        # but i think ansi_wrap has a bug
   }
   optimize_end();
}

#
# read_tfworlds
#    Quick and dirty subroutine to read tf's world file if named .tfworlds.
#
sub read_tfworlds
{
   my ($conn,$fn,$quiet) = @_;
   my ($file, $bad);

   return if is_remote();

   if(-e "@ENV{HOME}/.muddler" || !-e "@ENV{HOME}/.tfworlds") {
      return;
   } elsif(!module_enabled("Text::ParseWords")) {
      echo($conn,
           "%% .tfworlds may not be read without Text::ParseWords module"
          );
   } else {
      if(!open($file,$fn)) {
         echo($conn,"%% Unable to open '%s' for reading",$fn) if (!$quiet);
         return;
      }
   
      while(<$file>) {
         s/\r|\n//g;
         if(/^\/test addworld\((.*)\)$/) {
            my @data = quotewords(',',0,$1);
            @address{lc(trim(@data[0]))} = {};
            @address{lc(trim(@data[0]))}->{host} = trim(@data[2]);
            @address{lc(trim(@data[0]))}->{port} = trim(@data[3]);;
            @address{lc(trim(@data[0]))}->{user} = trim(@data[4]);;
            @address{lc(trim(@data[0]))}->{pass} = trim(@data[5]);;
            @address{lc(trim(@data[0]))}->{name} = trim(@data[0]);
         } else {
            $bad++;
            echo($conn,"%% Unknown data: '%s'",$_);
         }
      }
      close($file);
      echo($conn,"%% %d worlds read from tfworlds file.",scalar keys %address);
   }
}

sub read_tfrc
{
   my $fn = shift;
   my ($file, $prev);

   return if is_remote();

   open($file,$fn) || return;

   while(<$file>) {
      s/\r|\n//g;
      if(/^\s*;/) {
         # comment;
      } elsif(/\s*\\\s*$/) {
         $prev .= $`;
      } elsif($prev . $_ !~ /^\s*\/set /) {
         do_cmd(undef,$prev . $_);
         $prev = undef;
      }
   }
   close($file);
}

sub get_checksums
{
   my ($file,$pos,%data);
   my $ln = 1;
#

   open($file,$0) ||
     return echo(@state{world},
                 "%% Unable to read source file, /reload disabled"
                );

   delete @state{version};

   for my $line (<$file>) {
      if($pos eq undef && $line =~ /^#\-#  /) {
         @state{version} .= $';
      } elsif($pos eq undef && 
         ( $line =~ /^sub\s+([^ \n\r]+)\s*$/ ||
          $line =~ /^sub\s+([^ \n\r]+)\s*\(@\)\s*$/)) {
         $pos = $1;
         @data{$pos} = {
            line => $ln,
            src  => qq[#line 0 "$pos"\n] . $line,
         };
         if($pos =~ /^(key|cmd)_/) {
            @state{help} = {} if not defined @state{help};
            @state{summary} = {} if not defined @state{summary};
            delete @state{help}->{$pos} if defined @state{help}->{$pos};
            delete @state{summary}->{$pos} if defined @state{summary}->{$pos};
            delete @state{summary}->{$pos} if defined @state{summary}->{$pos};
         }
      } elsif($pos ne undef && $line =~ /^}\s*$/) {
         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk} = chksum(@data{$pos}->{src});
         @data{$pos}->{done} = 1;
         if($pos =~ /cmd_/) {
            @state{help}->{$pos} =~ s/\n$//;
         }
         $pos = undef;
      } elsif($pos ne undef) {
         if($pos =~ /(key|cmd)_/) {
            if($line =~ /^#-# -+$/) {
               # header ignored
            } elsif($line =~ /^#-# summary: /) {
               @state{summary}->{$pos} = $';
               @state{summary}->{$pos} =~ s/[\r|\n]+$//g;
            } elsif($line =~ /^#-# {0,1}/) {
               @state{help}->{$pos} .= $';
            }
         }

         @data{$pos}->{src} .= $line;
      }
      $ln++;
   }
   close($file);

   for my $pos (keys %data) {
      if(!defined @data{$pos}->{done}) {
         echo(@state{world},"% Warning: Did not find end to %s",$pos);
      }
   }
   @state{help}->{cmd_addworld} = "n/a";
   @state{summary}->{cmd_addworld} = "internal";
   return \%data;
}

#
# reload_code
#    As long as the global variables do not change, the code can be
#    reloaded without dropping any connections.
#
sub reload_code
{
   my ($conn,$nomodules) = @_;
   my $count = 0;

   my $new = get_checksums();
   my $old = (defined @state{chksum}) ? @state{chksum} : {};

   for my $key (sort keys %$new) {
      if((@state{state} eq "init" || 
         (!defined $$old{$key} || $$old{$key}->{chk} ne $$new{$key}->{chk}))) {
         
         LOGGIT("%% Reloading: %s",$key) if @state{state} ne "init";
         echo($conn,"%% Reloading: %s",$key) if @state{state} ne "init";
         eval($$new{$key}->{src});
         $count++;
         if($@) {
            echo($conn,"%% Error reloading $key");
            LOGGIT("%s\n",$@);
            $$new{$key}->{chk} = -1;
         } elsif(@state{state} ne "init") {
            echo($conn,"%% Reloading: %s [done]",$key);
         }
      }
   }
   @state{chksum} = $new;
   command_init();
   key_init();
   http_data_init();
   telnet_ch_init();
   fansi_init();
   var_init();
   encoding_init();
   load_modules() if(!$nomodules);
   callback_init();


   if($count == 0) {
      echo($conn,"%% No changes found to reload.");
   }
}

#
# ignoreit
#    Ignore certain hash key entries at all depths or just the specified
#    depth.
#
sub ignoreit
{
   my ($skip,$key,$depth) = @_;


   if(!defined $$skip{$key}) {
      return 0;
   } elsif($$skip{$key} < 0 || ($$skip{$key} >= 0 && $$skip{$key} == $depth)) {
     return 1;
   } else {
     return 0;
   }
}

#
# print_var
#    Return a "text" printable version of a HASH / Array
#
sub print_var
{
   my ($var,$depth,$name,$skip,$recursive) = @_;
   my ($PL,$PR) = ('{','}');
   my $out;

   if($depth > 6) {
       return (" " x ($depth * 2)) .  " -> TO_BIG\n";
   }
   $depth = 0 if $depth eq "";
   $out .= (" " x ($depth * 2)) . (($name eq undef) ? "UNDEFINED" : $name) .
           " $PL\n" if(!$recursive);
   $depth++;

   for my $key (sort ((ref($var) eq "HASH") ? keys %$var : 0 .. $#$var)) {

      my $data = (ref($var) eq "HASH") ? $$var{$key} : $$var[$key];

      if((ref($data) eq "HASH" || ref($data) eq "ARRAY") &&
         !ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s $PL\n"," " x ($depth*2),$key);
         $out .= print_var($data,$depth+1,$key,$skip,1);
         $out .= sprintf("%s$PR\n"," " x ($depth*2));
      } elsif(!ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s = %s\n"," " x ($depth*2),$key,$data);
      }
   }

   $out .= (" " x (($depth-1)*2)) . "$PR\n" if(!$recursive);
   return $out;
}


#
# remove any space at the begining or end of a string
#
sub trim
{
   my $txt = shift;

   $txt =~ s/^\s+|\s+$//g;
   return $txt;
}

sub myshuffle (@)
{
    my $array = shift;
    my $i;
    for ($i = @$array; --$i; ) {
        my $j = int rand ($i+1);
        next if $i == $j;
        @$array[$i,$j] = @$array[$j,$i];
    }
}


sub tick
{
   if(defined @state{save_last} &&
      defined @state{save_fd} &&
      time() - @state{save_last} > 2) {
      my $fd = @state{save_fd};
      $fd->close();
      delete @state{save_fd};
      delete @state{save_last};
      $fd = undef;
   }
   # keep alive. Send something to a world to keep it alive if nothing has
   # bloggiteen sent / recieved.
   for my $w (keys %socket) {
      if(is_loggedin($w) &&
         time()-@socket{$w}->{last_send} > @socket{$w}->{next_check}) {
         if(defined @address{$w} &&
            defined @address{$w}->{keepalive} &&
            trim(@address{$w}->{keepalive}) ne "") {

            if(@address{$w}->{keepalive} !~ /^\s(off|none)\s*$/i) {
               @socket{$w}->{next_check}=180+sprintf("%d",rand(60 * 5));
               @state{out_nomore} = 1;
               # loggit("#ka1{$w} %s",@address{$w}->{keepalive});
               out($w,@address{$w}->{keepalive});
            }
         } else {
            my $str = "commands \\d+ ###";
            # loggit("#ka1{$w} %s",$str,time());
            out($w,"help commands %d ###",rand(1000));
            # @def{sprintf("i_%s_%s_%06s",$w,time(),(scalar keys %def)+1)} = {
            @def{sprintf("i_%s",$w)} = {
                 atr       => "g",
                 txt       => "*$str*",
                 world     => $w,
                 keepalive => 1,
                 regexp    => "(?i)($str|I can't help you)",
                 # hits      => 1,
                 created   => time()
            };
            @socket{$w}->{next_check}=180+sprintf("%d",rand(60 * 5));
         }
      }

      # handle results from /quote command as they may need to be handled
      # in the future and not specifically when cmd_quote() is running.
      if(defined @socket{$w}->{quote}) {
         my $quote = @socket{$w}->{quote};

         while($#$quote > -1 && $$quote[0]->{when} <= time()) {
             my $item = shift(@$quote);
             if($$item{how} eq "echo" || $$item{how} eq 0) {
                # impliment me, yes you.
             } elsif($$item{how} eq "send" || $$item{how} eq 1) {
                @state{out_nomore} = 1;
                out($w,"%s",$$item{what});
             } elsif($$item{how} eq "exec" || $$item{how} eq 2) {
                # impliment me, yes you.
             }
         }
         delete @socket{$w}->{quote} if($#$quote == -1);
      }

      # handle file transfer over a MUSH
      if(defined @socket{$w}->{ftsend} && @socket{$w}->{ftsend}->{approved}) {
#         delete @socket{$w}->{ftsend};
         if($#{@socket{$w}->{ftsend}->{data}} >= 0) {
            @state{out_nomore} = 1;
            out($w,"\@pemit *%s=#%s# %s",
               @socket{$w}->{ftsend}->{name},
               @socket{$w}->{ftsend}->{id},
               join('%r#' . @socket{$w}->{ftsend}->{id}."# ",
                    splice(@{@socket{$w}->{ftsend}->{data}},0,55)
                   )
               );
         } else {
            @state{out_nomore} = 1;
            out($w,"\@pemit *%s=#%s# request complete",
               @socket{$w}->{ftsend}->{name},
               @socket{$w}->{ftsend}->{id});
            echo($w,"%% File transfer to %s completed.",
               @socket{$w}->{ftsend}->{name});
            delete @socket{$w}->{ftsend};
            last;
         }
      }
   }

   # a window change happened but we buffer it after the first change.
   if(defined @state{winch} && time() - @state{winch} >= 1) {
      delete @state{winch};
      change_window_size();
   }

   if(time() - @state{wrap_garbage_collect_last} > 300) {
      @state{wrap_garbage_collect_last}  = time();
      wrap_garbage_collect();
   }

   if(web()) {
      for my $key (keys %ws) {
         if(ref(@ws{$key}) ne "HASH") {
            delete @ws{$key};
         } elsif(@ws{$key}->{auth} eq 0 && time() - @ws{$key}->{start} > 60) {
            ws_echo(@ws{$key}->{conn},"t","%% Password entry timed out",1);
            ws_disconnect(@ws{$key}->{conn});
         }
      }
   }
 
   for my $id (keys %pid) {
      if(@pid{$id}->{last} + @pid{$id}->{tick} <= time()) {
         run_pid($id);
      }
   }

   for my $key (keys %def) {
      # check to see if trigger has "timed out"
      if(defined @def{$key}->{ttl} && 
         (time() > @def{$key}->{created} + @def{$key}->{ttl})) {

         # wait for detect client timed out for fansi worlds.
         if(defined @def{$key}->{world} && defined @def{$key}->{LOGIN}) {
            handle_login(@def{$key}->{world});
         }
         delete @def{$key};
      }
   }
}

sub read_file
{
   my $fn =shift;
   my $file;

   open($file,$fn) || 
      die("Could not open '$fn' for reading");
   my $result = join("",<$file>);
   close($file);
   return $result;
}

#
# muddler_init: run once type stuff
#
sub muddler_init
{
   if(module_enabled("Encode")) {
      binmode(STDOUT, ":encoding(UTF-8)");
   }
   if(module_enabled("Net::WebSocket::Server") && !is_remote()) {
      $ws_server = Net::WebSocket::Server->new(
         tick_period => 1,
         on_connect => 
            sub { my( $serv, $conn ) = @_;
                  $conn->on( ready =>      sub{ ws_login_screen(@_); },
                             utf8  =>      sub{ ws_process( @_, 0 ); },
                             disconnect => sub{ ws_disconnect(@_);   },
                           );
             },
         );
   }
   listener_init();
   callback_init();

   # for temporay viewport for output before a connected world
   push(@std_input,[]);
   @state{telnet_mode} = "normal";
   @history{muddler} = [];
   @socket{"muddler"} = { name                => "muddler",
                          more                => 0,
                          more_count          => 0,
                          last_read           => -1,
                          history_pos         => -1,
                          history_pos_partial => -1,
                          sock                => "n/a"
                        };

   @state{state} = "init";

   get_console_size();

   @state{chksum} = get_checksums();
   load(@state{world},1);
   LOGGIT("### START ###");

   # initialize websocket client
   wc_init() if is_remote();

   if(console()) {
      $| = 1;                                                  # unbuffer stdout
      cbreak();
   }

   key_init();
   command_init();
   encoding_init();
   var_init();

   draw_screen(@state{world},1);
   show_banner(@state{world}) if !is_remote();
   cmd_help();

   if(!-e "@ENV{HOME}/.muddler") {
      read_tfworlds(@state{world},"@ENV{HOME}/.tfworlds",1);
      @state{p_more} = 1;
      @state{p_overlap} = 2;
   }
   reload_code(@state{world},1);
   read_tfrc("@ENV{HOME}/.tfrc",1);
#   Monitor::monitor(@pending{alpha}, "array");
   @state{state} = "post-init";

   # these should go into another variable, but this allows reloading
   @state{IAC} = chr(255);
   @state{SB} = chr(250);
   @state{SE} = chr(240);
   @state{255} = 'IAC';
   @state{250} = 'SB';
   @state{240} = 'SE';
   @state{241} = 'NOP';

   @state{WILL} = chr(251);
   @state{WONT} = chr(252);
   @state{DO}   = chr(253);
   @state{DONT} = chr(254);
   @state{251} = 'WILL';
   @state{252} = 'WONT';
   @state{253} = 'DO';
   @state{254} = 'DONT';
   telnet_ch_init();
   fansi_init();

   cmd_web("muddler","on",1) if(@state{p_web} == 1);
}

#
# muddler
#    Contents of the main loop, seperated so it can be reloaded since
#    the main loop should not be.
#
sub muddler
{
   local $SIG{ALRM} = sub {
      delete @pid{keys %pid};
      LOGGIT("### Fatal ### Alarm timeout");
      LOGGIT(code("long"));
      die("alarm\n");
   };
   alarm(30);

   io();
   LOGGIT("Crash? $@") if($@);
   draw_bar();

   if(time() - @state{tick_last} >= 1) {
      tick();
      @state{tick_last} = time();
   }
   alarm(0);
}

#
# sig_usr1
#    Handle the SIGUSR1 signal and reload the perl code in case the code can
#    not be reloaded any other way.
#
$SIG{USR1} = sub { sig_usr1(); };
sub sig_usr1
{
   delete @pid{keys %pid};
   reload_code(@state{world});
}

#
# sig_int
#   Catch control-c without exiting?
#
$SIG{'INT'} = sub { sig_int() };

sub sig_int
{
    if(defined @state{ctl_c} && time() - @state{ctl_c} < 30) {
       exit(1);
    } else {
       echo(@state{world},
            "Warning: A Control-C was recieved. Two are needed to exit."
           );
       @state{ctl_c} = time();
    }
}


#
# sig_winch
#    Handle the WINCH signal and get the new size of the window and
#    adjust accordingly.
#
$SIG{'WINCH'} = sub { sig_winch(); };

sub change_window_size
{
   get_console_size();

   if(is_remote()) {
      wc_out("/web_size %s,%s\n",@state{size_x},@state{size_y}+3);
      draw_input();
   } else {
      draw_screen(@state{world},1);

      # re-calc all pending because of screen size change.
#      for my $key (keys %pending) {
#         my $w = world($key);
#         if(defined @socket{$w}) { # re-calc pending because of screen size
#            @socket{$w}->{pending} = calc_pending($w);
#         }
#      }
#      draw_screen(@state{world},1);
   }
}



sub calc_pending
{
   my $w = shift;
   my ($cnt,$new,$start) = (0,0,0);

   if(history_pos_partial($w) == -1) {    # last line shown was fully shown
      $start = history_pos($w) + 1;                    # start on next line
   } else {                                # last line only partially shown,
      $start = history_pos($w);                       # start where left off
   }

   for(my $i = $start;$i <= history_max($w);$i++) {
      if($i == $start && history_pos_partial($w) != -1) {
         my $start = history_pos_partial($w);
         $new = scalar ansi_wrap(ansi_substr(@history{$w}->[$i]->{txt},
                                              $start
                                             ),
                                 @state{size_y}
                                 );
      } else {
         $new = scalar ansi_wrap(@history{$w}->[$i]->{txt});
      }
      $cnt += ($new <= 0) ? 1 : $new;           # blank line fudge factor
   }
   return $cnt;
}


#
# sig_winch
#    The window size has changed. This may happen to frequently, so
#    do the change only every 3 seconds. tick() will handle the
#    followup window size change.
#
sub sig_winch
{
   @state{winch} = time();
}

for my $i (0 .. $#ARGV) {
   if(@ARGV[$i] eq "--noconsole") {
      @state{console} = 0;
   } elsif(@ARGV[$i] eq "--install") {
     install_modules(); 
   } elsif(@ARGV[$i] =~ /^--port=(\d+)$/) {
      @state{port} = $1;
   } elsif(@ARGV[$i] =~ /^--(pass|password)=(.*)$/) {
      @state{p_password} = $2;
      save("muddler","p_password");
   } elsif(@ARGV[$i] =~ /^--xy=(\d+),(\d+)$/) {
      (@state{size_x},@state{size_y}) = ($1,$2);
   } elsif(@ARGV[$i] =~ /^--window=/) {
      @state{console} = 0;
      @state{window_value} = $';
   } elsif(@ARGV[$i] =~ /^--remote=/) {
      my $value = $';
      @state{remote} = 1;
      if($value =~ /^([^:]+):(\d+)$/) {
         @state{remote_address} = $value;
      } else {
         @state{remote_address} = "$value:9001";
      }
   } elsif(@ARGV[$i] =~ /^--remote$/) {
      @state{remote} = 1;
   } elsif(@ARGV[$i] =~ /^--test-worlds$/) {
      exit test_worlds();
   } else {
     die("Invalid Option: '@ARGV[$i]'");
   }
}

load_modules();

ws_init() if !console();

if(!module_enabled("Net::WebSocket::Server") || is_remote()) {
   $ws_server = {};
   $ws_server->{select_readable} = IO::Select->new();
}

eval {
   muddler_init();
};

if($@) {
   LOGGIT($@);
   err("FATAL: $@");
}

if(defined @state{modules}) {
   for my $i (0 .. $#{@state{modules}}) {
      @state{modules}->[$i] =~ s/\r|\n//g;
      echo(@state{world},
           "%s %s",
           (($i == 0) ? "Optional:" : (" " x 9)),
           @state{modules}->[$i]
          );
   }
}

# keep the main loop small.
while(1) {
   eval {
      muddler();
   };
   LOGGIT("Fatal: $@ -> %s\n",code()) if($@);
}

__DATA__
START: muddler_ansi.css
   /* underlined text */
   .ansi-4 { text-decoration: underline; }
   
   /* blinking text */
   .ansi-5 {
       -webkit-animation: blink .75s linear infinite;
       -moz-animation: blink .75s linear infinite;
       -ms-animation: blink .75s linear infinite;
       -o-animation: blink .75s linear infinite;
       animation: blink .75s linear infinite;
   }

   /* standard 16 foreground colors */
   .ansi-30 { color: black; }
   .ansi-1-30 { color: gray; }
   .ansi-31 { color: maroon; }
   .ansi-1-31 { color: red; }
   .ansi-32 { color: green; }
   .ansi-1-32 { color: lime; }
   .ansi-33 { color: olive; }
   .ansi-1-33 { color: yellow; }
   .ansi-34 { color: navy; }
   .ansi-1-34 { color: blue; }
   .ansi-35 { color: purple; }
   .ansi-1-35 { color: fuchsia; }
   .ansi-36 { color: teal; }
   .ansi-1-36 { color: aqua; }
   .ansi-37 { color: black; }
   .ansi-1-37 { color: black; } 


   /* standard 16 background colors */
   .ansi-40 { background-color: black; }
   .ansi-1-40 { background-color: gray; }
   .ansi-41 { background-color: maroon; }
   .ansi-1-41 { background-color: red; }
   .ansi-42 { background-color: green; }
   .ansi-1-42 { background-color: lime; }
   .ansi-43 { background-color: olive; }
   .ansi-1-43 { background-color: yellow; }
   .ansi-44 { background-color: navy; }
   .ansi-1-44 { background-color: blue; }
   .ansi-45 { background-color: purple; }
   .ansi-1-45 { background-color: fuchsia; }
   .ansi-46 { background-color: teal; }
   .ansi-1-46 { background-color: aqua; }
   .ansi-47 { background-color: silver; }
   .ansi-1-47 { background-color: white; }
   
   .ansi-38-5-0     { color:            #000000; }
   .ansi-38-5-1     { color:            #cd0000; }
   .ansi-38-5-2     { color:            #00cd00; }
   .ansi-38-5-3     { color:            #cdcd00; }
   .ansi-38-5-4     { color:            #0000ee; }
   .ansi-38-5-5     { color:            #cd00cd; }
   .ansi-38-5-6     { color:            #00cdcd; }
   .ansi-38-5-7     { color:            #e5e5e5; }
   .ansi-38-5-8     { color:            #7f7f7f; }
   .ansi-38-5-9     { color:            #ff0000; }
   .ansi-38-5-10    { color:            #00ff00; }
   .ansi-38-5-11    { color:            #e8e800; }
   .ansi-38-5-12    { color:            #5c5cff; }
   .ansi-38-5-13    { color:            #ff00ff; }
   .ansi-38-5-14    { color:            #00ffff; }
   .ansi-38-5-15    { color:            #ffffff; }
   
   /* XTERM colors - 256 color mode */
   .ansi-38-5-16    { color:            #000000; }
   .ansi-38-5-17    { color:            #00005f; }
   .ansi-38-5-18    { color:            #000087; }
   .ansi-38-5-19    { color:            #0000af; }
   .ansi-38-5-20    { color:            #0000d7; }
   .ansi-38-5-21    { color:            #0000ff; }
   .ansi-38-5-22    { color:            #005f00; }
   .ansi-38-5-23    { color:            #005f5f; }
   .ansi-38-5-24    { color:            #005f87; }
   .ansi-38-5-25    { color:            #005faf; }
   .ansi-38-5-26    { color:            #005fd7; }
   .ansi-38-5-27    { color:            #005fff; }
   .ansi-38-5-28    { color:            #008700; }
   .ansi-38-5-29    { color:            #00875f; }
   .ansi-38-5-30    { color:            #008787; }
   .ansi-38-5-31    { color:            #0087af; }
   .ansi-38-5-32    { color:            #0087d7; }
   .ansi-38-5-33    { color:            #0087ff; }
   .ansi-38-5-34    { color:            #00af00; }
   .ansi-38-5-35    { color:            #00af5f; }
   .ansi-38-5-36    { color:            #00af87; }
   .ansi-38-5-37    { color:            #00afaf; }
   .ansi-38-5-38    { color:            #00afd7; }
   .ansi-38-5-39    { color:            #00afff; }
   .ansi-38-5-40    { color:            #00d700; }
   .ansi-38-5-41    { color:            #00d75f; }
   .ansi-38-5-42    { color:            #00d787; }
   .ansi-38-5-43    { color:            #00d7af; }
   .ansi-38-5-44    { color:            #00d7d7; }
   .ansi-38-5-45    { color:            #00d7ff; }
   .ansi-38-5-46    { color:            #00ff00; }
   .ansi-38-5-47    { color:            #00ff5f; }
   .ansi-38-5-48    { color:            #00ff87; }
   .ansi-38-5-49    { color:            #00ffaf; }
   .ansi-38-5-50    { color:            #00ffd7; }
   .ansi-38-5-51    { color:            #00ffff; }
   .ansi-38-5-52    { color:            #5f0000; }
   .ansi-38-5-53    { color:            #5f005f; }
   .ansi-38-5-54    { color:            #5f0087; }
   .ansi-38-5-55    { color:            #5f00af; }
   .ansi-38-5-56    { color:            #5f00d7; }
   .ansi-38-5-57    { color:            #5f00ff; }
   .ansi-38-5-58    { color:            #5f5f00; }
   .ansi-38-5-59    { color:            #5f5f5f; }
   .ansi-38-5-60    { color:            #5f5f87; }
   .ansi-38-5-61    { color:            #5f5faf; }
   .ansi-38-5-62    { color:            #5f5fd7; }
   .ansi-38-5-63    { color:            #5f5fff; }
   .ansi-38-5-64    { color:            #5f8700; }
   .ansi-38-5-65    { color:            #5f875f; }
   .ansi-38-5-66    { color:            #5f8787; }
   .ansi-38-5-67    { color:            #5f87af; }
   .ansi-38-5-68    { color:            #5f87d7; }
   .ansi-38-5-69    { color:            #5f87ff; }
   .ansi-38-5-70    { color:            #5faf00; }
   .ansi-38-5-71    { color:            #5faf5f; }
   .ansi-38-5-72    { color:            #5faf87; }
   .ansi-38-5-73    { color:            #5fafaf; }
   .ansi-38-5-74    { color:            #5fafd7; }
   .ansi-38-5-75    { color:            #5fafff; }
   .ansi-38-5-76    { color:            #5fd700; }
   .ansi-38-5-77    { color:            #5fd75f; }
   .ansi-38-5-78    { color:            #5fd787; }
   .ansi-38-5-79    { color:            #5fd7af; }
   .ansi-38-5-80    { color:            #5fd7d7; }
   .ansi-38-5-81    { color:            #5fd7ff; }
   .ansi-38-5-82    { color:            #5fff00; }
   .ansi-38-5-83    { color:            #5fff5f; }
   .ansi-38-5-84    { color:            #5fff87; }
   .ansi-38-5-85    { color:            #5fffaf; }
   .ansi-38-5-86    { color:            #5fffd7; }
   .ansi-38-5-87    { color:            #5fffff; }
   .ansi-38-5-88    { color:            #870000; }
   .ansi-38-5-89    { color:            #87005f; }
   .ansi-38-5-90    { color:            #870087; }
   .ansi-38-5-91    { color:            #8700af; }
   .ansi-38-5-92    { color:            #8700d7; }
   .ansi-38-5-93    { color:            #8700ff; }
   .ansi-38-5-94    { color:            #875f00; }
   .ansi-38-5-95    { color:            #875f5f; }
   .ansi-38-5-96    { color:            #875f87; }
   .ansi-38-5-97    { color:            #875faf; }
   .ansi-38-5-98    { color:            #875fd7; }
   .ansi-38-5-99    { color:            #875fff; }
   .ansi-38-5-100   { color:            #878700; }
   .ansi-38-5-101   { color:            #87875f; }
   .ansi-38-5-102   { color:            #878787; }
   .ansi-38-5-103   { color:            #8787af; }
   .ansi-38-5-104   { color:            #8787d7; }
   .ansi-38-5-105   { color:            #8787ff; }
   .ansi-38-5-106   { color:            #87af00; }
   .ansi-38-5-107   { color:            #87af5f; }
   .ansi-38-5-108   { color:            #87af87; }
   .ansi-38-5-109   { color:            #87afaf; }
   .ansi-38-5-110   { color:            #87afd7; }
   .ansi-38-5-111   { color:            #87afff; }
   .ansi-38-5-112   { color:            #87d700; }
   .ansi-38-5-113   { color:            #87d75f; }
   .ansi-38-5-114   { color:            #87d787; }
   .ansi-38-5-115   { color:            #87d7af; }
   .ansi-38-5-116   { color:            #87d7d7; }
   .ansi-38-5-117   { color:            #87d7ff; }
   .ansi-38-5-118   { color:            #87ff00; }
   .ansi-38-5-119   { color:            #87ff5f; }
   .ansi-38-5-120   { color:            #87ff87; }
   .ansi-38-5-121   { color:            #87ffaf; }
   .ansi-38-5-122   { color:            #87ffd7; }
   .ansi-38-5-123   { color:            #87ffff; }
   .ansi-38-5-124   { color:            #af0000; }
   .ansi-38-5-125   { color:            #af005f; }
   .ansi-38-5-126   { color:            #af0087; }
   .ansi-38-5-127   { color:            #af00af; }
   .ansi-38-5-128   { color:            #af00d7; }
   .ansi-38-5-129   { color:            #af00ff; }
   .ansi-38-5-130   { color:            #af5f00; }
   .ansi-38-5-131   { color:            #af5f5f; }
   .ansi-38-5-132   { color:            #af5f87; }
   .ansi-38-5-133   { color:            #af5faf; }
   .ansi-38-5-134   { color:            #af5fd7; }
   .ansi-38-5-135   { color:            #af5fff; }
   .ansi-38-5-136   { color:            #af8700; }
   .ansi-38-5-137   { color:            #af875f; }
   .ansi-38-5-138   { color:            #af8787; }
   .ansi-38-5-139   { color:            #af87af; }
   .ansi-38-5-140   { color:            #af87d7; }
   .ansi-38-5-141   { color:            #af87ff; }
   .ansi-38-5-142   { color:            #afaf00; }
   .ansi-38-5-143   { color:            #afaf5f; }
   .ansi-38-5-144   { color:            #afaf87; }
   .ansi-38-5-145   { color:            #afafaf; }
   .ansi-38-5-146   { color:            #afafd7; }
   .ansi-38-5-147   { color:            #afafff; }
   .ansi-38-5-148   { color:            #afd700; }
   .ansi-38-5-149   { color:            #afd75f; }
   .ansi-38-5-150   { color:            #afd787; }
   .ansi-38-5-151   { color:            #afd7af; }
   .ansi-38-5-152   { color:            #afd7d7; }
   .ansi-38-5-153   { color:            #afd7ff; }
   .ansi-38-5-154   { color:            #afff00; }
   .ansi-38-5-155   { color:            #afff5f; }
   .ansi-38-5-156   { color:            #afff87; }
   .ansi-38-5-157   { color:            #afffaf; }
   .ansi-38-5-158   { color:            #afffd7; }
   .ansi-38-5-159   { color:            #afffff; }
   .ansi-38-5-160   { color:            #d70000; }
   .ansi-38-5-161   { color:            #d7005f; }
   .ansi-38-5-162   { color:            #d70087; }
   .ansi-38-5-163   { color:            #d700af; }
   .ansi-38-5-164   { color:            #d700d7; }
   .ansi-38-5-165   { color:            #d700ff; }
   .ansi-38-5-166   { color:            #d75f00; }
   .ansi-38-5-167   { color:            #d75f5f; }
   .ansi-38-5-168   { color:            #d75f87; }
   .ansi-38-5-169   { color:            #d75faf; }
   .ansi-38-5-170   { color:            #d75fd7; }
   .ansi-38-5-171   { color:            #d75fff; }
   .ansi-38-5-172   { color:            #d78700; }
   .ansi-38-5-173   { color:            #d7875f; }
   .ansi-38-5-174   { color:            #d78787; }
   .ansi-38-5-175   { color:            #d787af; }
   .ansi-38-5-176   { color:            #d787d7; }
   .ansi-38-5-177   { color:            #d787ff; }
   .ansi-38-5-178   { color:            #d7af00; }
   .ansi-38-5-179   { color:            #d7af5f; }
   .ansi-38-5-180   { color:            #d7af87; }
   .ansi-38-5-181   { color:            #d7afaf; }
   .ansi-38-5-182   { color:            #d7afd7; }
   .ansi-38-5-183   { color:            #d7afff; }
   .ansi-38-5-184   { color:            #d7d700; }
   .ansi-38-5-185   { color:            #d7d75f; }
   .ansi-38-5-186   { color:            #d7d787; }
   .ansi-38-5-187   { color:            #d7d7af; }
   .ansi-38-5-188   { color:            #d7d7d7; }
   .ansi-38-5-189   { color:            #d7d7ff; }
   .ansi-38-5-190   { color:            #d7ff00; }
   .ansi-38-5-191   { color:            #d7ff5f; }
   .ansi-38-5-192   { color:            #d7ff87; }
   .ansi-38-5-193   { color:            #d7ffaf; }
   .ansi-38-5-194   { color:            #d7ffd7; }
   .ansi-38-5-195   { color:            #d7ffff; }
   .ansi-38-5-196   { color:            #ff0000; }
   .ansi-38-5-197   { color:            #ff005f; }
   .ansi-38-5-198   { color:            #ff0087; }
   .ansi-38-5-199   { color:            #ff00af; }
   .ansi-38-5-200   { color:            #ff00d7; }
   .ansi-38-5-201   { color:            #ff00ff; }
   .ansi-38-5-202   { color:            #ff5f00; }
   .ansi-38-5-203   { color:            #ff5f5f; }
   .ansi-38-5-204   { color:            #ff5f87; }
   .ansi-38-5-205   { color:            #ff5faf; }
   .ansi-38-5-206   { color:            #ff5fd7; }
   .ansi-38-5-207   { color:            #ff5fff; }
   .ansi-38-5-208   { color:            #ff8700; }
   .ansi-38-5-209   { color:            #ff875f; }
   .ansi-38-5-210   { color:            #ff8787; }
   .ansi-38-5-211   { color:            #ff87af; }
   .ansi-38-5-212   { color:            #ff87d7; }
   .ansi-38-5-213   { color:            #ff87ff; }
   .ansi-38-5-214   { color:            #ffaf00; }
   .ansi-38-5-215   { color:            #ffaf5f; }
   .ansi-38-5-216   { color:            #ffaf87; }
   .ansi-38-5-217   { color:            #ffafaf; }
   .ansi-38-5-218   { color:            #ffafd7; }
   .ansi-38-5-219   { color:            #ffafff; }
   .ansi-38-5-220   { color:            #ffd700; }
   .ansi-38-5-221   { color:            #ffd75f; }
   .ansi-38-5-222   { color:            #ffd787; }
   .ansi-38-5-223   { color:            #ffd7af; }
   .ansi-38-5-224   { color:            #ffd7d7; }
   .ansi-38-5-225   { color:            #ffd7ff; }
   .ansi-38-5-226   { color:            #ffff00; }
   .ansi-38-5-227   { color:            #ffff5f; }
   .ansi-38-5-228   { color:            #ffff87; }
   .ansi-38-5-229   { color:            #ffffaf; }
   .ansi-38-5-230   { color:            #ffffd7; }
   .ansi-38-5-231   { color:            #ffffff; }
   .ansi-38-5-232   { color:            #080808; }
   .ansi-38-5-233   { color:            #121212; }
   .ansi-38-5-234   { color:            #1c1c1c; }
   .ansi-38-5-235   { color:            #262626; }
   .ansi-38-5-236   { color:            #303030; }
   .ansi-38-5-237   { color:            #3a3a3a; }
   .ansi-38-5-238   { color:            #444444; }
   .ansi-38-5-239   { color:            #4e4e4e; }
   .ansi-38-5-240   { color:            #585858; }
   .ansi-38-5-241   { color:            #626262; }
   .ansi-38-5-242   { color:            #6c6c6c; }
   .ansi-38-5-243   { color:            #767676; }
   .ansi-38-5-244   { color:            #808080; }
   .ansi-38-5-245   { color:            #8a8a8a; }
   .ansi-38-5-246   { color:            #949494; }
   .ansi-38-5-247   { color:            #9e9e9e; }
   .ansi-38-5-248   { color:            #a8a8a8; }
   .ansi-38-5-249   { color:            #b2b2b2; }
   .ansi-38-5-250   { color:            #bcbcbc; }
   .ansi-38-5-251   { color:            #c6c6c6; }
   .ansi-38-5-252   { color:            #d0d0d0; }
   .ansi-38-5-253   { color:            #dadada; }
   .ansi-38-5-254   { color:            #e4e4e4; }
   .ansi-38-5-255   { color:            #eeeeee; }
   
   /* SYSTEM colors */
   
   .ansi-48-5-0   { background-color: #000000; }
   .ansi-48-5-1   { background-color: #cd0000; }
   .ansi-48-5-2   { background-color: #00cd00; }
   .ansi-48-5-3   { background-color: #cdcd00; }
   .ansi-48-5-4   { background-color: #0000ee; }
   .ansi-48-5-5   { background-color: #cd00cd; }
   .ansi-48-5-6   { background-color: #00cdcd; }
   .ansi-48-5-7   { background-color: #e5e5e5; }
   .ansi-48-5-8   { background-color: #7f7f7f; }
   .ansi-48-5-9   { background-color: #ff0000; }
   .ansi-48-5-10  { background-color: #00ff00; }
   .ansi-48-5-11  { background-color: #e8e800; }
   .ansi-48-5-12  { background-color: #5c5cff; }
   .ansi-48-5-13  { background-color: #ff00ff; }
   .ansi-48-5-14  { background-color: #00ffff; }
   .ansi-48-5-15  { background-color: #ffffff; }
   
   /* XTERM colors - 256 color mode */
   .ansi-48-5-16  { background-color: #000000; }
   .ansi-48-5-17  { background-color: #00005f; }
   .ansi-48-5-18  { background-color: #000087; }
   .ansi-48-5-19  { background-color: #0000af; }
   .ansi-48-5-20  { background-color: #0000d7; }
   .ansi-48-5-21  { background-color: #0000ff; }
   .ansi-48-5-22  { background-color: #005f00; }
   .ansi-48-5-23  { background-color: #005f5f; }
   .ansi-48-5-24  { background-color: #005f87; }
   .ansi-48-5-25  { background-color: #005faf; }
   .ansi-48-5-26  { background-color: #005fd7; }
   .ansi-48-5-27  { background-color: #005fff; }
   .ansi-48-5-28  { background-color: #008700; }
   .ansi-48-5-29  { background-color: #00875f; }
   .ansi-48-5-30  { background-color: #008787; }
   .ansi-48-5-31  { background-color: #0087af; }
   .ansi-48-5-32  { background-color: #0087d7; }
   .ansi-48-5-33  { background-color: #0087ff; }
   .ansi-48-5-34  { background-color: #00af00; }
   .ansi-48-5-35  { background-color: #00af5f; }
   .ansi-48-5-36  { background-color: #00af87; }
   .ansi-48-5-37  { background-color: #00afaf; }
   .ansi-48-5-38  { background-color: #00afd7; }
   .ansi-48-5-39  { background-color: #00afff; }
   .ansi-48-5-40  { background-color: #00d700; }
   .ansi-48-5-41  { background-color: #00d75f; }
   .ansi-48-5-42  { background-color: #00d787; }
   .ansi-48-5-43  { background-color: #00d7af; }
   .ansi-48-5-44  { background-color: #00d7d7; }
   .ansi-48-5-45  { background-color: #00d7ff; }
   .ansi-48-5-46  { background-color: #00ff00; }
   .ansi-48-5-47  { background-color: #00ff5f; }
   .ansi-48-5-48  { background-color: #00ff87; }
   .ansi-48-5-49  { background-color: #00ffaf; }
   .ansi-48-5-50  { background-color: #00ffd7; }
   .ansi-48-5-51  { background-color: #00ffff; }
   .ansi-48-5-52  { background-color: #5f0000; }
   .ansi-48-5-53  { background-color: #5f005f; }
   .ansi-48-5-54  { background-color: #5f0087; }
   .ansi-48-5-55  { background-color: #5f00af; }
   .ansi-48-5-56  { background-color: #5f00d7; }
   .ansi-48-5-57  { background-color: #5f00ff; }
   .ansi-48-5-58  { background-color: #5f5f00; }
   .ansi-48-5-59  { background-color: #5f5f5f; }
   .ansi-48-5-60  { background-color: #5f5f87; }
   .ansi-48-5-61  { background-color: #5f5faf; }
   .ansi-48-5-62  { background-color: #5f5fd7; }
   .ansi-48-5-63  { background-color: #5f5fff; }
   .ansi-48-5-64  { background-color: #5f8700; }
   .ansi-48-5-65  { background-color: #5f875f; }
   .ansi-48-5-66  { background-color: #5f8787; }
   .ansi-48-5-67  { background-color: #5f87af; }
   .ansi-48-5-68  { background-color: #5f87d7; }
   .ansi-48-5-69  { background-color: #5f87ff; }
   .ansi-48-5-70  { background-color: #5faf00; }
   .ansi-48-5-71  { background-color: #5faf5f; }
   .ansi-48-5-72  { background-color: #5faf87; }
   .ansi-48-5-73  { background-color: #5fafaf; }
   .ansi-48-5-74  { background-color: #5fafd7; }
   .ansi-48-5-75  { background-color: #5fafff; }
   .ansi-48-5-76  { background-color: #5fd700; }
   .ansi-48-5-77  { background-color: #5fd75f; }
   .ansi-48-5-78  { background-color: #5fd787; }
   .ansi-48-5-79  { background-color: #5fd7af; }
   .ansi-48-5-80  { background-color: #5fd7d7; }
   .ansi-48-5-81  { background-color: #5fd7ff; }
   .ansi-48-5-82  { background-color: #5fff00; }
   .ansi-48-5-83  { background-color: #5fff5f; }
   .ansi-48-5-84  { background-color: #5fff87; }
   .ansi-48-5-85  { background-color: #5fffaf; }
   .ansi-48-5-86  { background-color: #5fffd7; }
   .ansi-48-5-87  { background-color: #5fffff; }
   .ansi-48-5-88  { background-color: #870000; }
   .ansi-48-5-89  { background-color: #87005f; }
   .ansi-48-5-90  { background-color: #870087; }
   .ansi-48-5-91  { background-color: #8700af; }
   .ansi-48-5-92  { background-color: #8700d7; }
   .ansi-48-5-93  { background-color: #8700ff; }
   .ansi-48-5-94  { background-color: #875f00; }
   .ansi-48-5-95  { background-color: #875f5f; }
   .ansi-48-5-96  { background-color: #875f87; }
   .ansi-48-5-97  { background-color: #875faf; }
   .ansi-48-5-98  { background-color: #875fd7; }
   .ansi-48-5-99  { background-color: #875fff; }
   .ansi-48-5-100 { background-color: #878700; }
   .ansi-48-5-101 { background-color: #87875f; }
   .ansi-48-5-102 { background-color: #878787; }
   .ansi-48-5-103 { background-color: #8787af; }
   .ansi-48-5-104 { background-color: #8787d7; }
   .ansi-48-5-105 { background-color: #8787ff; }
   .ansi-48-5-106 { background-color: #87af00; }
   .ansi-48-5-107 { background-color: #87af5f; }
   .ansi-48-5-108 { background-color: #87af87; }
   .ansi-48-5-109 { background-color: #87afaf; }
   .ansi-48-5-110 { background-color: #87afd7; }
   .ansi-48-5-111 { background-color: #87afff; }
   .ansi-48-5-112 { background-color: #87d700; }
   .ansi-48-5-113 { background-color: #87d75f; }
   .ansi-48-5-114 { background-color: #87d787; }
   .ansi-48-5-115 { background-color: #87d7af; }
   .ansi-48-5-116 { background-color: #87d7d7; }
   .ansi-48-5-117 { background-color: #87d7ff; }
   .ansi-48-5-118 { background-color: #87ff00; }
   .ansi-48-5-119 { background-color: #87ff5f; }
   .ansi-48-5-120 { background-color: #87ff87; }
   .ansi-48-5-121 { background-color: #87ffaf; }
   .ansi-48-5-122 { background-color: #87ffd7; }
   .ansi-48-5-123 { background-color: #87ffff; }
   .ansi-48-5-124 { background-color: #af0000; }
   .ansi-48-5-125 { background-color: #af005f; }
   .ansi-48-5-126 { background-color: #af0087; }
   .ansi-48-5-127 { background-color: #af00af; }
   .ansi-48-5-128 { background-color: #af00d7; }
   .ansi-48-5-129 { background-color: #af00ff; }
   .ansi-48-5-130 { background-color: #af5f00; }
   .ansi-48-5-131 { background-color: #af5f5f; }
   .ansi-48-5-132 { background-color: #af5f87; }
   .ansi-48-5-133 { background-color: #af5faf; }
   .ansi-48-5-134 { background-color: #af5fd7; }
   .ansi-48-5-135 { background-color: #af5fff; }
   .ansi-48-5-136 { background-color: #af8700; }
   .ansi-48-5-137 { background-color: #af875f; }
   .ansi-48-5-138 { background-color: #af8787; }
   .ansi-48-5-139 { background-color: #af87af; }
   .ansi-48-5-140 { background-color: #af87d7; }
   .ansi-48-5-141 { background-color: #af87ff; }
   .ansi-48-5-142 { background-color: #afaf00; }
   .ansi-48-5-143 { background-color: #afaf5f; }
   .ansi-48-5-144 { background-color: #afaf87; }
   .ansi-48-5-145 { background-color: #afafaf; }
   .ansi-48-5-146 { background-color: #afafd7; }
   .ansi-48-5-147 { background-color: #afafff; }
   .ansi-48-5-148 { background-color: #afd700; }
   .ansi-48-5-149 { background-color: #afd75f; }
   .ansi-48-5-150 { background-color: #afd787; }
   .ansi-48-5-151 { background-color: #afd7af; }
   .ansi-48-5-152 { background-color: #afd7d7; }
   .ansi-48-5-153 { background-color: #afd7ff; }
   .ansi-48-5-154 { background-color: #afff00; }
   .ansi-48-5-155 { background-color: #afff5f; }
   .ansi-48-5-156 { background-color: #afff87; }
   .ansi-48-5-157 { background-color: #afffaf; }
   .ansi-48-5-158 { background-color: #afffd7; }
   .ansi-48-5-159 { background-color: #afffff; }
   .ansi-48-5-160 { background-color: #d70000; }
   .ansi-48-5-161 { background-color: #d7005f; }
   .ansi-48-5-162 { background-color: #d70087; }
   .ansi-48-5-163 { background-color: #d700af; }
   .ansi-48-5-164 { background-color: #d700d7; }
   .ansi-48-5-165 { background-color: #d700ff; }
   .ansi-48-5-166 { background-color: #d75f00; }
   .ansi-48-5-167 { background-color: #d75f5f; }
   .ansi-48-5-168 { background-color: #d75f87; }
   .ansi-48-5-169 { background-color: #d75faf; }
   .ansi-48-5-170 { background-color: #d75fd7; }
   .ansi-48-5-171 { background-color: #d75fff; }
   .ansi-48-5-172 { background-color: #d78700; }
   .ansi-48-5-173 { background-color: #d7875f; }
   .ansi-48-5-174 { background-color: #d78787; }
   .ansi-48-5-175 { background-color: #d787af; }
   .ansi-48-5-176 { background-color: #d787d7; }
   .ansi-48-5-177 { background-color: #d787ff; }
   .ansi-48-5-178 { background-color: #d7af00; }
   .ansi-48-5-179 { background-color: #d7af5f; }
   .ansi-48-5-180 { background-color: #d7af87; }
   .ansi-48-5-181 { background-color: #d7afaf; }
   .ansi-48-5-182 { background-color: #d7afd7; }
   .ansi-48-5-183 { background-color: #d7afff; }
   .ansi-48-5-184 { background-color: #d7d700; }
   .ansi-48-5-185 { background-color: #d7d75f; }
   .ansi-48-5-186 { background-color: #d7d787; }
   .ansi-48-5-187 { background-color: #d7d7af; }
   .ansi-48-5-188 { background-color: #d7d7d7; }
   .ansi-48-5-189 { background-color: #d7d7ff; }
   .ansi-48-5-190 { background-color: #d7ff00; }
   .ansi-48-5-191 { background-color: #d7ff5f; }
   .ansi-48-5-192 { background-color: #d7ff87; }
   .ansi-48-5-193 { background-color: #d7ffaf; }
   .ansi-48-5-194 { background-color: #d7ffd7; }
   .ansi-48-5-195 { background-color: #d7ffff; }
   .ansi-48-5-196 { background-color: #ff0000; }
   .ansi-48-5-197 { background-color: #ff005f; }
   .ansi-48-5-198 { background-color: #ff0087; }
   .ansi-48-5-199 { background-color: #ff00af; }
   .ansi-48-5-200 { background-color: #ff00d7; }
   .ansi-48-5-201 { background-color: #ff00ff; }
   .ansi-48-5-202 { background-color: #ff5f00; }
   .ansi-48-5-203 { background-color: #ff5f5f; }
   .ansi-48-5-204 { background-color: #ff5f87; }
   .ansi-48-5-205 { background-color: #ff5faf; }
   .ansi-48-5-206 { background-color: #ff5fd7; }
   .ansi-48-5-207 { background-color: #ff5fff; }
   .ansi-48-5-208 { background-color: #ff8700; }
   .ansi-48-5-209 { background-color: #ff875f; }
   .ansi-48-5-210 { background-color: #ff8787; }
   .ansi-48-5-211 { background-color: #ff87af; }
   .ansi-48-5-212 { background-color: #ff87d7; }
   .ansi-48-5-213 { background-color: #ff87ff; }
   .ansi-48-5-214 { background-color: #ffaf00; }
   .ansi-48-5-215 { background-color: #ffaf5f; }
   .ansi-48-5-216 { background-color: #ffaf87; }
   .ansi-48-5-217 { background-color: #ffafaf; }
   .ansi-48-5-218 { background-color: #ffafd7; }
   .ansi-48-5-219 { background-color: #ffafff; }
   .ansi-48-5-220 { background-color: #ffd700; }
   .ansi-48-5-221 { background-color: #ffd75f; }
   .ansi-48-5-222 { background-color: #ffd787; }
   .ansi-48-5-223 { background-color: #ffd7af; }
   .ansi-48-5-224 { background-color: #ffd7d7; }
   .ansi-48-5-225 { background-color: #ffd7ff; }
   .ansi-48-5-226 { background-color: #ffff00; }
   .ansi-48-5-227 { background-color: #ffff5f; }
   .ansi-48-5-228 { background-color: #ffff87; }
   .ansi-48-5-229 { background-color: #ffffaf; }
   .ansi-48-5-230 { background-color: #ffffd7; }
   .ansi-48-5-231 { background-color: #ffffff; }
   .ansi-48-5-232 { background-color: #080808; }
   .ansi-48-5-233 { background-color: #121212; }
   .ansi-48-5-234 { background-color: #1c1c1c; }
   .ansi-48-5-235 { background-color: #262626; }
   .ansi-48-5-236 { background-color: #303030; }
   .ansi-48-5-237 { background-color: #3a3a3a; }
   .ansi-48-5-238 { background-color: #444444; }
   .ansi-48-5-239 { background-color: #4e4e4e; }
   .ansi-48-5-240 { background-color: #585858; }
   .ansi-48-5-241 { background-color: #626262; }
   .ansi-48-5-242 { background-color: #6c6c6c; }
   .ansi-48-5-243 { background-color: #767676; }
   .ansi-48-5-244 { background-color: #808080; }
   .ansi-48-5-245 { background-color: #8a8a8a; }
   .ansi-48-5-246 { background-color: #949494; }
   .ansi-48-5-247 { background-color: #9e9e9e; }
   .ansi-48-5-248 { background-color: #a8a8a8; }
   .ansi-48-5-249 { background-color: #b2b2b2; }
   .ansi-48-5-250 { background-color: #bcbcbc; }
   .ansi-48-5-251 { background-color: #c6c6c6; }
   .ansi-48-5-252 { background-color: #d0d0d0; }
   .ansi-48-5-253 { background-color: #dadada; }
   .ansi-48-5-254 { background-color: #e4e4e4; }
   .ansi-48-5-255 { background-color: #eeeeee; }

START: muddler_dark_ansi.css
   .ansi-4 { text-decoration: underline; }
   
   /* blinking text */
   .ansi-5 {
       -webkit-animation: blink .75s linear infinite;
       -moz-animation: blink .75s linear infinite;
       -ms-animation: blink .75s linear infinite;
       -o-animation: blink .75s linear infinite;
       animation: blink .75s linear infinite;
   }
   
   /* standard 16 foreground colors */
   .ansi-30 { color: black; }
   .ansi-1-30 { color: gray; }
   .ansi-31 { color: maroon; }
   .ansi-1-31 { color: red; }
   .ansi-32 { color: green; }
   .ansi-1-32 { color: lime; }
   .ansi-33 { color: olive; }
   .ansi-1-33 { color: yellow; }
   .ansi-34 { color: navy; }
   .ansi-1-34 { color: blue; }
   .ansi-35 { color: purple; }
   .ansi-1-35 { color: fuchsia; }
   .ansi-36 { color: teal; }
   .ansi-1-36 { color: aqua; }
   .ansi-37 { color: black; }
   .ansi-1-37 { color: white; }
   
   /* standard 16 background colors */
   .ansi-40 { background-color: black; }
   .ansi-1-40 { background-color: gray; }
   .ansi-41 { background-color: maroon; }
   .ansi-1-41 { background-color: red; }
   .ansi-42 { background-color: green; }
   .ansi-1-42 { background-color: lime; }
   .ansi-43 { background-color: olive; }
   .ansi-1-43 { background-color: yellow; }
   .ansi-44 { background-color: navy; }
   .ansi-1-44 { background-color: blue; }
   .ansi-45 { background-color: purple; }
   .ansi-1-45 { background-color: fuchsia; }
   .ansi-46 { background-color: teal; }
   .ansi-1-46 { background-color: aqua; }
   .ansi-47 { background-color: silver; }
   .ansi-1-47 { background-color: white; }
   
   /* xterm256 foreground colors */
   .ansi-38-5-0 { color: #000000; }
   .ansi-38-5-1 { color: #800000; }
   .ansi-38-5-2 { color: #008000; }
   .ansi-38-5-3 { color: #808000; }
   .ansi-38-5-4 { color: #000080; }
   .ansi-38-5-5 { color: #800080; }
   .ansi-38-5-6 { color: #008080; }
   .ansi-38-5-7 { color: #c0c0c0; }
   .ansi-38-5-8 { color: #808080; }
   .ansi-38-5-9 { color: #ff0000; }
   .ansi-38-5-10 { color: #00ff00; }
   .ansi-38-5-11 { color: #ffff00; }
   .ansi-38-5-12 { color: #0000ff; }
   .ansi-38-5-13 { color: #ff00ff; }
   .ansi-38-5-14 { color: #00ffff; }
   .ansi-38-5-15 { color: #ffffff; }
   .ansi-38-5-16 { color: #000000; }
   .ansi-38-5-17 { color: #00005f; }
   .ansi-38-5-18 { color: #000087; }
   .ansi-38-5-19 { color: #0000af; }
   .ansi-38-5-20 { color: #0000d7; }
   .ansi-38-5-21 { color: #0000ff; }
   .ansi-38-5-22 { color: #005f00; }
   .ansi-38-5-23 { color: #005f5f; }
   .ansi-38-5-24 { color: #005f87; }
   .ansi-38-5-25 { color: #005faf; }
   .ansi-38-5-26 { color: #005fd7; }
   .ansi-38-5-27 { color: #005fff; }
   .ansi-38-5-28 { color: #008700; }
   .ansi-38-5-29 { color: #00875f; }
   .ansi-38-5-30 { color: #008787; }
   .ansi-38-5-31 { color: #0087af; }
   .ansi-38-5-32 { color: #0087d7; }
   .ansi-38-5-33 { color: #0087ff; }
   .ansi-38-5-34 { color: #00af00; }
   .ansi-38-5-35 { color: #00af5f; }
   .ansi-38-5-36 { color: #00af87; }
   .ansi-38-5-37 { color: #00afaf; }
   .ansi-38-5-38 { color: #00afd7; }
   .ansi-38-5-39 { color: #00afff; }
   .ansi-38-5-40 { color: #00d700; }
   .ansi-38-5-41 { color: #00d75f; }
   .ansi-38-5-42 { color: #00d787; }
   .ansi-38-5-43 { color: #00d7af; }
   .ansi-38-5-44 { color: #00d7d7; }
   .ansi-38-5-45 { color: #00d7ff; }
   .ansi-38-5-46 { color: #00ff00; }
   .ansi-38-5-47 { color: #00ff5f; }
   .ansi-38-5-48 { color: #00ff87; }
   .ansi-38-5-49 { color: #00ffaf; }
   .ansi-38-5-50 { color: #00ffd7; }
   .ansi-38-5-51 { color: #00ffff; }
   .ansi-38-5-52 { color: #5f0000; }
   .ansi-38-5-53 { color: #5f005f; }
   .ansi-38-5-54 { color: #5f0087; }
   .ansi-38-5-55 { color: #5f00af; }
   .ansi-38-5-56 { color: #5f00d7; }
   .ansi-38-5-57 { color: #5f00ff; }
   .ansi-38-5-58 { color: #5f5f00; }
   .ansi-38-5-59 { color: #5f5f5f; }
   .ansi-38-5-60 { color: #5f5f87; }
   .ansi-38-5-61 { color: #5f5faf; }
   .ansi-38-5-62 { color: #5f5fd7; }
   .ansi-38-5-63 { color: #5f5fff; }
   .ansi-38-5-64 { color: #5f8700; }
   .ansi-38-5-65 { color: #5f875f; }
   .ansi-38-5-66 { color: #5f8787; }
   .ansi-38-5-67 { color: #5f87af; }
   .ansi-38-5-68 { color: #5f87d7; }
   .ansi-38-5-69 { color: #5f87ff; }
   .ansi-38-5-70 { color: #5faf00; }
   .ansi-38-5-71 { color: #5faf5f; }
   .ansi-38-5-72 { color: #5faf87; }
   .ansi-38-5-73 { color: #5fafaf; }
   .ansi-38-5-74 { color: #5fafd7; }
   .ansi-38-5-75 { color: #5fafff; }
   .ansi-38-5-76 { color: #5fd700; }
   .ansi-38-5-77 { color: #5fd75f; }
   .ansi-38-5-78 { color: #5fd787; }
   .ansi-38-5-79 { color: #5fd7af; }
   .ansi-38-5-80 { color: #5fd7d7; }
   .ansi-38-5-81 { color: #5fd7ff; }
   .ansi-38-5-82 { color: #5fff00; }
   .ansi-38-5-83 { color: #5fff5f; }
   .ansi-38-5-84 { color: #5fff87; }
   .ansi-38-5-85 { color: #5fffaf; }
   .ansi-38-5-86 { color: #5fffd7; }
   .ansi-38-5-87 { color: #5fffff; }
   .ansi-38-5-88 { color: #870000; }
   .ansi-38-5-89 { color: #87005f; }
   .ansi-38-5-90 { color: #870087; }
   .ansi-38-5-91 { color: #8700af; }
   .ansi-38-5-92 { color: #8700d7; }
   .ansi-38-5-93 { color: #8700ff; }
   .ansi-38-5-94 { color: #875f00; }
   .ansi-38-5-95 { color: #875f5f; }
   .ansi-38-5-96 { color: #875f87; }
   .ansi-38-5-97 { color: #875faf; }
   .ansi-38-5-98 { color: #875fd7; }
   .ansi-38-5-99 { color: #875fff; }
   .ansi-38-5-100 { color: #878700; }
   .ansi-38-5-101 { color: #87875f; }
   .ansi-38-5-102 { color: #878787; }
   .ansi-38-5-103 { color: #8787af; }
   .ansi-38-5-104 { color: #8787d7; }
   .ansi-38-5-105 { color: #8787ff; }
   .ansi-38-5-106 { color: #87af00; }
   .ansi-38-5-107 { color: #87af5f; }
   .ansi-38-5-108 { color: #87af87; }
   .ansi-38-5-109 { color: #87afaf; }
   .ansi-38-5-110 { color: #87afd7; }
   .ansi-38-5-111 { color: #87afff; }
   .ansi-38-5-112 { color: #87d700; }
   .ansi-38-5-113 { color: #87d75f; }
   .ansi-38-5-114 { color: #87d787; }
   .ansi-38-5-115 { color: #87d7af; }
   .ansi-38-5-116 { color: #87d7d7; }
   .ansi-38-5-117 { color: #87d7ff; }
   .ansi-38-5-118 { color: #87ff00; }
   .ansi-38-5-119 { color: #87ff5f; }
   .ansi-38-5-120 { color: #87ff87; }
   .ansi-38-5-121 { color: #87ffaf; }
   .ansi-38-5-122 { color: #87ffd7; }
   .ansi-38-5-123 { color: #87ffff; }
   .ansi-38-5-124 { color: #af0000; }
   .ansi-38-5-125 { color: #af005f; }
   .ansi-38-5-126 { color: #af0087; }
   .ansi-38-5-127 { color: #af00af; }
   .ansi-38-5-128 { color: #af00d7; }
   .ansi-38-5-129 { color: #af00ff; }
   .ansi-38-5-130 { color: #af5f00; }
   .ansi-38-5-131 { color: #af5f5f; }
   .ansi-38-5-132 { color: #af5f87; }
   .ansi-38-5-133 { color: #af5faf; }
   .ansi-38-5-134 { color: #af5fd7; }
   .ansi-38-5-135 { color: #af5fff; }
   .ansi-38-5-136 { color: #af8700; }
   .ansi-38-5-137 { color: #af875f; }
   .ansi-38-5-138 { color: #af8787; }
   .ansi-38-5-139 { color: #af87af; }
   .ansi-38-5-140 { color: #af87d7; }
   .ansi-38-5-141 { color: #af87ff; }
   .ansi-38-5-142 { color: #afaf00; }
   .ansi-38-5-143 { color: #afaf5f; }
   .ansi-38-5-144 { color: #afaf87; }
   .ansi-38-5-145 { color: #afafaf; }
   .ansi-38-5-146 { color: #afafd7; }
   .ansi-38-5-147 { color: #afafff; }
   .ansi-38-5-148 { color: #afd700; }
   .ansi-38-5-149 { color: #afd75f; }
   .ansi-38-5-150 { color: #afd787; }
   .ansi-38-5-151 { color: #afd7af; }
   .ansi-38-5-152 { color: #afd7d7; }
   .ansi-38-5-153 { color: #afd7ff; }
   .ansi-38-5-154 { color: #afff00; }
   .ansi-38-5-155 { color: #afff5f; }
   .ansi-38-5-156 { color: #afff87; }
   .ansi-38-5-157 { color: #afffaf; }
   .ansi-38-5-158 { color: #afffd7; }
   .ansi-38-5-159 { color: #afffff; }
   .ansi-38-5-160 { color: #d70000; }
   .ansi-38-5-161 { color: #d7005f; }
   .ansi-38-5-162 { color: #d70087; }
   .ansi-38-5-163 { color: #d700af; }
   .ansi-38-5-164 { color: #d700d7; }
   .ansi-38-5-165 { color: #d700ff; }
   .ansi-38-5-166 { color: #d75f00; }
   .ansi-38-5-167 { color: #d75f5f; }
   .ansi-38-5-168 { color: #d75f87; }
   .ansi-38-5-169 { color: #d75faf; }
   .ansi-38-5-170 { color: #d75fd7; }
   .ansi-38-5-171 { color: #d75fff; }
   .ansi-38-5-172 { color: #d78700; }
   .ansi-38-5-173 { color: #d7875f; }
   .ansi-38-5-174 { color: #d78787; }
   .ansi-38-5-175 { color: #d787af; }
   .ansi-38-5-176 { color: #d787d7; }
   .ansi-38-5-177 { color: #d787ff; }
   .ansi-38-5-178 { color: #d7af00; }
   .ansi-38-5-179 { color: #d7af5f; }
   .ansi-38-5-180 { color: #d7af87; }
   .ansi-38-5-181 { color: #d7afaf; }
   .ansi-38-5-182 { color: #d7afd7; }
   .ansi-38-5-183 { color: #d7afff; }
   .ansi-38-5-184 { color: #d7d700; }
   .ansi-38-5-185 { color: #d7d75f; }
   .ansi-38-5-186 { color: #d7d787; }
   .ansi-38-5-187 { color: #d7d7af; }
   .ansi-38-5-188 { color: #d7d7d7; }
   .ansi-38-5-189 { color: #d7d7ff; }
   .ansi-38-5-190 { color: #d7ff00; }
   .ansi-38-5-191 { color: #d7ff5f; }
   .ansi-38-5-192 { color: #d7ff87; }
   .ansi-38-5-193 { color: #d7ffaf; }
   .ansi-38-5-194 { color: #d7ffd7; }
   .ansi-38-5-195 { color: #d7ffff; }
   .ansi-38-5-196 { color: #ff0000; }
   .ansi-38-5-197 { color: #ff005f; }
   .ansi-38-5-198 { color: #ff0087; }
   .ansi-38-5-199 { color: #ff00af; }
   .ansi-38-5-200 { color: #ff00d7; }
   .ansi-38-5-201 { color: #ff00ff; }
   .ansi-38-5-202 { color: #ff5f00; }
   .ansi-38-5-203 { color: #ff5f5f; }
   .ansi-38-5-204 { color: #ff5f87; }
   .ansi-38-5-205 { color: #ff5faf; }
   .ansi-38-5-206 { color: #ff5fd7; }
   .ansi-38-5-207 { color: #ff5fff; }
   .ansi-38-5-208 { color: #ff8700; }
   .ansi-38-5-209 { color: #ff875f; }
   .ansi-38-5-210 { color: #ff8787; }
   .ansi-38-5-211 { color: #ff87af; }
   .ansi-38-5-212 { color: #ff87d7; }
   .ansi-38-5-213 { color: #ff87ff; }
   .ansi-38-5-214 { color: #ffaf00; }
   .ansi-38-5-215 { color: #ffaf5f; }
   .ansi-38-5-216 { color: #ffaf87; }
   .ansi-38-5-217 { color: #ffafaf; }
   .ansi-38-5-218 { color: #ffafd7; }
   .ansi-38-5-219 { color: #ffafff; }
   .ansi-38-5-220 { color: #ffd700; }
   .ansi-38-5-221 { color: #ffd75f; }
   .ansi-38-5-222 { color: #ffd787; }
   .ansi-38-5-223 { color: #ffd7af; }
   .ansi-38-5-224 { color: #ffd7d7; }
   .ansi-38-5-225 { color: #ffd7ff; }
   .ansi-38-5-226 { color: #ffff00; }
   .ansi-38-5-227 { color: #ffff5f; }
   .ansi-38-5-228 { color: #ffff87; }
   .ansi-38-5-229 { color: #ffffaf; }
   .ansi-38-5-230 { color: #ffffd7; }
   .ansi-38-5-231 { color: #ffffff; }
   .ansi-38-5-232 { color: #080808; }
   .ansi-38-5-233 { color: #121212; }
   .ansi-38-5-234 { color: #1c1c1c; }
   .ansi-38-5-235 { color: #262626; }
   .ansi-38-5-236 { color: #303030; }
   .ansi-38-5-237 { color: #3a3a3a; }
   .ansi-38-5-238 { color: #444444; }
   .ansi-38-5-239 { color: #4e4e4e; }
   .ansi-38-5-240 { color: #585858; }
   .ansi-38-5-241 { color: #626262; }
   .ansi-38-5-242 { color: #6c6c6c; }
   .ansi-38-5-243 { color: #767676; }
   .ansi-38-5-244 { color: #808080; }
   .ansi-38-5-245 { color: #8a8a8a; }
   .ansi-38-5-246 { color: #949494; }
   .ansi-38-5-247 { color: #9e9e9e; }
   .ansi-38-5-248 { color: #a8a8a8; }
   .ansi-38-5-249 { color: #b2b2b2; }
   .ansi-38-5-250 { color: #bcbcbc; }
   .ansi-38-5-251 { color: #c6c6c6; }
   .ansi-38-5-252 { color: #d0d0d0; }
   .ansi-38-5-253 { color: #dadada; }
   .ansi-38-5-254 { color: #e4e4e4; }
   .ansi-38-5-255 { color: #eeeeee; }
   
   /* xterm256 background colors */
   .ansi-48-5-0 { background-color: #000000; }
   .ansi-48-5-1 { background-color: #800000; }
   .ansi-48-5-2 { background-color: #008000; }
   .ansi-48-5-3 { background-color: #808000; }
   .ansi-48-5-4 { background-color: #000080; }
   .ansi-48-5-5 { background-color: #800080; }
   .ansi-48-5-6 { background-color: #008080; }
   .ansi-48-5-7 { background-color: #c0c0c0; }
   .ansi-48-5-8 { background-color: #808080; }
   .ansi-48-5-9 { background-color: #ff0000; }
   .ansi-48-5-10 { background-color: #00ff00; }
   .ansi-48-5-11 { background-color: #ffff00; }
   .ansi-48-5-12 { background-color: #0000ff; }
   .ansi-48-5-13 { background-color: #ff00ff; }
   .ansi-48-5-14 { background-color: #00ffff; }
   .ansi-48-5-15 { background-color: #ffffff; }
   .ansi-48-5-16 { background-color: #000000; }
   .ansi-48-5-17 { background-color: #00005f; }
   .ansi-48-5-18 { background-color: #000087; }
   .ansi-48-5-19 { background-color: #0000af; }
   .ansi-48-5-20 { background-color: #0000d7; }
   .ansi-48-5-21 { background-color: #0000ff; }
   .ansi-48-5-22 { background-color: #005f00; }
   .ansi-48-5-23 { background-color: #005f5f; }
   .ansi-48-5-24 { background-color: #005f87; }
   .ansi-48-5-25 { background-color: #005faf; }
   .ansi-48-5-26 { background-color: #005fd7; }
   .ansi-48-5-27 { background-color: #005fff; }
   .ansi-48-5-28 { background-color: #008700; }
   .ansi-48-5-29 { background-color: #00875f; }
   .ansi-48-5-30 { background-color: #008787; }
   .ansi-48-5-31 { background-color: #0087af; }
   .ansi-48-5-32 { background-color: #0087d7; }
   .ansi-48-5-33 { background-color: #0087ff; }
   .ansi-48-5-34 { background-color: #00af00; }
   .ansi-48-5-35 { background-color: #00af5f; }
   .ansi-48-5-36 { background-color: #00af87; }
   .ansi-48-5-37 { background-color: #00afaf; }
   .ansi-48-5-38 { background-color: #00afd7; }
   .ansi-48-5-39 { background-color: #00afff; }
   .ansi-48-5-40 { background-color: #00d700; }
   .ansi-48-5-41 { background-color: #00d75f; }
   .ansi-48-5-42 { background-color: #00d787; }
   .ansi-48-5-43 { background-color: #00d7af; }
   .ansi-48-5-44 { background-color: #00d7d7; }
   .ansi-48-5-45 { background-color: #00d7ff; }
   .ansi-48-5-46 { background-color: #00ff00; }
   .ansi-48-5-47 { background-color: #00ff5f; }
   .ansi-48-5-48 { background-color: #00ff87; }
   .ansi-48-5-49 { background-color: #00ffaf; }
   .ansi-48-5-50 { background-color: #00ffd7; }
   .ansi-48-5-51 { background-color: #00ffff; }
   .ansi-48-5-52 { background-color: #5f0000; }
   .ansi-48-5-53 { background-color: #5f005f; }
   .ansi-48-5-54 { background-color: #5f0087; }
   .ansi-48-5-55 { background-color: #5f00af; }
   .ansi-48-5-56 { background-color: #5f00d7; }
   .ansi-48-5-57 { background-color: #5f00ff; }
   .ansi-48-5-58 { background-color: #5f5f00; }
   .ansi-48-5-59 { background-color: #5f5f5f; }
   .ansi-48-5-60 { background-color: #5f5f87; }
   .ansi-48-5-61 { background-color: #5f5faf; }
   .ansi-48-5-62 { background-color: #5f5fd7; }
   .ansi-48-5-63 { background-color: #5f5fff; }
   .ansi-48-5-64 { background-color: #5f8700; }
   .ansi-48-5-65 { background-color: #5f875f; }
   .ansi-48-5-66 { background-color: #5f8787; }
   .ansi-48-5-67 { background-color: #5f87af; }
   .ansi-48-5-68 { background-color: #5f87d7; }
   .ansi-48-5-69 { background-color: #5f87ff; }
   .ansi-48-5-70 { background-color: #5faf00; }
   .ansi-48-5-71 { background-color: #5faf5f; }
   .ansi-48-5-72 { background-color: #5faf87; }
   .ansi-48-5-73 { background-color: #5fafaf; }
   .ansi-48-5-74 { background-color: #5fafd7; }
   .ansi-48-5-75 { background-color: #5fafff; }
   .ansi-48-5-76 { background-color: #5fd700; }
   .ansi-48-5-77 { background-color: #5fd75f; }
   .ansi-48-5-78 { background-color: #5fd787; }
   .ansi-48-5-79 { background-color: #5fd7af; }
   .ansi-48-5-80 { background-color: #5fd7d7; }
   .ansi-48-5-81 { background-color: #5fd7ff; }
   .ansi-48-5-82 { background-color: #5fff00; }
   .ansi-48-5-83 { background-color: #5fff5f; }
   .ansi-48-5-84 { background-color: #5fff87; }
   .ansi-48-5-85 { background-color: #5fffaf; }
   .ansi-48-5-86 { background-color: #5fffd7; }
   .ansi-48-5-87 { background-color: #5fffff; }
   .ansi-48-5-88 { background-color: #870000; }
   .ansi-48-5-89 { background-color: #87005f; }
   .ansi-48-5-90 { background-color: #870087; }
   .ansi-48-5-91 { background-color: #8700af; }
   .ansi-48-5-92 { background-color: #8700d7; }
   .ansi-48-5-93 { background-color: #8700ff; }
   .ansi-48-5-94 { background-color: #875f00; }
   .ansi-48-5-95 { background-color: #875f5f; }
   .ansi-48-5-96 { background-color: #875f87; }
   .ansi-48-5-97 { background-color: #875faf; }
   .ansi-48-5-98 { background-color: #875fd7; }
   .ansi-48-5-99 { background-color: #875fff; }
   .ansi-48-5-100 { background-color: #878700; }
   .ansi-48-5-101 { background-color: #87875f; }
   .ansi-48-5-102 { background-color: #878787; }
   .ansi-48-5-103 { background-color: #8787af; }
   .ansi-48-5-104 { background-color: #8787d7; }
   .ansi-48-5-105 { background-color: #8787ff; }
   .ansi-48-5-106 { background-color: #87af00; }
   .ansi-48-5-107 { background-color: #87af5f; }
   .ansi-48-5-108 { background-color: #87af87; }
   .ansi-48-5-109 { background-color: #87afaf; }
   .ansi-48-5-110 { background-color: #87afd7; }
   .ansi-48-5-111 { background-color: #87afff; }
   .ansi-48-5-112 { background-color: #87d700; }
   .ansi-48-5-113 { background-color: #87d75f; }
   .ansi-48-5-114 { background-color: #87d787; }
   .ansi-48-5-115 { background-color: #87d7af; }
   .ansi-48-5-116 { background-color: #87d7d7; }
   .ansi-48-5-117 { background-color: #87d7ff; }
   .ansi-48-5-118 { background-color: #87ff00; }
   .ansi-48-5-119 { background-color: #87ff5f; }
   .ansi-48-5-120 { background-color: #87ff87; }
   .ansi-48-5-121 { background-color: #87ffaf; }
   .ansi-48-5-122 { background-color: #87ffd7; }
   .ansi-48-5-123 { background-color: #87ffff; }
   .ansi-48-5-124 { background-color: #af0000; }
   .ansi-48-5-125 { background-color: #af005f; }
   .ansi-48-5-126 { background-color: #af0087; }
   .ansi-48-5-127 { background-color: #af00af; }
   .ansi-48-5-128 { background-color: #af00d7; }
   .ansi-48-5-129 { background-color: #af00ff; }
   .ansi-48-5-130 { background-color: #af5f00; }
   .ansi-48-5-131 { background-color: #af5f5f; }
   .ansi-48-5-132 { background-color: #af5f87; }
   .ansi-48-5-133 { background-color: #af5faf; }
   .ansi-48-5-134 { background-color: #af5fd7; }
   .ansi-48-5-135 { background-color: #af5fff; }
   .ansi-48-5-136 { background-color: #af8700; }
   .ansi-48-5-137 { background-color: #af875f; }
   .ansi-48-5-138 { background-color: #af8787; }
   .ansi-48-5-139 { background-color: #af87af; }
   .ansi-48-5-140 { background-color: #af87d7; }
   .ansi-48-5-141 { background-color: #af87ff; }
   .ansi-48-5-142 { background-color: #afaf00; }
   .ansi-48-5-143 { background-color: #afaf5f; }
   .ansi-48-5-144 { background-color: #afaf87; }
   .ansi-48-5-145 { background-color: #afafaf; }
   .ansi-48-5-146 { background-color: #afafd7; }
   .ansi-48-5-147 { background-color: #afafff; }
   .ansi-48-5-148 { background-color: #afd700; }
   .ansi-48-5-149 { background-color: #afd75f; }
   .ansi-48-5-150 { background-color: #afd787; }
   .ansi-48-5-151 { background-color: #afd7af; }
   .ansi-48-5-152 { background-color: #afd7d7; }
   .ansi-48-5-153 { background-color: #afd7ff; }
   .ansi-48-5-154 { background-color: #afff00; }
   .ansi-48-5-155 { background-color: #afff5f; }
   .ansi-48-5-156 { background-color: #afff87; }
   .ansi-48-5-157 { background-color: #afffaf; }
   .ansi-48-5-158 { background-color: #afffd7; }
   .ansi-48-5-159 { background-color: #afffff; }
   .ansi-48-5-160 { background-color: #d70000; }
   .ansi-48-5-161 { background-color: #d7005f; }
   .ansi-48-5-162 { background-color: #d70087; }
   .ansi-48-5-163 { background-color: #d700af; }
   .ansi-48-5-164 { background-color: #d700d7; }
   .ansi-48-5-165 { background-color: #d700ff; }
   .ansi-48-5-166 { background-color: #d75f00; }
   .ansi-48-5-167 { background-color: #d75f5f; }
   .ansi-48-5-168 { background-color: #d75f87; }
   .ansi-48-5-169 { background-color: #d75faf; }
   .ansi-48-5-170 { background-color: #d75fd7; }
   .ansi-48-5-171 { background-color: #d75fff; }
   .ansi-48-5-172 { background-color: #d78700; }
   .ansi-48-5-173 { background-color: #d7875f; }
   .ansi-48-5-174 { background-color: #d78787; }
   .ansi-48-5-175 { background-color: #d787af; }
   .ansi-48-5-176 { background-color: #d787d7; }
   .ansi-48-5-177 { background-color: #d787ff; }
   .ansi-48-5-178 { background-color: #d7af00; }
   .ansi-48-5-179 { background-color: #d7af5f; }
   .ansi-48-5-180 { background-color: #d7af87; }
   .ansi-48-5-181 { background-color: #d7afaf; }
   .ansi-48-5-182 { background-color: #d7afd7; }
   .ansi-48-5-183 { background-color: #d7afff; }
   .ansi-48-5-184 { background-color: #d7d700; }
   .ansi-48-5-185 { background-color: #d7d75f; }
   .ansi-48-5-186 { background-color: #d7d787; }
   .ansi-48-5-187 { background-color: #d7d7af; }
   .ansi-48-5-188 { background-color: #d7d7d7; }
   .ansi-48-5-189 { background-color: #d7d7ff; }
   .ansi-48-5-190 { background-color: #d7ff00; }
   .ansi-48-5-191 { background-color: #d7ff5f; }
   .ansi-48-5-192 { background-color: #d7ff87; }
   .ansi-48-5-193 { background-color: #d7ffaf; }
   .ansi-48-5-194 { background-color: #d7ffd7; }
   .ansi-48-5-195 { background-color: #d7ffff; }
   .ansi-48-5-196 { background-color: #ff0000; }
   .ansi-48-5-197 { background-color: #ff005f; }
   .ansi-48-5-198 { background-color: #ff0087; }
   .ansi-48-5-199 { background-color: #ff00af; }
   .ansi-48-5-200 { background-color: #ff00d7; }
   .ansi-48-5-201 { background-color: #ff00ff; }
   .ansi-48-5-202 { background-color: #ff5f00; }
   .ansi-48-5-203 { background-color: #ff5f5f; }
   .ansi-48-5-204 { background-color: #ff5f87; }
   .ansi-48-5-205 { background-color: #ff5faf; }
   .ansi-48-5-206 { background-color: #ff5fd7; }
   .ansi-48-5-207 { background-color: #ff5fff; }
   .ansi-48-5-208 { background-color: #ff8700; }
   .ansi-48-5-209 { background-color: #ff875f; }
   .ansi-48-5-210 { background-color: #ff8787; }
   .ansi-48-5-211 { background-color: #ff87af; }
   .ansi-48-5-212 { background-color: #ff87d7; }
   .ansi-48-5-213 { background-color: #ff87ff; }
   .ansi-48-5-214 { background-color: #ffaf00; }
   .ansi-48-5-215 { background-color: #ffaf5f; }
   .ansi-48-5-216 { background-color: #ffaf87; }
   .ansi-48-5-217 { background-color: #ffafaf; }
   .ansi-48-5-218 { background-color: #ffafd7; }
   .ansi-48-5-219 { background-color: #ffafff; }
   .ansi-48-5-220 { background-color: #ffd700; }
   .ansi-48-5-221 { background-color: #ffd75f; }
   .ansi-48-5-222 { background-color: #ffd787; }
   .ansi-48-5-223 { background-color: #ffd7af; }
   .ansi-48-5-224 { background-color: #ffd7d7; }
   .ansi-48-5-225 { background-color: #ffd7ff; }
   .ansi-48-5-226 { background-color: #ffff00; }
   .ansi-48-5-227 { background-color: #ffff5f; }
   .ansi-48-5-228 { background-color: #ffff87; }
   .ansi-48-5-229 { background-color: #ffffaf; }
   .ansi-48-5-230 { background-color: #ffffd7; }
   .ansi-48-5-231 { background-color: #ffffff; }
   .ansi-48-5-232 { background-color: #080808; }
   .ansi-48-5-233 { background-color: #121212; }
   .ansi-48-5-234 { background-color: #1c1c1c; }
   .ansi-48-5-235 { background-color: #262626; }
   .ansi-48-5-236 { background-color: #303030; }
   .ansi-48-5-237 { background-color: #3a3a3a; }
   .ansi-48-5-248 { background-color: #444444; }
   .ansi-48-5-239 { background-color: #4e4e4e; }
   .ansi-48-5-240 { background-color: #585858; }
   .ansi-48-5-241 { background-color: #626262; }
   .ansi-48-5-242 { background-color: #6c6c6c; }
   .ansi-48-5-243 { background-color: #767676; }
   .ansi-48-5-244 { background-color: #808080; }
   .ansi-48-5-245 { background-color: #8a8a8a; }
   .ansi-48-5-246 { background-color: #949494; }
   .ansi-48-5-247 { background-color: #9e9e9e; }
   .ansi-48-5-248 { background-color: #a8a8a8; }
   .ansi-48-5-249 { background-color: #b2b2b2; }
   .ansi-48-5-250 { background-color: #bcbcbc; }
   .ansi-48-5-251 { background-color: #c6c6c6; }
   .ansi-48-5-252 { background-color: #d0d0d0; }
   .ansi-48-5-253 { background-color: #dadada; }
   .ansi-48-5-254 { background-color: #e4e4e4; }
   .ansi-48-5-255 { background-color: #eeeeee; }
__ANSI__

START: muddler_style.css
   html, body {
     left: 0px;
     right: 0px;
     bottom: 0px;
     top: 0px;
     position: absolute;
/*     width: 100%;
     height: 100%; */
     margin: 0;
     overflow: hidden;
     background: #2667bd;
   /*     font-family: 'Courier New', monospace; */
   /*     font-family: 'termnine',Monospace; */
     font-family: Monospace;
     font-size: 11pt;
     font-weight: normal;
   }
   
   a {
     display: inline;
     text-decoration: none;
     border-bottom: 1px solid blue;
   }
   
   a:hover {
     cursor: pointer;
   }
   
   textarea {
     font-family: inherit;
     font-size: inherit;
   }
   
   ul {
     display: flex;
     flex-direction: column;
     list-style-type: none;
     margin: 0;
     padding: 0;
   }
   
   .localEcho {
     color: blue;
     font-weight: bold;
   }
   
   .logMessage {
     color: red;
     font-weight: bold;
   }
   
   #terminal {
     position: fixed;
     margin: 0;
     padding: 0;
     border: none;
     background: white;
     left: 0px;
     right: 0px;
     top: 0px;
     bottom: 0px;
     box-shadow: 0 0 0.2em 0.1em gray;
     overflow: hidden;
     /* display: none; */
   }
   
   #output {
     overflow: hidden;
     white-space: pre-wrap;
     word-wrap: break-word;
     position: absolute;
     margin: 0;
     border: 0;
     padding: 0.0em 0.0% 0.0em 0.0%;
     left: 0;
     width: 99%;
     top: 0;
     bottom: 71px; /* 6em */
     line-height: 110%;
#     word-spacing: 20;
     background: white; 
     font-size: 10pt;
   }
   
   #bar {
     padding: 0.0em 0.0% 0.0em 0.0%;
     white-space: pre-wrap;
     color: red;
     font-weight: bold;
     display: table-cell;
     overflow: hidden;
     position: absolute;
     left: 0;
     width: 100%;
     bottom: 50px;
     height: 1.4em;
     vertical-align: middle;
     text-align: left;
     border-bottom: 1px solid black;
   }
   
   #bartime {
     padding: 0.0em 0.0% 0.0em 0.0%;
     white-space: pre-wrap;
     color: red;
     font-weight: bold;
     display: table-cell;
     overflow: hidden;
     position: absolute;
     left: 0;
     width: 100%;
     bottom: 50px; /* 4em */
     height: 1.4em;
     vertical-align: middle;
     text-align: right;
   }

   #prompt {
     overflow: hidden;
     white-space: pre-wrap;
     text-align: left;
     position: absolute;
     margin: 0;
     left: 0;
     width: 100%;
     bottom: 4em;
     height: 1em;
   }
   
   #input {
     position: absolute;
     margin: 0;
     background: white;
     color: black;
     border: none;
     outline: none;
     vertical-align: middle;
     padding: 0.1em 0.1% 0.1em 0.1%;
     resize: none;
     left: 0;
     width: 99%;
     bottom: 0;
     height: 3em;
   }
   #buttonbar {
     position: absolute; 
     bottom: 5px;
     left: 0;
     right: 0;
     height: 30px;
     display: none;
/*     position: absolute;
     margin: 0;
     background: white;
     color: black;
     border: none;
     outline: none;
     vertical-align: middle;
     padding: 0px 0px 0px 0px;
     resize: none;
     left: 0;
     width: 100%;
     bottom: 0;
     height: 30px;
     float: left;
     position: absolute; */
#     display: none;
   }

   .triangle {
       border: 2px solid gray;
       position: absolute;
       height: 100px;
       width: 100px;
       z-index: 2; 
   }
   
   .inner-triangle {
      width: 0;
      height: 0;
      border-top: 70px solid #ffcc00;
      border-bottom: 70px solid transparent;
      border-left: 70px solid transparent;
      position:absolute;
      right:0;
      z-index: 2; 
   }

   .inner-triangle span {
      position:absolute;
      top: -50px;
      width: 70px;
      left: -60px;
      text-align: center;
      transform: rotate(45deg);
      display: block;
      z-index: 10;
   }

START: muddler_client.js
   //////////////////////////////////////////////////////////////////
   // WebSockClient for PennMUSH
   // There is no license. Just make a neato game with it.
   //////////////////////////////////////////////////////////////////
   

   // tell the actual client that the window is no longer focused
   function window_blurred() {
       input.onEnter('/blurred')
   }

   // tell the actual client that the window is focused
   function window_focused() {
       input.onEnter('/focused')
   }

   window.addEventListener('blur', window_blurred);
   window.addEventListener('focus', window_focused);
   var WSClient = (function (window, document, undefined) {
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // MU* protocol carried over the WebSocket API.


     function displaywheel(e){
         var evt=window.event || e //equalize event object
         var delta=evt.detail? evt.detail*(-500) : evt.wheelDelta 
         //check for detail first so Opera uses that instead of wheelDelta
         window.console.log(delta);
         if(delta < 0) {
             input.onEnter('/key_pgdn 5')
         } else {
             input.onEnter('/key_pgup 5');
         }
     }
 
     var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x
 
     if (document.attachEvent) //if IE (and Opera depending on user setting)
         document.attachEvent("on"+mousewheelevt, displaywheel)
     else if (document.addEventListener) //WC3 browsers
         document.addEventListener(mousewheelevt, displaywheel, false)

      var t

      window.onresize = () => {
          clearTimeout(t); 
          t = setTimeout(() => { t = undefined; resEnded() }, 500);
      }
      
      function resEnded() { 
          input.onEnter('/web_size ' + get_xy_size() + '\r\n' );
      }

      function get_xy_size() {
         var out = document.getElementById('output')
         var css = getComputedStyle(out,null);
         var ff  = css.getPropertyValue("font-family");
         var fs  = css.getPropertyValue("font-size");
         var temp = document.createElement('span');

         temp.style = "margin:0px;padding:0px;font-family:"+ff+
                      ";font-size:" + fs;

         temp.innerText = "0123456789";
         var element = document.body.appendChild(temp);
         var x = Math.round(out.offsetHeight / (temp.offsetHeight-2));
         var y = Math.round(out.offsetWidth / (temp.offsetWidth / 10));
         temp.parentNode.removeChild(temp);
         return x + "," + y + "," + fs + "-" + ff + "=2";
     }
   
     function Connection(url) {
       var that = this;
       
       this.url = url;
       this.socket = null;
       this.isOpen = false;
       
       Connection.reconnect(that);
     }
     
     Connection.CHANNEL_TEXT   = 't';
     Connection.CHANNEL_BAR    = 'b';
     Connection.CHANNEL_BARTIME= '*';
     Connection.CHANNEL_JSON   = 'j';
     Connection.CHANNEL_HTML   = 'h';
     Connection.CHANNEL_PUEBLO = 'p';
     Connection.CHANNEL_PROMPT = '>';
     Connection.CHANNEL_DO     = 'd';
   
     Connection.reconnect = function (that) {
       const now = +new Date();

          that.reconnect();
     };
     
     Connection.onopen = function (that, evt) {
       that.isOpen = true;
       that.onOpen && that.onOpen(evt);
     };
   
     Connection.onerror = function (that, evt) {
       that.isOpen = false;
       that.onError && that.onError(evt);
     };
   
     Connection.onclose = function (that, evt) {
       that.isOpen = false;
       that.onClose && that.onClose(evt);
     };
   
     Connection.onmessage = function (that, evt) {
       that.onMessage && that.onMessage(evt.data[0], evt.data.substring(1));
     };

     Connection.prototype.reconnect = function () {
       var that = this;
       
       // quit the old connection, if we have one
       if (this.isConnected()) {
         var old = this.socket;
         this.isOpen && setTimeout(old.close, 1000);
       }
   
       console.log('URL: ' + this.url);
       this.socket = new window.WebSocket(this.url);
       this.isOpen = false;

       this.socket.onopen = function (evt) {
         Connection.onopen(that, evt);
       };
   
       this.socket.onerror = function (evt) {
         Connection.onerror(that, evt);
       };
   
       this.socket.onclose = function (evt) {
         Connection.onclose(that, evt);
       };
   
       this.socket.onmessage = function (evt) {
         Connection.onmessage(that, evt);
       };
     };
     
     Connection.prototype.isConnected = function() {
       return (this.socket && this.isOpen && (this.socket.readyState === 1));
     };
   
     Connection.prototype.close = function () {
       this.socket && this.socket.close();
     };
   
     Connection.prototype.sendText = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_TEXT + data + '\r\n');
     };
   
     Connection.prototype.sendBar = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_BAR + data + '\r\n');
     };
   
     Connection.prototype.sendObject = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_JSON + window.JSON.stringify(data));
     };
   
     Connection.prototype.onOpen = null;
     Connection.prototype.onError = null;
     Connection.prototype.onClose = null;
   
     Connection.prototype.onMessage = function (channel, data) {
       switch (channel) {
       case Connection.CHANNEL_TEXT:
         this.onText && this.onText(data);
         break;
   
       case Connection.CHANNEL_BAR:
         this.onBar && this.onBar(data);
         break;

       case Connection.CHANNEL_BARTIME:
         this.onBarTime && this.onBarTime(data);
         break;
   
       case Connection.CHANNEL_JSON:
         this.onObject && this.onObject(window.JSON.parse(data));
         break;
   
       case Connection.CHANNEL_HTML:
         this.onHTML && this.onHTML(data);
         break;
   
       case Connection.CHANNEL_PUEBLO:
         this.onPueblo && this.onPueblo(data);
         break;
       
       case Connection.CHANNEL_PROMPT:
         this.onPrompt && this.onPrompt(data);
         break;
  
       case Connection.CHANNEL_DO:
           data = data.replace(/[\r\n]+/g, '').trim();

           // console.log("request: " + data);

           if(data === "mobile on") {
              document.querySelector('#bar').style.bottom = "52px";
              document.querySelector('#bartime').style.bottom = "52px";
              var obj = document.getElementById("output");
              document.querySelector('#terminal').style.bottom = "30px";
              document.querySelector('#buttonbar').style.display = 
                  "inline-block";
              document.querySelector('#output').style.fontSize = "6pt";
              document.querySelector('#output').style.bottom = "74px";
              document.querySelector('#bar').style.fontSize = "6pt";
              document.querySelector('#bartime').style.fontSize= "6pt";
              obj.style.fontSize = "6pt";
              obj.scrollTop = obj.scrollHeight;
              document.querySelector('#input').style.bottom = '4px';
              sendCommand('/web_size ' + get_xy_size("6pt") + '\r\n');
           } else if(data === "mobile off") {
              var obj = document.getElementById("output");
              document.querySelector('#terminal').style.bottom = 0;
              document.querySelector('#buttonbar').style.display = "none";
              document.querySelector('#output').style.fontSize = "10pt";
//              obj.style.fontSize = "10pt";
              obj.scrollTop = obj.scrollHeight;

              document.querySelector('#bar').style.bottom = "50px";
              document.querySelector('#bartime').style.bottom = "50px";
              document.querySelector('#terminal').style.bottom = "0px";
              document.querySelector('#output').style.bottom = "71px";
              document.querySelector('#input').style.bottom = '0px';
              document.querySelector('#bar').style.fontSize = "11pt";
              document.querySelector('#bartime').style.fontSize= "11pt";

              sendCommand('/web_size ' + get_xy_size("10pt") + '\r\n');
           } else if(data === "theme light") {
              document.querySelector('.ansi-37').style.color='black';
              document.getElementById('output').style.backgroundColor='white';
              document.getElementById('bar').style.backgroundColor='white';
              document.getElementById('input').style.backgroundColor = 'white';
              document.querySelector('#bar').style.borderBottom =
                  '1px solid black';
              document.querySelector('#terminal').style.background = 'white';
              document.querySelector('#input').style.color= 'black';
           } else if(data === "theme dark") {
              document.getElementById('output').style.backgroundColor=
                 '#131712';
              document.getElementById('bar').style.backgroundColor = '#131712';
              document.getElementById('input').style.backgroundColor='#131712';
              document.querySelector('#terminal').style.background = '#131712';
              document.querySelector('#bar').style.borderBottom=
                 '1px solid white';
              document.querySelector('.ansi-37').style.color  = 'white';
              document.querySelector('#input').style.color= 'white';
           } else if(data === "clear") {
              document.getElementById('output').innerHTML = ""
           } else if(data === "password") {
              sendCommand(window.prompt("Enter password","password"));
           } else {
              console.log("unknown do request: " + data);
           }
           break;
   
       default:
         window.console && window.console.log('unhandled message', data);
         return false;
       }
   
       return true;
     };
   
     Connection.prototype.onText = null;
     Connection.prototype.onClear = null;
     Connection.prototype.onBar = null;
     Connection.prototype.onBarTime = null;
     Connection.prototype.onObject = null;
     Connection.prototype.onHTML = null;
     Connection.prototype.onPueblo = null;
     Connection.prototype.onPrompt = null;
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // MU* terminal emulator.
     function Terminal(root) {
       this.root = root;
       
       if (root === null) {
         return null;
       }
       
       this.clear();
     }
   
     Terminal.PARSE_PLAIN = 0;
     Terminal.PARSE_CR = 1;
     Terminal.PARSE_ESC1 = 2;
     Terminal.PARSE_ESC2 = 3;
   
     Terminal.ANSI_NORMAL = 0;
     Terminal.ANSI_BRIGHT = 1;
     Terminal.ANSI_UNDERLINE = 4;
     Terminal.ANSI_BLINK = 5;
     Terminal.ANSI_INVERSE = 7;
     Terminal.ANSI_XTERM_FG = 38;
     Terminal.ANSI_XTERM_BG = 48;
   
     Terminal.DEFAULT_FG = 37;
     Terminal.DEFAULT_BG = 30;
     
     Terminal.UNCLOSED_TAGS = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',
             'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];
   
   
     /////////////////////////////////////////////////////
     // ansi parsing routines
     
     Terminal.encodeState = function (state) {
       if (!state) {
         return '';
       }
   
       var classes = [];
   
       if (state[Terminal.ANSI_INVERSE]) {
         var value = state.fg;
         state.fg = state.bg;
         state.bg = value;
         
         value = state.fg256;
         state.fg256 = state.bg256;
         state.bg256 = value;
       }
       
       var fg = state.fg;
       var bg = state.bg;
       
       if (state[Terminal.ANSI_UNDERLINE]) {
         classes[classes.length] = 'ansi-' + Terminal.ANSI_UNDERLINE;
       }
   
       // make sure to avoid conflict with XTERM256 color's usage of blink (code 5)
       if (state.fg256) {
         classes[classes.length] = 'ansi-38-5-' + state.fg;
       } else {  
         if (state[Terminal.ANSI_BRIGHT]) {
           if (state[Terminal.ANSI_INVERSE]) {
             if (fg !== Terminal.DEFAULT_FG) {
               classes[classes.length] = 'ansi-' + fg;
             }
           } else {
             classes[classes.length] = 'ansi-1-' + fg;
           }
         } else if (fg !== Terminal.DEFAULT_FG) {
           classes[classes.length] = 'ansi-' + fg;
         }
       }
       
       if (state.bg256) {
         classes[classes.length] = 'ansi-48-5-' + state.bg;
       } else {
         if (state[Terminal.ANSI_BRIGHT]) {
           if (state[Terminal.ANSI_INVERSE]) {
             classes[classes.length] = 'ansi-1-' + (bg + 10);
           } else {
             if (bg !== Terminal.DEFAULT_BG) {
               classes[classes.length] = 'ansi-' + (bg + 10);
             }
           }
         } else if (bg !== Terminal.DEFAULT_BG) {
           classes[classes.length] = 'ansi-' + (bg + 10);
         }
       }
   
       if (state[Terminal.ANSI_BLINK] && !(state.fg256 || state.bg256)) {
         classes[classes.length] = 'ansi-' + Terminal.ANSI_BLINK;
       }
       
       return classes.join(' ');
     };
   
     Terminal.prototype.getANSI = function () {
       if (!this.ansiState) {
         this.ansiState = {
           fg: Terminal.DEFAULT_FG,
           bg: Terminal.DEFAULT_BG,
           fg256: false,
           bg256: false
         };
       }
   
       return this.ansiState;
     };
   
     Terminal.prototype.applyANSI = function (ansi) {
       switch (ansi.charCodeAt(ansi.length - 1)) {
       case 109: // m (SGR)
         var codes = ansi.substring(0, ansi.length - 1).split(';');
   
         var value, state;
         for (var ii = 0; (value = codes[ii]) !== undefined; ++ii) {
           if (value.length === 0) {
             // Empty is treated as the equivalent of 0.
             value = Terminal.ANSI_NORMAL;
           } else {
             value = parseInt(value);
           }
           
           state = this.getANSI();
           
           // check for xterm256 fg/bg first, fallback to standard codes otherwise
           if (state[Terminal.ANSI_XTERM_FG] && state[Terminal.ANSI_BLINK]) {
             if (value >= 0 && value <= 255) {
               state.fg = value;
               state.fg256 = true;
               state[Terminal.ANSI_XTERM_FG] = false;
               state[Terminal.ANSI_BLINK] = false;
             } else {
               // invalid xterm256, let's reset the ansi state due to bad codes
               this.ansiState = null;
             }
           } else if (state[Terminal.ANSI_XTERM_BG] && state[Terminal.ANSI_BLINK]) {
             if (value >= 0 && value <= 255) {
               state.bg = value;
               state.bg256 = true;
               state[Terminal.ANSI_XTERM_BG] = false;
               state[Terminal.ANSI_BLINK] = false;
             } else {
               // invalid xterm256, let's reset the ansi state due to bad codes
               this.ansiState = null;
             }
           } else {
             // detect regular ansi codes
             switch (value) {
             case Terminal.ANSI_NORMAL: // reset
               this.ansiState = null;
               break;
   
             case Terminal.ANSI_BRIGHT:
             case Terminal.ANSI_UNDERLINE:
             case Terminal.ANSI_BLINK:
             case Terminal.ANSI_INVERSE:
             case Terminal.ANSI_XTERM_FG:
             case Terminal.ANSI_XTERM_BG:
               state[value] = true;
               break;
   
             default:
               if (30 <= value && value <= 37) {
                 state.fg = value;
               } else if (40 <= value && value <= 47) {
                 state.bg = value - 10;
               }
              break;
             }
           }
   
           this.ansiDirty = true;
         }
         break;
       }
     };
   
     Terminal.prototype.write = function (value, start, end) {
       if (start === end) {
         return;
       }
   
       if (this.ansiDirty) {
         var next = Terminal.encodeState(this.ansiState);
   
         if (this.ansiClass !== next) {
           this.ansiClass = next;
           this.span = null;
         }
   
         this.ansiDirty = false;
       }
   
       if (this.ansiClass && !this.span) {
         this.span = document.createElement('span');
         this.span.className = this.ansiClass;
         this.stack[this.stack.length - 1].appendChild(this.span);
       }
   
       var text = document.createTextNode(value.substring(start, end));
       this.lineBuf[this.lineBuf.length] = text;
   
       this.appendChild(text);
     };
   
     Terminal.prototype.endLine = function () {
       var that = this;
       this.onLine && this.onLine(that, this.lineBuf);
   
       this.write('\n', 0, 1);
       this.lineBuf.length = 0;
     };
   
     Terminal.prototype.abortParse = function (value, start, end) {
       switch (this.state) {
       case Terminal.PARSE_PLAIN:
         this.write(value, start, end);
         break;
   
       case Terminal.PARSE_ESC1:
         this.write('\u001B', 0, 1);
         break;
   
       case Terminal.PARSE_ESC2:
         this.write('\u001B[', 0, 2);
         this.write(this.parseBuf, 0, this.parseBuf.length);
         this.parseBuf = '';
         break;
       }
     };
   
     /////////////////////////////////////////////////////
     // message appending routines
     
     // appends a text string to the terminal, parsing ansi escape codes into html/css
     Terminal.prototype.appendText = function (data) {
       var start = 0;
   
       // Scan for sequence start characters.
       // TODO: Could scan with RegExp; not convinced sufficiently simpler/faster.
       for (var ii = 0, ilen = data.length; ii < ilen; ++ii) {
         var ch = data.charCodeAt(ii);
   
         // Resynchronize at special characters.
         switch (ch) {
         case 10: // newline
           if (this.state !== Terminal.PARSE_CR) {
             this.abortParse(data, start, ii);
             this.endLine();
           }
   
           start = ii + 1;
           this.state = Terminal.PARSE_PLAIN;
           continue;
   
         case 13: // carriage return
           this.abortParse(data, start, ii);
           this.endLine();
           start = ii + 1;
           this.state = Terminal.PARSE_CR;
           continue;
   
         case 27: // escape
           this.abortParse(data, start, ii);
           start = ii + 1;
           this.state = Terminal.PARSE_ESC1;
           continue;
         }
   
         // Parse other characters.
         switch (this.state) {
         case Terminal.PARSE_CR:
           this.state = Terminal.PARSE_PLAIN;
           break;
   
         case Terminal.PARSE_ESC1:
           if (ch === 91) {
             // Start of escape sequence (\e[).
             start = ii + 1;
             this.state = Terminal.PARSE_ESC2;
           } else {
             // Not an escape sequence.
             this.abortParse(data, start, ii);
             start = ii;
             this.state = Terminal.PARSE_PLAIN;
           }
           break;
   
         case Terminal.PARSE_ESC2:
           if (64 <= ch && ch <= 126) {
             // End of escape sequence.
             this.parseBuf += data.substring(start, (start = ii + 1));
             this.applyANSI(this.parseBuf);
             this.parseBuf = '';
             this.state = Terminal.PARSE_PLAIN;
           }
           break;
         }
       }
   
       // Handle tail.
       switch (this.state) {
       case Terminal.PARSE_PLAIN:
         this.write(data, start, data.length);
         break;
   
       case Terminal.PARSE_ESC2:
         this.parseBuf += data.substring(start);
         break;
       }
     };
   
     Terminal.prototype.appendHTML = function (html) {
       var div = document.createElement('div');
       var fragment = document.createDocumentFragment();
   
       div.innerHTML = html;
   
       for (var child = div.firstChild; child; child = child.nextSibling) {
         var cmd = child.getAttribute('xch_cmd');
         if (cmd !== null && cmd !== '') {
           child.setAttribute('onClick', 'this.onCommand("' + cmd + '");');
           child.onCommand = this.onCommand;
           child.removeAttribute('xch_cmd');
         }
         fragment.appendChild(child);
       }
   
       this.appendChild(fragment);
     };
   
     // append an HTML fragment to the terminal
     Terminal.prototype.appendChild = function (fragment) {
       var last = (this.span || this.stack[this.stack.length - 1]);
       last.appendChild(fragment);
       
       this.scrollDown();
     };
     
     // append a log message to the terminal
     Terminal.prototype.appendMessage = function (classid, message) {
       var div = document.createElement('div');
       div.className = classid;
       
       // create a text node to safely append the string without rendering code
       var text = document.createTextNode(message);
       div.appendChild(text);
       
       this.appendChild(div);
     };
     
     // push a new html element onto the stack
     Terminal.prototype.pushElement = function (element) {
       this.span = null;
       this.stack[this.stack.length - 1].appendChild(element);
       this.stack[this.stack.length] = element;
     };
   
     // remove 1 level from the stack, check consistency 
     Terminal.prototype.popElement = function () {
       this.span = null;
   
       if (this.stack.length > 1) {
         --this.stack.length;
       } else {
         window.console && window.console.warn('element stack underflow');
       }
     };
   
     // append a pueblo tag to the terminal stack (or pop if an end tag)
     Terminal.prototype.appendPueblo = function (data) {
       var tag, attrs;
   
       var idx = data.indexOf(' ');
       if (idx !== -1) {
         tag = data.substring(0, idx);
         attrs = data.substring(idx + 1);
       } else {
         tag = data;
         attrs = '';
       }
       
       var html = '<' + tag + (attrs ? ' ' : '') + attrs + '>';
   
       var start;
       if (tag[0] !== '/') {
         start = true;
       } else {
         start = false;
         tag = tag.substring(1);
       }
       
       // detect a self closed tag
       var selfClosing = false;
       if ((tag.substring(-1) === '/') || (attrs.substring(-1) === '/')) {
         selfClosing = true;
       }
       
       if (Terminal.UNCLOSED_TAGS.indexOf(tag.toLowerCase()) > -1) {
         selfClosing = true;
       }
   
       if ((tag === 'XCH_PAGE') || 
           ((tag === 'IMG') && (attrs.search(/xch_graph=(("[^"]*")|('[^']*')|([^\s]*))/i) !== -1))) {
         //console.log("unhandled pueblo", html);
         return;
       }
   
       // we have a starting <tag> (not </tag>)
       if (start) {
         var div = document.createElement('div');
   
         html = html.replace(
           /xch_graph=(("[^"]*")|('[^']*')|([^\s]*))/i,
           ''
         );
   
         html = html.replace(
           /xch_mode=(("[^"]*")|('[^']*')|([^\s]*))/i,
           ''
         );
   
         html = html.replace(
           /xch_hint="([^"]*)"/i,
           'title="$1"'
         );
   
         div.innerHTML = html.replace(
           /xch_cmd="([^"]*)"/i,
           "onClick='this.onCommand(&quot;$1&quot;)'"
         );
         
         div.firstChild.onCommand = this.onCommand;
   
         div.setAttribute('target', '_blank');
         
         // add this tag to the stack to keep track of nested elements
         this.pushElement(div.firstChild);
   
         // automatically pop the tag if it is self closing
         if (selfClosing) {
           this.popElement();
         }
   
       } else {
         // we have an ending </tag> so remove the closed tag from the stack
         // don't bother for self closing tags with an explicit end tag, we already popped them
         if (!selfClosing) {
           this.popElement();
         }
       }
     };
     
     Terminal.prototype.clear = function() {
       this.root.innerHTML = '';
   
       this.stack = [this.root];
   
       this.state = Terminal.PARSE_PLAIN;
       this.line = null;
       this.lineBuf = [];
       this.span = null;
       this.parseBuf = '';
   
       this.ansiClass = '';
       this.ansiState = null;
       this.ansiDirty = false;
     };
     
     // animate scrolling the terminal window to the bottom
     Terminal.prototype.scrollDown = function() {
       // TODO: May want to animate this, to make it less abrupt.
       //this.root.scrollTop = this.root.scrollHeight;
       //return;
       
       var root = this.root;
       var scrollCount = 0;
       var scrollDuration = 500.0;
       var oldTimestamp = performance.now();
   
       function step (newTimestamp) {
         var bottom = root.scrollHeight - root.clientHeight;
         var delta = (bottom - root.scrollTop) / 2.0;
   
         scrollCount += Math.PI / (scrollDuration / (newTimestamp - oldTimestamp));
         if (scrollCount >= Math.PI) root.scrollTo(0, bottom);
         if (root.scrollTop === bottom) { return; }
         root.scrollTo(0, Math.round(root.scrollTop + delta));
         oldTimestamp = newTimestamp;
         window.requestAnimationFrame(step);
       }
       window.requestAnimationFrame(step);
     };
   
     // setup the pueblo xch_cmd callback
     Terminal.prototype.onCommand = null;
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // User input handler (command history, callback events)
     function UserInput(root) {
       var that = this;
       
       if (root === null) {
         return null;
       }
       
       this.root = root;
       
       this.clearHistory();
     
       this.root.onkeydown = function(evt) {
         UserInput.onkeydown(that, evt);
       };
       
       this.root.onkeyup = function(evt) {
         UserInput.onkeyup(that, evt);
       };
     }
     
     // clear the history for a given UserInput object
     UserInput.clearhistory = function(that) {
   
     };
     
     // passthrough to the local onKeyDown callback
     UserInput.onkeydown = function(that, evt) {
       that.onKeyDown && that.onKeyDown(evt);
     };
   
     // passthrough to the local onKeyUp callback
     UserInput.onkeyup = function(that, evt) {
       that.onKeyUp && that.onKeyUp(evt);
     };
     
     // set the default onKeyDown handler
     UserInput.prototype.onKeyDown = function(e) {
       PressKey(this, e);
     };
     
     // set the default onKeyUp handler
     UserInput.prototype.onKeyUp = function(e) {
       ReleaseKey(this, e);
     };
     
     UserInput.prototype.onEnter = null;
     UserInput.prototype.onEscape = null;
     
     // clear the command history
     UserInput.prototype.clearHistory = function() {
       this.history = [];
       this.ncommand = 0;
       this.save_current = '';
       this.current = -1;
     };
     
     // push a command onto the history list and clear the input box
     UserInput.prototype.saveCommand = function() {
       if (this.root.value !== '') {
         this.history[this.ncommand] = this.root.value;
         this.ncommand++;
         this.save_current = '';
         this.current = -1;
         this.root.value = '';
       }
     };
     
     // cycle the history backward
     UserInput.prototype.cycleBackward = function() {
       // save the current entry in case we come back
       console.log("cycle backwards");
       if (this.current < 0) {
         this.save_current = this.root.value;
       }
       
       // cycle command history backward
       if (this.current < this.ncommand - 1) {
         this.current++;
         this.root.value = this.history[this.ncommand - this.current - 1];
       }
     };
     
     // cycle the history forward
     UserInput.prototype.cycleForward = function () {
       // cycle command history forward
       console.log("cycle forwards");
       if (this.current > 0) {
         this.current--;
         this.root.value = this.history[this.ncommand - this.current - 1];
       } else if (this.current === 0) {
         // recall the current entry if they had typed something already
         this.current = -1;
         this.root.value = this.save_current;
       }
     };
     
     
     
     // move the input cursor to the end of the input elements current text
     UserInput.prototype.moveCursor = function() {
       if (typeof this.root.selectionStart === "number") {
           this.root.selectionStart = this.root.selectionEnd = this.root.value.length;
       } else if (typeof this.root.createTextRange !== "undefined") {
           this.focus();
           var range = this.root.createTextRange();
           range.collapse(false);
           range.select();
       }
     };
     
     
     
     // clear the current input text
     UserInput.prototype.clear = function() {
       this.root.value = '';
     };
     
     // get the current text in the input box
     UserInput.prototype.value = function() {
       return this.root.value;
     };
     
     // refocus the input box
     UserInput.prototype.focus = function() {
       var text = "";
       if (window.getSelection) {
         text = window.getSelection().toString();
       } else if (document.selection && document.selection.type != "Control") {
         text = document.selection.createRange().text;
       }
       
       if (text === "") {
         this.root.focus();
       }
     };
     
     // user-defined keys for command history
     UserInput.prototype.keyCycleForward = null;
     UserInput.prototype.keyCycleBackward = null;
    
     UserInput.ctl_u = function( that, key) {
        if(key.code === 85 && key.ctrl) {
           return 1;
        } else {
           return 0;
        }
     };

     UserInput.ctl_l = function( that, key) {
        if(key.code === 76 && key.ctrl) {
           return 1;
        } else {
           return 0;
        }
     };
 
     UserInput.isKeyCycleForward = function(that, key) {
       if (that && that.keyCycleForward) {
         return that.keyCycleForward(key);
       } else {
         // default key is ctrl+n
         return (key.code === 78 && key.ctrl);
       }
     };
     
     UserInput.isKeyCycleBackward = function (that, key) {
       if (that && that.keyCycleBackward) {
         return that.keyCycleBackward(key);
       } else {
         // default key is ctrl+p
         return (key.code === 80 && key.ctrl);
       }
     };
     
     
     
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     // some string helper functions for replacing links and user input tokens
   
     // Example onLine() handler that linkifies URLs in text.
     function LinkHandler(that, lineBuf) {
       // Merge text so we can scan it.
       if (!lineBuf.length) {
         return;
       }
   
       var line = '';
       for (var ii = 0, ilen = lineBuf.length; ii < ilen; ++ii) {
         line += lineBuf[ii].nodeValue;
       }
   
       // Scan the merged text for links.
       var links = LinkHandler.scan(line);
       if (!links.length) {
         return;
       }
   
       // Find the start and end text nodes.
       var nodeIdx = 0, nodeStart = 0, nodeEnd = lineBuf[0].nodeValue.length;
       for (var ii = 0, ilen = links.length; ii < ilen; ++ii) {
         var info = links[ii], startOff, startNode, endOff, endNode;
   
         while (nodeEnd <= info.start) {
           nodeStart = nodeEnd;
           nodeEnd += lineBuf[++nodeIdx].nodeValue.length;
         }
   
         startOff = info.start - nodeStart;
         startNode = lineBuf[nodeIdx];
   
         while (nodeEnd < info.end) {
           nodeStart = nodeEnd;
           nodeEnd += lineBuf[++nodeIdx].nodeValue.length;
         }
   
         endOff = info.end - nodeStart;
         endNode = lineBuf[nodeIdx];
   
         // Wrap the link text.
         // TODO: In this version, we won't try to cross text nodes.
         // TODO: Discard any text nodes that are already part of links?
         if (startNode !== endNode) {
           window.console && window.console.warn('link', info);
           continue;
         }
   
         lineBuf[nodeIdx] = endNode.splitText(endOff);
         nodeStart += endOff;
   
         var middleNode = startNode.splitText(startOff);
         var anchor = document.createElement('a');
         middleNode.parentNode.replaceChild(anchor, middleNode);
   
         anchor.target = '_blank';
         if (info.url === '' && info.xch_cmd !== '') {
           anchor.setAttribute('onClick', 'this.onCommand("'+info.xch_cmd+'");');
           anchor.onCommand = that.onCommand;
         } else {
           anchor.href = info.url;
         }
         anchor.appendChild(middleNode);
       }
     }
   
     // Link scanner function.
     // TODO: Customizers may want to replace this, since regular expressions
     // ultimately limit how clever our heuristics can be.
     LinkHandler.scan = function (line) {
       var links = [], result;
   
       LinkHandler.regex.lastIndex = 0;
       while ((result = LinkHandler.regex.exec(line))) {
         var info = {};
   
         info.start = result.index + result[1].length;
         info.xch_cmd = '';
         if (result[2]) {
           result = result[2];
           info.url = result;
         } else if (result[3]) {
           result = result[3];
           info.url = 'mailto:' + result;
         } else if (result[4]) {
           result = result[4];
           info.url = '';
           info.xch_cmd = 'help ' + result;
           info.className = "ansi-1-37";
         }
   
         info.end = info.start + result.length;
   
         links[links.length] = info;
       }
   
       return links;
     };
   
     // LinkHandler regex:
     //
     // 1. Links must be preceded by a non-alphanumeric delimiter.
     // 2. Links are matched greedily.
     // 3. URLs must start with a supported scheme.
     // 4. E-mail addresses are also linkified.
     // 5. Twitter users and hash tags are also linkified.
     //
     // TODO: This can be improved (but also customized). One enhancement might be
     // to support internationalized syntax.
     LinkHandler.regex = /(^|[^a-zA-Z0-9]+)(?:((?:http|https):\/\/[-a-zA-Z0-9_.~:\/?#[\]@!$&'()*+,;=%]+[-a-zA-Z0-9_~:\/?#@!$&*+;=%])|([-.+a-zA-Z0-9_]+@[-a-zA-Z0-9]+(?:\.[-a-zA-Z0-9]+)+)|(@[a-zA-Z]\w*))/g;
   
     // set the default line handler for the terminal to use the LinkHandler
     Terminal.prototype.onLine = LinkHandler;
   
     // detect if more user input is required for a pueblo command
     function ReplaceToken(command) {
       var cmd = command;
       var regex = /\?\?/;
       
       // check for the search token '??'
       if (cmd.search(regex) !== -1) {
         var val = prompt(command);
         
         if (val === null) {
           // user cancelled the prompt, don't send any command
           cmd = '';
         } else {
           // replace the ?? token with the prompt value
           cmd = cmd.replace(regex, val);
         }
       }
       
       return cmd;
     };
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // default handler for key press events
     function PressKey(that, e) {
       var key = { code: (e.keyCode ? e.keyCode : e.which),
                   ctrl: e.ctrlKey,
                   shift: e.shiftKey,
                   alt: e.altKey };
   
       var prevent = true;
//       console.log('key: ' + key.code);
      
       if(UserInput.ctl_u(that,key)) {
          that.root.value = '';
       } else if(UserInput.ctl_l(that,key)) {
          that.onEnter('/key_ctl_l\r\n');
       } else if (UserInput.isKeyCycleBackward(that, key)) {
         console.log('cycle backwards');
         // cycle history backward
         that.cycleBackward();
       } else if (UserInput.isKeyCycleForward(that, key)) {
         // cycle history forward
         console.log('cycle forward');
         that.cycleForward();
   
       } else if (key.code === 13) {
         // enter key
         
         // save the command string and clear the input box
         var cmd = that.root.value;
         that.saveCommand();
   
         // pass through to the local callback for sending data
         that.onEnter && that.onEnter(cmd);
           
       } else if (key.code === 27) {
   
         // pass through to the local callback for the escape key
   //      that.onEscape && that.onEscape();
   
   //    } else if  (that.last_key === 27 && key.code === 119) {
       } else if (that.last_key == 27 && key.code === 87) {
         that.onEnter('/key_esc_w\r\n');
       } else if  (that.last_key == 27 && key.code === 76) {
         that.onEnter('/key_ctl_l\r\n');
       } else if (key.code === 9) {
         that.onEnter('/key_tab\r\n');
       } else if (key.code === 38) {
         that.onEnter('/key_up\r\n' );
       } else if (key.code === 40) {
         that.onEnter('/key_down\r\n');
       } else if (key.code === 34) {
         that.onEnter('/key_pgdn\r\n');
       } else if (key.code === 33) {
         that.onEnter('/key_pgup\r\n');
       } else { 
         // didn't capture anything, pass it through
         prevent = false;
   
       }
       
       that.last_key = key.code; 
   
       if (prevent) {
         e.preventDefault();
       }
   
       // make sure input retains focus
       that.focus();
     };
   
   
   
     // default handler for key release events
     function ReleaseKey(that, e) {
       var key = { code: (e.keyCode ? e.keyCode : e.which),
                   ctrl: e.ctrlKey,
                   shift: e.shiftKey,
                   alt: e.altKey };
   
       if (UserInput.isKeyCycleBackward(that, key) ||
           UserInput.isKeyCycleForward(that, key)) {
   
         // move the cursor to end of the input text after a history change
         that.moveCursor();
       }
     };
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // Module exports.
     var exports = {};
   
     // open a websocket connection to url
     exports.connect = function (url) {
       return new Connection(url);
     };
   
     // create a terminal emulator that appends output to root
     exports.output = function (root) {
       return new Terminal(root);
     };
     
     // create an input handler that saves and recalls command history
     exports.input = function (root) {
       return new UserInput(root);
     };
     
     // default key event callback handlers
     exports.pressKey = PressKey;
     exports.releaseKey = ReleaseKey;
     
     // helper for replacing ?? in string with user input
     exports.parseCommand = ReplaceToken;
     
     // export the LinkHandler just in case it's useful elsewhere
     exports.parseLinks = LinkHandler;
   
    return exports;
   })(window, document);
START: muddler_client.html
   <!DOCTYPE html>
   <html><head><meta name="viewport" content="width=device-width, maximum-scale=1" charset="UTF-8">


   
   <link rel="stylesheet" href="muddler_ansi.css">
   <link rel="stylesheet" href="muddler_style.css">
   <base target="_blank">
   <title>Muddler</title></head>
   
   <body onLoad="input.focus()"
          setTimeout(conn.close, 1000);"
         onClick="input.focus()">
   
   <div id="terminal">
     <div id="output" class="ansi-37 ansi-40"></div>
     <div id="bar" class="ansi-37 ansi-1-37"></div>
     <div id="prompt" class="ansi-37 ansi-1-37"></div>
     <div id="bartime" class="ansi-37 ansi-1-37"></div>
     <textarea id="input" autocomplete="off" autofocus></textarea>
   </div>
     <div id="buttonbar" "class=buttonbar" style=width:100%>
         <button style="display:inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 0px 1px 1px;padding:0;float:left" onclick="input.onEnter('/key_pgup 5')">Up</button>
         <button style="display:inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 0px 1px 1px;padding:0;float:left" onclick="input.onEnter('/key_pgdn 5')">Down</button>
         <button style="display: inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 0px 1px 1px;padding 0;float:left" onclick="input.onEnter('/key_up')">Next</button>
         <button style="display: inline-block;width:25%;height:35px;border: 1px solid black;border-width:1px 1px 1px 1px;padding 0;float:left" onclick="input.onEnter('/key_down')">Prev</button>
     </div>
     </div class=triangle>
        <div class="inner-triangle" onclick="input.onEnter('/mobile')"><span>muddler</span></div>
        <div class="outer-triangle"></div>
     </div>
   
   <script type="text/javascript" src="muddler_client.js"></script>
   <script type="text/javascript">
     var serverAddress = window.location.hostname;
     var serverSSL = window.location.protocol == "https:";
     var serverProto = serverSSL ? "wss://" : "ws://";
     var serverPort = '__PORT__';
     
     var customUrl = window.location.search.substring(1) ? window.location.search.substring(1) : serverAddress + ":" + serverPort;
     // The connection URL is ws://host:port/wsclient (or wss:// for SSL connections)
   //  var serverUrl = serverProto + customUrl + '/wsclient'
     var serverUrl = serverProto + customUrl + '/connect'
     // define the input box, output terminal, and network connection
     var output = WSClient.output(document.getElementById('output'));
     var cmdprompt = WSClient.output(document.getElementById('prompt'));
     var bar = WSClient.output(document.getElementById('bar'));
     var bartime = WSClient.output(document.getElementById('bartime'));
     var input = WSClient.input(document.getElementById('input'));
     var conn = WSClient.connect(serverUrl);
     var last_conn = +new Date();
     // function to send a command string to the server
     function sendCommand(cmd) {
       if (conn.isConnected()) {
         if (cmd !== '') {
           conn.sendText(cmd);
   //        output.appendMessage('localEcho', cmd);
         }
       } else {
         // connection was broken, let's reconnect
         const now = +new Date();
         if(last_conn == undefined || now - last_conn > 5000) {
            last_conn = now;
            conn.reconnect();
            output.appendMessage('logMessage', '%% Reconnecting to server...' + conn.socket.readyState);
         }
       }
     }
  
     function get_xy_size() {
         var out = document.getElementById('output')
         var css = getComputedStyle(out,null);
         var ff  = css.getPropertyValue("font-family");
         var fs  = css.getPropertyValue("font-size");
         var temp = document.createElement('span');

         temp.style = "margin:0px;padding:0px;font-family:"+ff+
                      ";font-size:" + fs;
        
         temp.innerText = "0123456789";
         var element = document.body.appendChild(temp);
         var x = Math.round(out.offsetHeight / (temp.offsetHeight-2));
         var y = Math.round(out.offsetWidth / (temp.offsetWidth / 10));
         temp.parentNode.removeChild(temp);
         return x + "," + y + "," + fs + "-" + ff + "=1";
     }

     // just log a standard message on these socket status events
     conn.onOpen = function (evt) { 
         output.appendMessage('logMessage', '%% Connected.');
         sendCommand('/web_size ' + get_xy_size() + '\r\n');
         // ENABLE_MOBILE
         // ENABLE_DARK
         // sendCommand(window.prompt("Enter password","xyzzy"));
     };
     conn.onError = function (evt) { output.appendMessage('logMessage', '%% Connection error!'); console.log(evt); };
     conn.onClose = function (evt) { output.appendMessage('logMessage', '%% Connection closed.'); };
     // handle incoming text, html, pueblo, or command prompts
   
   //        conn.onMessage = function (code,text) {
    //              output.appendText('### ' + code + ' : ' + text);
     //      };
   
     conn.onText = function (text) { output.appendText(text); };
     conn.onHTML = function (html) { output.appendHTML(html); };
     conn.onPueblo = function (html) { output.appendPueblo(html); };
     conn.onBar = function (html) { bar.clear();bar.appendText(html); };
     conn.onBarTime = function (html) { bartime.clear();bartime.appendText(html); };
     conn.onPrompt = function (text) { cmdprompt.clear(); cmdprompt.appendText(text + '\r\n'); };
     
     // handle incoming JSON objects. requires server specific implementation
     conn.onObject = function (obj) { console.log('unhandled JSON object' + obj); };
     // pueblo command links, prompt for user input and replace ?? token if present
     output.onCommand = function(cmd) { sendCommand(WSClient.parseCommand(cmd)); };
     // enter key passthrough from WSClient.pressKey
     input.onEnter = function(cmd) { sendCommand(cmd); };
     
     // escape key passthrough from WSClient.pressKey
     input.onEscape = function () { this.clear(); };
     
     // input key event callbacks. here we show the defaults
     // provided by WSClient.pressKey and WSClient.releaseKey
     // input.onKeyDown = function(e) { WSClient.pressKey(this, e); };
     // input.onKeyUp = function(e) { WSClient.releaseKey(this, e); };
     
     // which keys are used for cycling through command history?
     // here we show the default keys, ctrl+p and ctrl+n
     // input.keyCycleForward = function(key) { return (key.code === 78 && key.ctrl); }; // ctrl+n
     // input.keyCycleBackward = function(key) { return (key.code === 80 && key.ctrl); }; // ctrl+p
     
   </script>
   
   </body>
   </html>
